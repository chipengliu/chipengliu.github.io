<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一次 dispatch_once 引发的 crash 的思考</title>
      <link href="/2020/10/24/dispatch-once-crash/"/>
      <url>/2020/10/24/dispatch-once-crash/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>前不久项目上一段代码出现 crash，因为 dispatch_once 出现死锁问题</p><a id="more"></a><p>出现问题的代码简化后如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@interface UIDevice (Screen)</span><br><span class="line"></span><br><span class="line">- (BOOL)isIPhoneX;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation UIDevice (Screen)</span><br><span class="line"></span><br><span class="line">- (BOOL)isIPhoneX &#123;</span><br><span class="line">    static BOOL isIPhoneX = NO;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        if (@available(iOS 11.0, *)) &#123;</span><br><span class="line">            UIWindow *mainWindow = [UIApplication sharedApplication].windows.firstObject;</span><br><span class="line">            BOOL shouldRemoveWindow = NO;</span><br><span class="line">            if (!mainWindow) &#123;</span><br><span class="line">                mainWindow = [[UIWindow alloc] init];</span><br><span class="line">                mainWindow.backgroundColor = [UIColor clearColor];</span><br><span class="line">                shouldRemoveWindow = YES;</span><br><span class="line">            &#125;</span><br><span class="line">            if (mainWindow.safeAreaInsets.bottom &gt; 0.f) &#123;</span><br><span class="line">                isIPhoneX = YES;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            if (shouldRemoveWindow) &#123;</span><br><span class="line">                [mainWindow removeFromSuperview];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return isIPhoneX;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">- (BOOL)prefersStatusBarHidden &#123;</span><br><span class="line">    if ([[UIDevice currentDevice] isIPhoneX]) &#123;</span><br><span class="line">        NSLog(@&quot;do something&quot;);</span><br><span class="line">      return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>UIDevice分类方法 <code>-isIPhoneX</code> 内部调用 window 的 <code>safeAreaInsets</code> 属性，会触发当前显示的 ViewController <code>-prefersStatusBarHidden</code> 方法，而 <code>-prefersStatusBarHidden</code>  内部又再次调用了 <code>-isIPhoneX</code> 从而导致 dispatch_once 递归死锁。</p><h2 id="dispatch-once-原理"><a href="#dispatch-once-原理" class="headerlink" title="dispatch_once 原理"></a>dispatch_once 原理</h2><p>那么 dispatch_once 为什么会递归使用的时候造成死锁呢？</p><p>来看看其源码实现 （这里为了简化代码分析，选用libdispatch-339.1.9，项目上 GCD 版本和此版本不一样，但核心逻辑大致相同）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">dispatch_once(dispatch_once_t *val, dispatch_block_t block)</span><br><span class="line">&#123;</span><br><span class="line">  // 1. dispatch_once 逻辑入口</span><br><span class="line">dispatch_once_f(val, block, _dispatch_Block_invoke(block));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">struct _dispatch_once_waiter_s &#123;</span><br><span class="line">volatile struct _dispatch_once_waiter_s *volatile dow_next;</span><br><span class="line">_dispatch_thread_semaphore_t dow_sema;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define DISPATCH_ONCE_DONE ((struct _dispatch_once_waiter_s *)~0l)</span><br><span class="line"></span><br><span class="line">void</span><br><span class="line">dispatch_once_f(dispatch_once_t *val, void *ctxt, dispatch_function_t func)</span><br><span class="line">&#123;</span><br><span class="line">struct _dispatch_once_waiter_s * volatile *vval =</span><br><span class="line">(struct _dispatch_once_waiter_s**)val;</span><br><span class="line">struct _dispatch_once_waiter_s dow = &#123; NULL, 0 &#125;;</span><br><span class="line">struct _dispatch_once_waiter_s *tail, *tmp;</span><br><span class="line">_dispatch_thread_semaphore_t sema;</span><br><span class="line"></span><br><span class="line">  // 2. 判断 vval == NULL，如果 vval 的初始值为 NULL，返回 YES，同时把 &amp;dow 赋值给 vval；否则返回 NO。</span><br><span class="line">if (dispatch_atomic_cmpxchg(vval, NULL, &amp;dow, acquire)) &#123;</span><br><span class="line">    // 2.1. 执行 block</span><br><span class="line">_dispatch_client_callout(ctxt, func);</span><br><span class="line"></span><br><span class="line">dispatch_atomic_maximally_synchronizing_barrier();</span><br><span class="line">// above assumed to contain release barrier</span><br><span class="line">    </span><br><span class="line">    // 2.2. dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE) 将 vval 修改为指定状态 DISPATCH_ONCE_DONE</span><br><span class="line">    // 表示 block 以及执行完成</span><br><span class="line">tmp = dispatch_atomic_xchg(vval, DISPATCH_ONCE_DONE, relaxed);</span><br><span class="line">    </span><br><span class="line">    // 2.3. 遍历链表的节点（block 执行过程期间加入的）</span><br><span class="line">    // 调用 _dispatch_thread_semaphore_signal 来唤醒等待中的信号量</span><br><span class="line">tail = &amp;dow;</span><br><span class="line">while (tail != tmp) &#123;</span><br><span class="line">while (!tmp-&gt;dow_next) &#123;</span><br><span class="line">        // 2.4 若 tmp 的 next 指针还没更新完毕，等待其更新完毕</span><br><span class="line">dispatch_hardware_pause();</span><br><span class="line">&#125;</span><br><span class="line">sema = tmp-&gt;dow_sema;</span><br><span class="line">tmp = (struct _dispatch_once_waiter_s*)tmp-&gt;dow_next;</span><br><span class="line">      </span><br><span class="line">      // 2.5 发信号，通知链表其他节点，当前节点的任务以及执行完成</span><br><span class="line">_dispatch_thread_semaphore_signal(sema);</span><br><span class="line">&#125;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    // 3. 若首个任务未执行完毕</span><br><span class="line">dow.dow_sema = _dispatch_get_thread_semaphore();</span><br><span class="line">tmp = *vval;</span><br><span class="line">for (;;) &#123;</span><br><span class="line">      // 3.1 若首个任务已经完成，结束等待</span><br><span class="line">if (tmp == DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">      // 3.2 后续任务加入到链表</span><br><span class="line">      // 3.2.1 若 vval != tmp, for 循环等待其他节点插入操作完成</span><br><span class="line">if (dispatch_atomic_cmpxchgvw(vval, tmp, &amp;dow, &amp;tmp, release)) &#123;</span><br><span class="line">        // 3.2.2 若 vval == tmp，vval = &amp;dow，更新队列节点为当前节点</span><br><span class="line">dow.dow_next = tmp;</span><br><span class="line">        // 3.3 阻塞当前线程</span><br><span class="line">_dispatch_thread_semaphore_wait(dow.dow_sema);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">_dispatch_put_thread_semaphore(dow.dow_sema);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2020/10/24/dispatch-once-crash/image-20201025190248972.png" alt="image-20201025190248972"></p><h2 id="问题原因"><a href="#问题原因" class="headerlink" title="问题原因"></a>问题原因</h2><p><code>- (BOOL)isIPhoneX</code> 方法中 dispatch_once  传入的 block 内部在相同线程递归执行 <code>- (BOOL)isIPhoneX</code> ，导致前一个任务被后一个任务阻塞，后一个任务又依赖于前一个的完成状态，导致死锁</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><ol><li><p>上文的 crash 是从逻辑细节看，因为传入 dispatch_once 的 block 内部递归执行触发同一个 dispatch_once。而从函数设计来看，是因为函数内部逻辑不够单纯，出现了外部依赖。dispatch_once 执行的 block 应该尽可能保持单纯、简单。</p></li><li><p>对于 <code>- (BOOL)isIPhoneX</code> 这个case 来说，允许极端情况下执行多次内部判断逻辑对性能影响不大，退而求之，可使用静态全局变量保存执行记录；如果遇到极端场景，一开始是并发执行，就允许多次执行完整的判断逻辑，而之后直接使用计算过的结果。这里可以参考QMUI 中判断全面屏的逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">static NSInteger isNotchedScreen = -1;</span><br><span class="line">+ (BOOL)isNotchedScreen &#123;</span><br><span class="line">    if (@available(iOS 11, *)) &#123;</span><br><span class="line">        if (isNotchedScreen &lt; 0) &#123;</span><br><span class="line">            if (@available(iOS 12.0, *)) &#123;</span><br><span class="line">                SEL peripheryInsetsSelector = NSSelectorFromString([NSString stringWithFormat:@&quot;_%@%@&quot;, @&quot;periphery&quot;, @&quot;Insets&quot;]);</span><br><span class="line">                UIEdgeInsets peripheryInsets = UIEdgeInsetsZero;</span><br><span class="line">                [[UIScreen mainScreen] qmui_performSelector:peripheryInsetsSelector withPrimitiveReturnValue:&amp;peripheryInsets];</span><br><span class="line">                if (peripheryInsets.bottom &lt;= 0) &#123;</span><br><span class="line">                    UIWindow *window = [[UIWindow alloc] initWithFrame:UIScreen.mainScreen.bounds];</span><br><span class="line">                    peripheryInsets = window.safeAreaInsets;</span><br><span class="line">                    if (peripheryInsets.bottom &lt;= 0) &#123;</span><br><span class="line">                        UIViewController *viewController = [UIViewController new];</span><br><span class="line">                        window.rootViewController = viewController;</span><br><span class="line">                        if (CGRectGetMinY(viewController.view.frame) &gt; 20) &#123;</span><br><span class="line">                            peripheryInsets.bottom = 1;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                isNotchedScreen = peripheryInsets.bottom &gt; 0 ? 1 : 0;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                isNotchedScreen = [QMUIHelper is58InchScreen] ? 1 : 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        isNotchedScreen = 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return isNotchedScreen &gt; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://gcc.gnu.org/onlinedocs/gcc-4.1.1/gcc/Atomic-Builtins.html" target="_blank" rel="noopener">5.44 Built-in functions for atomic memory access</a></p><p><a href="https://satanwoo.github.io/2016/04/11/dispatch-once/" target="_blank" rel="noopener">滥用单例之dispatch_once死锁</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URLSession HTTP 缓存机制初探</title>
      <link href="/2020/05/19/urlsession-cache/"/>
      <url>/2020/05/19/urlsession-cache/</url>
      
        <content type="html"><![CDATA[<p>HTTP/HTTPS 可以通过 HTTP Response 中的 header 字段（如 <code>Cache-Control</code>、<code>Expires</code>、<code>Last-Modified</code>）告诉 client 是否需要对 response 进行缓存。有未过期的缓存，客户端可以使用缓存避免冗余的网络请求。</p><p>接下来探讨几个问题：</p><ol><li><p>HTTP 协议如何利用 header 控制缓存的？</p></li><li><p>iOS（URLSession）对于非幂等的网络请求是否也支持本地缓存（如 POST）？ 疑问来自于 <a href="http://www.faqs.org/rfcs/rfc2616.html" target="_blank" rel="noopener">rfc2616</a></p><blockquote><p>Responses to this method are not cacheable, unless the response<br>includes appropriate Cache-Control or Expires header fields. However,<br>the 303 (See Other) response can be used to direct the user agent to<br>retrieve a cacheable resource.</p></blockquote></li></ol><a id="more"></a><ol><li>GET/POST 是否都会进行缓存</li><li>缓存由哪些 HTTP header 字段影响</li><li>边界场景<ol><li><del>response 大于磁盘空间的5%不会触发<code>willCacheResponse</code> <a href="https://stackoverflow.com/questions/20290580/nscachedurlresponse-willcacheresponse-does-not-get-called" target="_blank" rel="noopener">参考</a></del></li></ol></li></ol><h2 id="HTTP-缓存机制"><a href="#HTTP-缓存机制" class="headerlink" title="HTTP 缓存机制"></a>HTTP 缓存机制</h2><p>利用缓存机制，HTTP 发请求可以可以分为3种情况：</p><ol><li>client 不发送 HTTP 请求， 直接使用本地的缓存。</li><li>client 发送请求，server 校验请求头中的字段（如 <code>If-Modified-Since</code>、<code>If-None-Match</code>）并判断 client 缓存为有效，server 返回 304 状态码通知 client 使用本地缓存，304 的响应头也可以同时更新缓存文档的过期时间。</li><li>和场景2类似，如果如果 server 判断 client 的缓存已经失效会返回 200 状态码和新的响应数据，client 根据响应头更新本地的缓存。</li></ol><h3 id="控制缓存常用的-header-字段"><a href="#控制缓存常用的-header-字段" class="headerlink" title="控制缓存常用的 header 字段"></a>控制缓存常用的 header 字段</h3><h4 id="1-Cache-Control"><a href="#1-Cache-Control" class="headerlink" title="1. Cache-Control"></a>1. Cache-Control</h4><blockquote><p><strong>HTTP/1.1</strong>定义的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener"><code>Cache-Control</code></a> 头用来区分对缓存机制的支持情况， <em>请求头和响应头都支持这个属性</em>。通过它提供的不同的值来定义缓存策略。</p></blockquote><p><strong>在请求中使用：</strong></p><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">no-store</td><td style="text-align:center">忽略本地缓存也就是拿到 response 不进行保存，每次 client 发起的请求都会下载完整的响应内容</td></tr><tr><td style="text-align:center">no-cache</td><td style="text-align:center">每次有请求发出时（即便是有未过期的本地缓存），带上相关字段 （如 <code>If-Modified-Since</code>、<code>If-None-Match</code>），server 端会验证请求中所描述的缓存是否过期，若未过期则返回 304 告知 client 使用本地缓存</td></tr><tr><td style="text-align:center">only-if-cached</td><td style="text-align:center">告诉（代理）服务器，客户端希望获取缓存的内容（若有），而不用向源服务器发请求。</td></tr><tr><td style="text-align:center">max-age</td><td style="text-align:center"><code>max-age=</code> 表示资源能够被缓存（保持新鲜）的最大时间，是距离请求发起的时间的秒数。</td></tr></tbody></table><p><strong>在响应中使用：</strong></p><table><thead><tr><th style="text-align:center">字段</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">no-store</td><td style="text-align:center">不直接使用缓存，要求想服务器发起（新鲜度）请求</td></tr><tr><td style="text-align:center">no-cache</td><td style="text-align:center">所有内容都不会被保存到缓存</td></tr><tr><td style="text-align:center">must-revalidate</td><td style="text-align:center">告诉 client，本地缓存过期前，可以使用缓存；本地缓存一旦过期，必须去 server 进行有效性校验。</td></tr><tr><td style="text-align:center">only-if-cached</td><td style="text-align:center">告诉（代理）服务器，客户端希望获取缓存的内容（若有），而不用向源服务器发请求。</td></tr><tr><td style="text-align:center">max-age</td><td style="text-align:center">告诉客户端该资源新鲜度的时间周期</td></tr></tbody></table><p>另外一些如  <code>private</code>、<code>public</code>  字段比较少用，这里不再阐述。</p><h4 id="2-Last-Modified"><a href="#2-Last-Modified" class="headerlink" title="2. Last-Modified"></a>2. Last-Modified</h4><p>响应头可以作为一种弱校验器。说它弱是因为它只能精确到一秒。如果响应头里含有这个信息，客户端可以在后续的请求中带上 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since" target="_blank" rel="noopener"><code>If-Modified-Since</code></a> /  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since" target="_blank" rel="noopener"><code>If-Unmodified-Since</code></a> 来验证缓存。</p><p>当向服务端发起缓存校验的请求时，服务端会返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200" target="_blank" rel="noopener"><code>200</code></a> ok表示返回正常的结果或者 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304" target="_blank" rel="noopener"><code>304</code></a> Not Modified(不返回body)表示浏览器可以使用本地缓存文件。304的响应头也可以同时更新缓存文档的过期时间。</p><ul><li><strong>If-Modified-Since</strong> : 是一个条件式请求首部，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200" target="_blank" rel="noopener"><code>200</code></a> 。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304" target="_blank" rel="noopener"><code>304</code></a> 响应，而在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified" target="_blank" rel="noopener"><code>Last-Modified</code></a> 首部中会带有上次修改时间。 不同于  <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Unmodified-Since" target="_blank" rel="noopener"><code>If-Unmodified-Since</code></a>, <code>If-Modified-Since</code> 只可以用在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener"><code>GET</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD" target="_blank" rel="noopener"><code>HEAD</code></a> 请求中。</li><li><strong>If-Unmodified-Since</strong>: HTTP协议中的 <strong><code>If-Unmodified-Since</code></strong> 消息头用于请求之中，使得当前请求成为条件式请求：只有当资源在指定的时间之后没有进行过修改的情况下，服务器才会返回请求的资源，或是接受 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener"><code>POST</code></a> 或其他 non-<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/safe" target="_blank" rel="noopener">safe</a> 方法的请求。如果所请求的资源在指定的时间之后发生了修改，那么会返回 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/412" target="_blank" rel="noopener"><code>412</code></a> (Precondition Failed) 错误。</li></ul><p><code>If-Modified-Since</code> 和 <code>If-Unmodified-Since</code> 的区别是：</p><ol><li>If-Modified-Since 告诉服务器如果时间一致，返回状态码 <code>304</code></li><li>If-Unmodified-Since 告诉服务器如果时间不一致，返回状态码 <code>412</code></li></ol><h4 id="3-Etag"><a href="#3-Etag" class="headerlink" title="3. Etag"></a>3. Etag</h4><p><code>ETag</code> HTTP响应头是资源的特定版本的标识符，类似于 hash 值。HTTP响应包会通过 Etag 把标识符告诉客户端。客户端下次请求时通过 <code>If-None-Match</code> 或 <code>If-Match</code> 带上该值，服务器对该值进行对比校验：如果一致则不要返回资源。</p><p><code>If-None-Match</code> 和 <code>If-Match</code> 的区别是：</p><ol><li>If-None-Match：告诉服务器如果一致，返回状态码 <code>304</code>，不一致则返回资源</li><li>If-Match：告诉服务器如果不一致，返回状态码 <code>412</code></li></ol><h3 id="有了-Last-Modified-为什么还需要-Etag-？"><a href="#有了-Last-Modified-为什么还需要-Etag-？" class="headerlink" title="有了 Last-Modified 为什么还需要 Etag ？"></a>有了 Last-Modified 为什么还需要 Etag ？</h3><p>ETag 是为了解决 Last-modified 的一些缺陷：</p><ul><li><p>一些资源的最后修改时间变了，但是内容没有改变，造成荣誉的请求</p></li><li><p>Last-modified 只能精确到秒级，如果一秒钟文件被多次修改，可能会导致客户端不能及时更新缓存数据。</p></li></ul><blockquote><p><code>Etag</code> 是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。<strong><code>Last-Modified</code> 与 <code>ETag</code> 是可以一起使用的，服务器会优先验证 <code>ETag</code>，一致的情况下，才会继续比对 <code>Last-Modified</code>，最后才决定是否返回 304</strong>。</p></blockquote><h2 id="URLSession-的缓存表现"><a href="#URLSession-的缓存表现" class="headerlink" title="URLSession 的缓存表现"></a>URLSession 的缓存表现</h2><p>URLSession 提供的缓存机制有一下几种，可以通过 NSURLSessionConfiguration/NSRequest 对象进行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)</span><br><span class="line">&#123;</span><br><span class="line">  // 默认的缓存策略，也是按照HTTP协议，根据不同字段进行标准的缓存策略</span><br><span class="line">    NSURLRequestUseProtocolCachePolicy = 0,</span><br><span class="line">    </span><br><span class="line">    // 忽略系统本地缓存，直接向服务器请求</span><br><span class="line">    NSURLRequestReloadIgnoringLocalCacheData = 1,</span><br><span class="line">  </span><br><span class="line">    // 忽略本地缓存，并告诉代理服务器不使用缓存，直接向源服务器请求数据</span><br><span class="line">    NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4,</span><br><span class="line">    NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData,</span><br><span class="line"></span><br><span class="line">    // 不管过期与否都使用本地缓存，若没有则向服务器请求</span><br><span class="line">    NSURLRequestReturnCacheDataElseLoad = 2,</span><br><span class="line">    // 不管过期与否都使用本地缓存，若没有不向服务器请求，返回错误给上层</span><br><span class="line">    NSURLRequestReturnCacheDataDontLoad = 3,</span><br><span class="line"></span><br><span class="line">    // 无论本地缓存过期与否，都先向服务器验证缓存的有效性</span><br><span class="line">    NSURLRequestReloadRevalidatingCacheData = 5,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>本文目的是验证 iOS 的 post 请求是否也会进行缓存，所以这里使用默认的缓存策略，也就是 <code>NSURLRequestUseProtocolCachePolicy</code></p><p>验证步骤分2步:</p><ol><li>app 使用 get 请求，回包分别返回 <code>Cache-control</code> 、<code>Last-Modified</code> 、 <code>ETag</code> 的表现</li><li>app 使用 post 请求，回包分别返回  <code>Cache-control</code> 、<code>Last-Modified</code> 、 <code>ETag</code> 的表现</li></ol><p>为了方便验证，服务端使用 beego 搭建本地简易 server</p><h3 id="URLSession-GET-请求缓存"><a href="#URLSession-GET-请求缓存" class="headerlink" title="URLSession GET 请求缓存"></a>URLSession GET 请求缓存</h3><p>客户端主要代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];</span><br><span class="line">    config.requestCachePolicy = 0;</span><br><span class="line">    self.session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:NSOperationQueue.mainQueue];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)GET:(id)sender &#123;</span><br><span class="line">    NSURL *URL = [NSURL URLWithString:@&quot;http://127.0.0.1:8080/get&quot;];</span><br><span class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:URL cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:15];</span><br><span class="line">NSURLSessionTask *task = [self.session dataTaskWithRequest:request];</span><br><span class="line">[task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (IBAction)POST:(id)sender &#123;</span><br><span class="line">    NSURL *URL = [NSURL URLWithString:@&quot;http://127.0.0.1:8080/post&quot;];</span><br><span class="line">    NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:URL cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:15];</span><br><span class="line">    request.HTTPMethod = @&quot;POST&quot;;</span><br><span class="line">    NSURLSessionTask *task = [self.session dataTaskWithRequest:request];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - NSURLSessionDataDelegate</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line">didReceiveResponse:(NSURLResponse *)response</span><br><span class="line"> completionHandler:(void (^)(NSURLSessionResponseDisposition disposition))completionHandler &#123;</span><br><span class="line">    NSLog(@&quot;%s|response allHeaderFields=%@&quot;,</span><br><span class="line">          __func__, [(NSHTTPURLResponse *)response allHeaderFields]);</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(NSURLSessionResponseAllow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data &#123;</span><br><span class="line">    //NSString *responseStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];</span><br><span class="line">    NSLog(@&quot;%s|data length=%@&quot;,</span><br><span class="line">          __func__, @(data.length));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask</span><br><span class="line"> willCacheResponse:(NSCachedURLResponse *)proposedResponse</span><br><span class="line"> completionHandler:(void (^)(NSCachedURLResponse * _Nullable cachedResponse))completionHandler &#123;</span><br><span class="line">    NSLog(@&quot;%s|proposedResponse=%@&quot;, __func__, proposedResponse);</span><br><span class="line">    if (completionHandler) &#123;</span><br><span class="line">        completionHandler(proposedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>Cache-Control</p><ul><li>服务端代码，设置回包数据的新鲜度为 60 秒</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *GetController)</span> <span class="title">Get</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> key, strings := <span class="keyword">range</span> c.Ctx.Request.Header &#123;</span><br><span class="line">beego.Debug(key, <span class="string">"="</span>, strings)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Cache-Control: max-age=60</span></span><br><span class="line">  interval := <span class="number">60</span></span><br><span class="line">maxAge := <span class="string">"max-age="</span> + strconv.Itoa(interval)</span><br><span class="line">c.Ctx.Output.Header(<span class="string">"Cache-Control"</span>,maxAge)</span><br><span class="line">c.Data[<span class="string">"json"</span>] = &amp;jsonData&#123;</span><br><span class="line"><span class="number">10086</span>,</span><br><span class="line"><span class="string">"message"</span>,</span><br><span class="line">&#125;</span><br><span class="line">c.ServeJSON()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *PostController)</span> <span class="title">Post</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> key, strings := <span class="keyword">range</span> c.Ctx.Request.Header &#123;</span><br><span class="line">beego.Debug(key, <span class="string">"="</span>, strings);</span><br><span class="line">&#125;</span><br><span class="line">interval := <span class="number">60</span></span><br><span class="line">maxAge := <span class="string">"max-age="</span> + strconv.Itoa(interval)</span><br><span class="line">c.Ctx.Output.Header(<span class="string">"Cache-Control"</span>,maxAge)</span><br><span class="line">c.Data[<span class="string">"json"</span>] = &amp;jsonData&#123;</span><br><span class="line"><span class="number">10010</span>,</span><br><span class="line"><span class="string">"message"</span>,</span><br><span class="line">&#125;</span><br><span class="line">c.ServeJSON()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>请求结果<ol><li>GET：60秒内客户端重复触发请求，从第二次开始，会使用本地缓存，不会发出网络请求</li><li>POST：客户端每次会发出网络请求，不会进行缓存</li></ol></li></ul></li></ol><ol start="2"><li><p>Last-Modified:</p><ul><li><p>服务端代码，设置回包数据的修改时间为 1609430400 秒（2021/1/1 00:00:00）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *GetController)</span> <span class="title">Get</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ...略</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里简单处理，客户端如果带上If-Modified-Since，则都返回304告诉其用本地缓存</span></span><br><span class="line">  ims := c.Ctx.Request.Header.Get(<span class="string">"If-Modified-Since"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ims) &gt; <span class="number">0</span> &#123;</span><br><span class="line">c.Ctx.ResponseWriter.WriteHeader(<span class="number">304</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 标记资源过期时间为2020/01/01 00:00:00</span></span><br><span class="line">  c.Ctx.Output.Header(<span class="string">"Last-Modified"</span>, <span class="string">"Fri, 01 Jan 2021 00:00:00 GMT"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// ...略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *PostController)</span> <span class="title">Post</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ...略</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 这里简单处理，客户端如果带上If-Modified-Since，则都返回304告诉其用本地缓存</span></span><br><span class="line">  ims := c.Ctx.Request.Header.Get(<span class="string">"If-Modified-Since"</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ims) &gt; <span class="number">0</span> &#123;</span><br><span class="line">c.Ctx.ResponseWriter.WriteHeader(<span class="number">304</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 标记资源过期时间为2020/01/01 00:00:00</span></span><br><span class="line">  c.Ctx.Output.Header(<span class="string">"Last-Modified"</span>, <span class="string">"Fri, 01 Jan 2021 00:00:00 GMT"</span>)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// ...略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>请求结果:</p><ol><li>GET：客户端每次都会发出网路请求；第一次响应收到 server 返回的 Last-Modified， 之后的请求中会通过 If-Modified-Since 客户端缓存的修改日期给到 server 端；若 server 端返回 304，则客户端使用本地的缓存，并且 URLSession 向上返回 200 的状态码。</li><li>POST: 和 GET 表现一致</li></ol></li></ul></li><li><p>ETag</p><ul><li><p>服务端代码：利用 ETag 把资源进行标记</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">func (c *MainController) Get() &#123;</span><br><span class="line">  <span class="comment">//...略</span></span><br><span class="line">  </span><br><span class="line">ims := c.Ctx.Request.Header.Get(<span class="string">"If-Modified-Since"</span>)</span><br><span class="line"><span class="keyword">if</span> len(ims) &gt; <span class="number">0</span> &#123;</span><br><span class="line">c.Ctx.ResponseWriter.WriteHeader(<span class="number">304</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">inm := c.Ctx.Request.Header.Get(<span class="string">"If-None-Match"</span>)</span><br><span class="line"><span class="keyword">if</span> len(inm) &gt; <span class="number">0</span> &#123;</span><br><span class="line">c.Ctx.ResponseWriter.WriteHeader(<span class="number">304</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.Ctx.Output.Header(<span class="string">"ETag"</span>, <span class="string">"ETagValueGet"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.Data[<span class="string">"json"</span>] = &amp;jsonData&#123;</span><br><span class="line"><span class="number">10086</span>,</span><br><span class="line"><span class="string">"etag-message-get"</span>+inm,</span><br><span class="line">&#125;</span><br><span class="line">c.ServeJSON()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (c *PostController) Post() &#123;</span><br><span class="line">inm := c.Ctx.Request.Header.Get(<span class="string">"If-None-Match"</span>)</span><br><span class="line"><span class="keyword">if</span> len(inm) &gt; <span class="number">0</span> &#123;</span><br><span class="line">c.Ctx.ResponseWriter.WriteHeader(<span class="number">304</span>)</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">c.Ctx.Output.Header(<span class="string">"ETag"</span>, <span class="string">"ETagValuePost"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.Data[<span class="string">"json"</span>] = &amp;jsonData&#123;</span><br><span class="line"><span class="number">10010</span>,</span><br><span class="line"><span class="string">"etag-message-post"</span>+inm,</span><br><span class="line">&#125;</span><br><span class="line">c.ServeJSON()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>请求结果:</p><ol><li>GET: 客户端每次都会发出网路请求；第一次响应收到 server 返回的 ETag， 之后的请求中会通过 If-None-Match 客户端缓存的标记给到 server 端；若 server 端返回 304，则客户端使用本地的缓存，并且 URLSession 向上返回 200 的状态码。</li><li>POST: 和 GET 表现一致</li></ol></li></ul></li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>URLSession 使用 NSURLRequestUseProtocolCachePolicy 策略的缓存表现可以概括为：</p><ol><li>如果 server 端通过  <code>Cache-Control</code> 告诉客户端资源新鲜度，则客户端在资源未过期之前，不会发出网络请求，直接使用本地缓存，只作用于 GET 请求。</li><li>server 端台利用 <code>Last-Modified</code> 标记资源修改时间或者利用 ETag 标记资源版本，下次客户端重新发出网络请求，携带上  <code>If-Modified-Since</code> / <code>If-None-Match</code> ，server 端会通过 HTTP 状态码 200 / 304 告诉客户端是否可以使用本地的缓存，GET / POST 请求表现一致。</li></ol><p>回到文章开头的问题：（URLSession）非幂等的网络请求是否也支持缓存（如 POST）？</p><p>从上文中简单的测试表现看，结论是不支持的，和 RFC 文档描述存在差异。于是网上搜索相关问题</p><p><a href="https://stackoverflow.com/questions/3874274/how-to-cache-an-http-post-response" target="_blank" rel="noopener">How to cache an HTTP POST response?</a></p><p><a href="https://stackoverflow.com/questions/626057/is-it-possible-to-cache-post-methods-in-http" target="_blank" rel="noopener">Is it possible to cache POST methods in HTTP?</a></p><p>问题底下的回复其中提及到：POST 请求支持缓存，但是客户端如 Firefox 浏览器实现中不支持</p><blockquote><p>Note, however many browsers, including current Firefox 3.0.10, will not cache POST response regardless of the headers. IE behaves more smartly in this respect.</p></blockquote><p>然后再去查阅 mozilla 的相关文档，POST 请求利用 Content-Location 字段也是可以进行资源新鲜度描述并进行缓存，但是一般很少应用支持。<a href="https://developer.mozilla.org/en-US/docs/Glossary/cacheable" target="_blank" rel="noopener">Cacheable</a></p><blockquote><p>The method used in the request is itself <em>cacheable</em>, that is either a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET" target="_blank" rel="noopener"><code>GET</code></a> or a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD" target="_blank" rel="noopener"><code>HEAD</code></a> method. A response to a <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" target="_blank" rel="noopener"><code>POST</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH" target="_blank" rel="noopener"><code>PATCH</code></a> request can also be cached if freshness is indicated and the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Location" target="_blank" rel="noopener"><code>Content-Location</code></a> header is set, but this is rarely implemented. (For example, Firefox does not support it per <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=109553." target="_blank" rel="noopener">https://bugzilla.mozilla.org/show_bug.cgi?id=109553.</a>) Other methods, like <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT" target="_blank" rel="noopener"><code>PUT</code></a> or <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/DELETE" target="_blank" rel="noopener"><code>DELETE</code></a> are not cacheable and their result cannot be cached.</p></blockquote><p>而 <code>Content-Location</code> 定义是：</p><blockquote><p><strong><code>Content-Location</code></strong> 首部指定的是要返回的数据的地址选项。最主要的用途是用来指定要访问的资源经过<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation" target="_blank" rel="noopener">内容协商</a>后的结果的URL。</p></blockquote><p>结合我们的测试表现，只有通过 GET 请求响应包携带的 <code>Cache-Control</code> 才能实现让 URLSession 不发出请求直接使用本地缓存。</p><p>参考文章：</p><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching_FAQ" target="_blank" rel="noopener">HTTP 缓存</a></li><li><a href="https://tech.ebayinc.com/engineering/caching-http-post-requests-and-responses/" target="_blank" rel="noopener">Caching HTTP POST Requests and Responses</a></li><li><a href="https://stackoverflow.com/questions/626057/is-it-possible-to-cache-post-methods-in-http" target="_blank" rel="noopener">Is it possible to cache POST methods in HTTP?</a></li><li><a href="https://www.cnblogs.com/chyingp/p/no-cache-vs-must-revalidate.html" target="_blank" rel="noopener">web性能优化之：no-cache与must-revalidate深入探究</a></li><li><a href="https://juejin.im/post/5d76162bf265da03b120738d" target="_blank" rel="noopener">iOS NSCache &amp; NSURLCache 机制原理探究 (二)</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IGListKit 源码解析</title>
      <link href="/2019/11/05/IGListKit/"/>
      <url>/2019/11/05/IGListKit/</url>
      
        <content type="html"><![CDATA[<p>IGListKit 是 Instagram 维护一个 UI 框架，采用面向协议的思想，基于 UICollectionView 实现，由数据驱动的 UI 列表框架。本文基于 IGListKit 源码对其主要设计思想进行分析。</p><a id="more"></a><p>分析前，我们现看一下 IGListKit 中的数据和 UI 对应关系图</p><p><img src="/2019/11/05/IGListKit/image-20191105193430090.png" alt="image-20191105193430090"></p><p>可以看出 IGListKit 都是基于 IGListAdapter 进行数据传递和 UI 刷新的操作，接下来从 IGListAdapter 入手分析 IGListKit 具体做了哪些工作。</p><h2 id="IGListAdapter"><a href="#IGListAdapter" class="headerlink" title="IGListAdapter"></a>IGListAdapter</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化:"></a>初始化:</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithUpdater:(<span class="keyword">id</span> &lt;IGListUpdatingDelegate&gt;)updater</span><br><span class="line">                 viewController:(<span class="built_in">UIViewController</span> *)viewController</span><br><span class="line">               workingRangeSize:(<span class="built_in">NSInteger</span>)workingRangeSize &#123;</span><br><span class="line">    IGAssertMainThread();</span><br><span class="line">    IGParameterAssert(updater);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">// objectLookupPointerFunctions 返回 hash 表计算 hash 以及比较 value 是否相同的设置</span></span><br><span class="line">        <span class="built_in">NSPointerFunctions</span> *keyFunctions = [updater objectLookupPointerFunctions];</span><br><span class="line">        <span class="built_in">NSPointerFunctions</span> *valueFunctions = [<span class="built_in">NSPointerFunctions</span> pointerFunctionsWithOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span>];</span><br><span class="line">      <span class="comment">// table 是以 object 为 key，sectionController 为 value 的 map</span></span><br><span class="line">        <span class="built_in">NSMapTable</span> *table = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyPointerFunctions:keyFunctions valuePointerFunctions:valueFunctions capacity:<span class="number">0</span>];</span><br><span class="line">        _sectionMap = [[IGListSectionMap alloc] initWithMapTable:table];</span><br><span class="line"></span><br><span class="line">        _displayHandler = [IGListDisplayHandler new];</span><br><span class="line">        _workingRangeHandler = [[IGListWorkingRangeHandler alloc] initWithWorkingRangeSize:workingRangeSize];</span><br><span class="line">        _updateListeners = [<span class="built_in">NSHashTable</span> weakObjectsHashTable];</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将 cell 和 sectionController 映射</span></span><br><span class="line">        _viewSectionControllerMap = [<span class="built_in">NSMapTable</span> mapTableWithKeyOptions:<span class="built_in">NSMapTableObjectPointerPersonality</span> | <span class="built_in">NSMapTableStrongMemory</span></span><br><span class="line">                                                          valueOptions:<span class="built_in">NSMapTableStrongMemory</span>];</span><br><span class="line"></span><br><span class="line">        _updater = updater;</span><br><span class="line">        _viewController = viewController;</span><br><span class="line"></span><br><span class="line">        [IGListDebugger trackAdapter:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>IGListSectionMap</strong>: 作用是映射 sectionController 和 collectionView 的 section 的对应关系，能在 O(1) 的时间复杂度根据 section 获取 sectionController。内部实现结果如下图:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">object -- objectToSectionControllerMap --&gt; IGListSectionController</span><br><span class="line">IGListSectionController -- objectToSectionControllerMap --&gt; object</span><br><span class="line">IGListSectionController -- sectionControllerToSectionMap --&gt; section</span><br><span class="line">section -- sectionControllerToSectionMap --&gt; IGListSectionController</span><br></pre></td></tr></table></figure><p><strong>IGListDisplayHandler</strong>: 作用和对外暴露的 IGListAdapterPerformanceDelegate 类似，主要是对 UICollectionViewCell 生命周日相关对调的处理(cell 显示/消失/分区头部、尾部显示/消失)，内部会把事件传给 IGListSectionController 的 displayDelegate；在 IGListAdapter+UICollectionView.m 文件中进行调用。</p><p><strong>IGListWorkingRangeHandler</strong>: 负责 collectionView 每个 section(sectionController) 的预加载的准备工作。在 IGListAdapter+UICollectionView.m 文件中进行调用，相关数据会保存起来，提供给 IGListAdapter 使用。</p><p><strong>IGListAdapterUpdateListener:</strong> 代理集合，IGListAdapter 更新完数据后对集合的代理进行通知</p><h4 id="数据源"><a href="#数据源" class="headerlink" title="数据源:"></a>数据源:</h4><p>IGListAdapter 会作为 UICollectionView 默认的 dataSource。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCollectionView:(<span class="built_in">UICollectionView</span> *)collectionView &#123;</span><br><span class="line">    <span class="keyword">if</span> (_collectionView != collectionView || _collectionView.dataSource != <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="built_in">NSMapTable</span>&lt;<span class="built_in">UICollectionView</span> *, IGListAdapter *&gt; *globalCollectionViewAdapterMap = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">if</span> (globalCollectionViewAdapterMap == <span class="literal">nil</span>) &#123;</span><br><span class="line">            globalCollectionViewAdapterMap = [<span class="built_in">NSMapTable</span> weakToWeakObjectsMapTable];</span><br><span class="line">        &#125;</span><br><span class="line">        [globalCollectionViewAdapterMap removeObjectForKey:_collectionView];</span><br><span class="line">        [[globalCollectionViewAdapterMap objectForKey:collectionView] setCollectionView:<span class="literal">nil</span>];</span><br><span class="line">        [globalCollectionViewAdapterMap setObject:<span class="keyword">self</span> forKey:collectionView];</span><br><span class="line"></span><br><span class="line">        _registeredCellIdentifiers = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">        _registeredNibNames = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">        _registeredSupplementaryViewIdentifiers = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line">        _registeredSupplementaryViewNibNames = [<span class="built_in">NSMutableSet</span> new];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">BOOL</span> settingFirstCollectionView = _collectionView == <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">        _collectionView = collectionView;</span><br><span class="line">        _collectionView.dataSource = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (@available(iOS <span class="number">10.0</span>, tvOS <span class="number">10</span>, *)) &#123;</span><br><span class="line">            _collectionView.prefetchingEnabled = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [_collectionView.collectionViewLayout ig_hijackLayoutInteractiveReorderingMethodForAdapter:<span class="keyword">self</span>];</span><br><span class="line">      <span class="comment">// 使当前的布局失效，同时触发布局更新</span></span><br><span class="line">        [_collectionView.collectionViewLayout invalidateLayout];</span><br><span class="line"></span><br><span class="line">        [<span class="keyword">self</span> _updateCollectionViewDelegate];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!IGListExperimentEnabled(<span class="keyword">self</span>.experiments, IGListExperimentGetCollectionViewAtUpdate)</span><br><span class="line">            || settingFirstCollectionView) &#123;</span><br><span class="line">            [<span class="keyword">self</span> _updateAfterPublicSettingsChange];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>globalCollectionViewAdapterMap: key 为 collectionView，value 为 IGListAdapter</p><p>通过 <code>- (void)setCollectionView:(UICollectionView *)collectionView</code> 关联 IGListAdapter 和 UICollectionView:</p><pre><code>1. globalCollectionViewAdapterMap 先移除旧的 _collectionView 对应的 IGListAdapter，就是代码中的 self 2. 将新 collectionView 之前绑定的 IGListAdapter 取消对 collectionView 绑定 3. 将新 collectionView 和当前 IGListAdapter 绑定</code></pre><p>dataSource 的方法实现再 IGListAdapter+UICollectionView.m 中，dataSource 的代理方法通过 IGSectionController 返回每个 section 对应的数据</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IGListAdapter+UICollectionView.m</span></span><br><span class="line"><span class="meta">#pragma mark - UICollectionViewDataSource</span></span><br><span class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInCollectionView:(<span class="built_in">UICollectionView</span> *)collectionView &#123;...&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSInteger</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView numberOfItemsInSection:(<span class="built_in">NSInteger</span>)section &#123;...&#125;</span><br><span class="line">  </span><br><span class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;...&#125;</span><br><span class="line">  </span><br><span class="line">- (<span class="built_in">UICollectionReusableView</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView viewForSupplementaryElementOfKind:(<span class="built_in">NSString</span> *)kind atIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;...&#125;</span><br><span class="line">  </span><br><span class="line">- (<span class="built_in">BOOL</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView canMoveItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">NSInteger</span> sectionIndex = indexPath.section;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">NSInteger</span> itemIndex = indexPath.item;</span><br><span class="line"></span><br><span class="line">    IGListSectionController *sectionController = [<span class="keyword">self</span> sectionControllerForSection:sectionIndex];</span><br><span class="line">    <span class="keyword">return</span> [sectionController canMoveItemAtIndex:itemIndex];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView</span><br><span class="line">   moveItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)sourceIndexPath</span><br><span class="line">           toIndexPath:(<span class="built_in">NSIndexPath</span> *)destinationIndexPath &#123;...&#125;</span><br></pre></td></tr></table></figure><h4 id="数据源更新-lt-IGListUpdatingDelegate-gt"><a href="#数据源更新-lt-IGListUpdatingDelegate-gt" class="headerlink" title="数据源更新 &lt;IGListUpdatingDelegate&gt;:"></a>数据源更新 <code>&lt;IGListUpdatingDelegate&gt;</code>:</h4><p>IGListAdapter 提供以下几种方法让外部进行数据更新:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performUpdatesAnimated:(<span class="built_in">BOOL</span>)animated completion:(<span class="keyword">nullable</span> IGListUpdaterCompletion)completion;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)reloadDataWithCompletion:(<span class="keyword">nullable</span> IGListUpdaterCompletion)completion;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)reloadObjects:(<span class="built_in">NSArray</span> *)objects;</span><br></pre></td></tr></table></figure><p>我们先以 <code>-reloadDataWithCompletion:</code> 方法为例子，分析数据更新的过程：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reloadDataWithCompletion:(<span class="keyword">nullable</span> IGListUpdaterCompletion)completion &#123;</span><br><span class="line">    IGAssertMainThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span>&lt;IGListAdapterDataSource&gt; dataSource = <span class="keyword">self</span>.dataSource;</span><br><span class="line">    <span class="built_in">UICollectionView</span> *collectionView = <span class="keyword">self</span>.collectionView;</span><br><span class="line">    <span class="keyword">if</span> (dataSource == <span class="literal">nil</span> || collectionView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        IGLKLog(<span class="string">@"Warning: Your call to %s is ignored as dataSource or collectionView haven't been set."</span>, __PRETTY_FUNCTION__);</span><br><span class="line">        <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">            completion(<span class="literal">NO</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新读取一次数据源代理方法，数据根据diffIdentifier去重</span></span><br><span class="line">    <span class="built_in">NSArray</span> *uniqueObjects = objectsWithDuplicateIdentifiersRemoved([dataSource objectsForListAdapter:<span class="keyword">self</span>]);</span><br><span class="line"></span><br><span class="line">    __<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    [<span class="keyword">self</span>.updater reloadDataWithCollectionViewBlock:[<span class="keyword">self</span> _collectionViewBlock]</span><br><span class="line">                                  reloadUpdateBlock:^&#123;</span><br><span class="line">                                    <span class="comment">// 移除所有 section controllers 以便于重新生成</span></span><br><span class="line">                                      [weakSelf.sectionMap reset];</span><br><span class="line">                                    <span class="comment">// 根据去重后的数据源重新生成 section controller</span></span><br><span class="line">                                      [weakSelf _updateObjects:uniqueObjects dataSource:dataSource];</span><br><span class="line">                                  &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                                      [weakSelf _notifyDidUpdate:IGListAdapterUpdateTypeReloadData animated:<span class="literal">NO</span>];</span><br><span class="line">                                      <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">                                          completion(finished);</span><br><span class="line">                                      &#125;</span><br><span class="line">                                  &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刷新数据之前，会先将数据去重，保证数据对应的 diffIdentifier 是唯一的。然后调用 IGListAdapterUpdater 的方法进行刷新数据</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)reloadDataWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock</span><br><span class="line">                   reloadUpdateBlock:(IGListReloadUpdateBlock)reloadUpdateBlock</span><br><span class="line">                          completion:(<span class="keyword">nullable</span> IGListUpdatingCompletion)completion &#123;</span><br><span class="line">    IGAssertMainThread();</span><br><span class="line">    IGParameterAssert(collectionViewBlock != <span class="literal">nil</span>);</span><br><span class="line">    IGParameterAssert(reloadUpdateBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    IGListUpdatingCompletion localCompletion = completion;</span><br><span class="line">    <span class="keyword">if</span> (localCompletion) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.completionBlocks addObject:localCompletion];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.reloadUpdates = reloadUpdateBlock;</span><br><span class="line">    <span class="keyword">self</span>.queuedReloadData = <span class="literal">YES</span>;</span><br><span class="line">    [<span class="keyword">self</span> _queueUpdateWithCollectionViewBlock:collectionViewBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_queueUpdateWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock &#123;</span><br><span class="line">    IGAssertMainThread();</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// dispatch_async 是为了执行 -performBatchUpdatesWithCollectionViewBlock: 前提供更多时间来完成数据更新处理，减少在主线程上进行差异化的操作</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (weakSelf.state != IGListBatchUpdateStateIdle</span><br><span class="line">            || ![weakSelf hasChanges]) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (weakSelf.hasQueuedReloadData) &#123;</span><br><span class="line">            [weakSelf performReloadDataWithCollectionViewBlock:collectionViewBlock];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [weakSelf performBatchUpdatesWithCollectionViewBlock:collectionViewBlock];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后进入条件判断执行 <code>-performReloadDataWithCollectionViewBlock:</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (void)performReloadDataWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock &#123;</span><br><span class="line">    IGAssertMainThread();</span><br><span class="line">    </span><br><span class="line">    id&lt;IGListAdapterUpdaterDelegate&gt; delegate = self.delegate;</span><br><span class="line">    void (^reloadUpdates)(void) = self.reloadUpdates;</span><br><span class="line">    IGListBatchUpdates *batchUpdates = self.batchUpdates;</span><br><span class="line">    NSMutableArray *completionBlocks = [self.completionBlocks mutableCopy];</span><br><span class="line"></span><br><span class="line">  // 清空相关状态</span><br><span class="line">    [self cleanStateBeforeUpdates];</span><br><span class="line"></span><br><span class="line">    void (^executeCompletionBlocks)(BOOL) = ^(BOOL finished) &#123;</span><br><span class="line">        for (IGListUpdatingCompletion block in completionBlocks) &#123;</span><br><span class="line">            block(finished);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        self.state = IGListBatchUpdateStateIdle;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 防止 collectionView 被释放导致崩溃</span><br><span class="line">    UICollectionView *collectionView = collectionViewBlock();</span><br><span class="line">    if (collectionView == nil) &#123;</span><br><span class="line">        [self _cleanStateAfterUpdates];</span><br><span class="line">        executeCompletionBlocks(NO);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 更新状态，避免更新数据的过程中去通知视图更新</span><br><span class="line">    self.state = IGListBatchUpdateStateExecutingBatchUpdateBlock;</span><br><span class="line"></span><br><span class="line">  // 通知外部移除所有 section controllers，然后重新生成</span><br><span class="line">    if (reloadUpdates) &#123;</span><br><span class="line">        reloadUpdates();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  // 即使我们只是调用reloadData，也要执行所有存储的 batchUpdates 任务</span><br><span class="line">  // 实际效果所有 section 视图的突变将被丢弃，建议使用者也将其实际的数据更新也放入 batchUpdates 任务集合中，因此，如果我们不执行该块，则 batchUpdates 是不会被触发</span><br><span class="line">    for (IGListItemUpdateBlock itemUpdateBlock in batchUpdates.itemUpdateBlocks) &#123;</span><br><span class="line">        itemUpdateBlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // add any completion blocks from item updates. added after item blocks are executed in order to capture any</span><br><span class="line">    // re-entrant updates</span><br><span class="line">    [completionBlocks addObjectsFromArray:batchUpdates.itemCompletionBlocks];</span><br><span class="line"></span><br><span class="line">    self.state = IGListBatchUpdateStateExecutedBatchUpdateBlock;</span><br><span class="line"></span><br><span class="line">    [self _cleanStateAfterUpdates];</span><br><span class="line"></span><br><span class="line">    [delegate listAdapterUpdater:self willReloadDataWithCollectionView:collectionView];</span><br><span class="line">    [collectionView reloadData];</span><br><span class="line">    [collectionView.collectionViewLayout invalidateLayout];</span><br><span class="line">    [collectionView layoutIfNeeded];</span><br><span class="line">    [delegate listAdapterUpdater:self didReloadDataWithCollectionView:collectionView];</span><br><span class="line"></span><br><span class="line">    executeCompletionBlocks(YES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-performReloadDataWithCollectionViewBlock:</code> 中也会触发保存在 batchUpdates 中的更新任务，以便及时刷新数据/界面，然后通过代理通知外部 UICollectionView 刷新的前后事件。</p><p>可以看出 <code>-reloadDataWithCompletion:</code> 基本等同于强制刷新，会把所有刷新任务全部执行完之后，通知 UICollectionView 刷新界面。</p><p>与 <code>-reloadDataWithCompletion:</code> 不同的是，IGListAdapter 还有提供另外一个方法进行数据刷新 <code>- (void)performUpdatesAnimated:completion:</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performUpdatesAnimated:(<span class="built_in">BOOL</span>)animated completion:(IGListUpdaterCompletion)completion &#123;</span><br><span class="line">    <span class="comment">// 略...</span></span><br><span class="line">    [<span class="keyword">self</span> _enterBatchUpdates];</span><br><span class="line">    [<span class="keyword">self</span>.updater performUpdateWithCollectionViewBlock:[<span class="keyword">self</span> _collectionViewBlock]</span><br><span class="line">                                           fromObjects:fromObjects</span><br><span class="line">                                        toObjectsBlock:toObjectsBlock</span><br><span class="line">                                              animated:animated</span><br><span class="line">                                 objectTransitionBlock:^(<span class="built_in">NSArray</span> *toObjects) &#123;</span><br><span class="line">                                     <span class="comment">// 重新捕获一次 sectionMap，防止同时间有数据被删除</span></span><br><span class="line">                                     weakSelf.previousSectionMap = [weakSelf.sectionMap <span class="keyword">copy</span>   </span><br><span class="line">                                     <span class="comment">// 更新 sectionMap 数据，刷新 collectiView 背景图</span></span><br><span class="line">                                     [weakSelf _updateObjects:toObjects dataSource:dataSource];</span><br><span class="line">                                 &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                                     <span class="comment">// release the previous items</span></span><br><span class="line">                                     weakSelf.previousSectionMap = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">                                     [weakSelf _notifyDidUpdate:IGListAdapterUpdateTypePerformUpdates animated:animated];</span><br><span class="line">                                     <span class="keyword">if</span> (completion) &#123;</span><br><span class="line">                                         completion(finished);</span><br><span class="line">                                     &#125;</span><br><span class="line">                                     [weakSelf _exitBatchUpdates];</span><br><span class="line">                                 &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>updater 会将更新数据 sectionMap 的操作保存到 objectTransitionBlock 中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performUpdateWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock</span><br><span class="line">                            fromObjects:(<span class="built_in">NSArray</span> *)fromObjects</span><br><span class="line">                         toObjectsBlock:(IGListToObjectBlock)toObjectsBlock</span><br><span class="line">                               animated:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">                  objectTransitionBlock:(IGListObjectTransitionBlock)objectTransitionBlock</span><br><span class="line">                             completion:(IGListUpdatingCompletion)completion &#123;</span><br><span class="line">    IGAssertMainThread();</span><br><span class="line">    IGParameterAssert(collectionViewBlock != <span class="literal">nil</span>);</span><br><span class="line">    IGParameterAssert(objectTransitionBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正在执行更新的过程中，同一时间内可能会有多个其他更新任务加入，</span></span><br><span class="line">    <span class="comment">// 执行更新动作的时候，是第一次加入的 fromObject 和 最后加入的 toObjects</span></span><br><span class="line">    <span class="comment">// 如果 self.fromObject == nil, 应该有先使用之前加入并且还没有执行的 batch update 任务的终点数据源(toObjects)</span></span><br><span class="line">    <span class="comment">// 这样做的目的是使整个数据变化可以串联起来</span></span><br><span class="line">    <span class="keyword">self</span>.fromObjects = <span class="keyword">self</span>.fromObjects ?: <span class="keyword">self</span>.pendingTransitionToObjects ?: fromObjects;</span><br><span class="line">    <span class="keyword">self</span>.toObjectsBlock = toObjectsBlock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// disabled animations will always take priority</span></span><br><span class="line">    <span class="comment">// reset to YES in -cleanupState</span></span><br><span class="line">    <span class="keyword">self</span>.queuedUpdateIsAnimated = <span class="keyword">self</span>.queuedUpdateIsAnimated &amp;&amp; animated;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证每次刷新使用最新的 objectTransitionBlock</span></span><br><span class="line">    <span class="keyword">self</span>.objectTransitionBlock = objectTransitionBlock;</span><br><span class="line"></span><br><span class="line">    IGListUpdatingCompletion localCompletion = completion;</span><br><span class="line">    <span class="keyword">if</span> (localCompletion) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.completionBlocks addObject:localCompletion];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> _queueUpdateWithCollectionViewBlock:collectionViewBlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> IGListUpdater 处理完传入的 fromObjects 和 toObjects，并保存数据转化的闭包 objectTransitionBlock，会调用 <code>-_queueUpdateWithCollectionViewBlock:</code> 方法，利用 dispatch_async 异步调用 <code>-performBatchUpdatesWithCollectionViewBlock:</code></p> <figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)performBatchUpdatesWithCollectionViewBlock:(IGListCollectionViewBlock)collectionViewBlock &#123;</span><br><span class="line">    IGAssertMainThread();</span><br><span class="line">    IGAssert(<span class="keyword">self</span>.state == IGListBatchUpdateStateIdle, <span class="string">@"Should not call batch updates when state isn't idle"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建局部变量，以便我们可以立即清除状态，但将这些数据传递到批处理更新任务中</span></span><br><span class="line">    <span class="keyword">id</span>&lt;IGListAdapterUpdaterDelegate&gt; delegate = <span class="keyword">self</span>.delegate;</span><br><span class="line">    <span class="built_in">NSArray</span> *fromObjects = [<span class="keyword">self</span>.fromObjects <span class="keyword">copy</span>];</span><br><span class="line">    IGListToObjectBlock toObjectsBlock = [<span class="keyword">self</span>.toObjectsBlock <span class="keyword">copy</span>];</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *completionBlocks = [<span class="keyword">self</span>.completionBlocks mutableCopy];</span><br><span class="line">    <span class="keyword">void</span> (^objectTransitionBlock)(<span class="built_in">NSArray</span> *) = [<span class="keyword">self</span>.objectTransitionBlock <span class="keyword">copy</span>];</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">BOOL</span> animated = <span class="keyword">self</span>.queuedUpdateIsAnimated;</span><br><span class="line">    IGListBatchUpdates *batchUpdates = <span class="keyword">self</span>.batchUpdates;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理所有状态，以便在当前更新进行时可以合并新的更新</span></span><br><span class="line">    [<span class="keyword">self</span> cleanStateBeforeUpdates];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化更新完成之后的回调</span></span><br><span class="line">    <span class="keyword">void</span> (^executeCompletionBlocks)(<span class="built_in">BOOL</span>) = ^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">        <span class="keyword">self</span>.applyingUpdateData = <span class="literal">nil</span>;</span><br><span class="line">        <span class="keyword">self</span>.state = IGListBatchUpdateStateIdle;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (IGListUpdatingCompletion block <span class="keyword">in</span> completionBlocks) &#123;</span><br><span class="line">            block(finished);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// collectionView 如果被销毁，则结束更新恢复相关状态</span></span><br><span class="line">    <span class="built_in">UICollectionView</span> *collectionView = collectionViewBlock();</span><br><span class="line">    <span class="keyword">if</span> (collectionView == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _cleanStateAfterUpdates];</span><br><span class="line">        executeCompletionBlocks(<span class="literal">NO</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSArray</span> *toObjects = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (toObjectsBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">        toObjects = objectsWithDuplicateIdentifiersRemoved(toObjectsBlock());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化数据刷新的闭包</span></span><br><span class="line">    <span class="keyword">void</span> (^executeUpdateBlocks)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.state = IGListBatchUpdateStateExecutingBatchUpdateBlock;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新包括 IGListAdapter 的 sectionController 和 objects 的映射关系等数据</span></span><br><span class="line">        <span class="comment">// 保证执行刷新前，数据已经是最新的</span></span><br><span class="line">        <span class="keyword">if</span> (objectTransitionBlock != <span class="literal">nil</span>) &#123;</span><br><span class="line">            objectTransitionBlock(toObjects);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 触发批量刷新任务的数据更新闭包（包括插入、删除、刷新单个 section 的数据）</span></span><br><span class="line">        <span class="comment">// objectTransitionBlock 之后执行是为了保证 section 级别的刷新在 item 级别刷新之前进行</span></span><br><span class="line">        <span class="keyword">for</span> (IGListItemUpdateBlock itemUpdateBlock <span class="keyword">in</span> batchUpdates.itemUpdateBlocks) &#123;</span><br><span class="line">            itemUpdateBlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集批量刷新完成的回调，后续所有操作完了之后一并处理</span></span><br><span class="line">        [completionBlocks addObjectsFromArray:batchUpdates.itemCompletionBlocks];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">self</span>.state = IGListBatchUpdateStateExecutedBatchUpdateBlock;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行全量的数据更新并刷新 UI</span></span><br><span class="line">    <span class="keyword">void</span> (^reloadDataFallback)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        executeUpdateBlocks();</span><br><span class="line">        [<span class="keyword">self</span> _cleanStateAfterUpdates];</span><br><span class="line">        [<span class="keyword">self</span> _performBatchUpdatesItemBlockApplied];</span><br><span class="line">        [collectionView reloadData];</span><br><span class="line">        [collectionView layoutIfNeeded];</span><br><span class="line"></span><br><span class="line">        executeCompletionBlocks(<span class="literal">YES</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前 collection 没有显示，跳过差分/分批刷新</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">BOOL</span> iOS83OrLater = (<span class="built_in">NSFoundationVersionNumber</span> &gt;= <span class="built_in">NSFoundationVersionNumber_iOS_8_3</span>);</span><br><span class="line">    <span class="keyword">if</span> (iOS83OrLater &amp;&amp; <span class="keyword">self</span>.allowsBackgroundReloading &amp;&amp; collectionView.window == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [<span class="keyword">self</span> _beginPerformBatchUpdatesToObjects:toObjects];</span><br><span class="line">        reloadDataFallback();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 禁止同时执行多个 -performBatchUpdates：</span></span><br><span class="line">    [<span class="keyword">self</span> _beginPerformBatchUpdatesToObjects:toObjects];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> IGListExperiment experiments = <span class="keyword">self</span>.experiments;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新旧数据源差分部分，算法参考: https://dl.acm.org/citation.cfm?id=359467&amp;dl=ACM&amp;coll=DL</span></span><br><span class="line">    IGListIndexSetResult *(^performDiff)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">        <span class="keyword">return</span> IGListDiffExperiment(fromObjects, toObjects, IGListDiffEquality, experiments);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block executed in the first param block of -[UICollectionView performBatchUpdates:completion:]</span></span><br><span class="line">    <span class="keyword">void</span> (^batchUpdatesBlock)(IGListIndexSetResult *result) = ^(IGListIndexSetResult *result)&#123;</span><br><span class="line">        <span class="comment">// 更新数据</span></span><br><span class="line">        executeUpdateBlocks();</span><br><span class="line">        <span class="comment">// 根据整理差分算法结果，过滤相关 section/item 数据，把 item 级别的刷新转换成 section 级别来规避 UICollectionView 的 bug，并调用 collectionView reload/insert/delete/move 操作</span></span><br><span class="line">        <span class="keyword">self</span>.applyingUpdateData = [<span class="keyword">self</span> _flushCollectionView:collectionView</span><br><span class="line">                                              withDiffResult:result</span><br><span class="line">                                                batchUpdates:<span class="keyword">self</span>.batchUpdates</span><br><span class="line">                                                 fromObjects:fromObjects];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新相关数据状态, 清空批量更新任务和等待更新的数据</span></span><br><span class="line">        [<span class="keyword">self</span> _cleanStateAfterUpdates];</span><br><span class="line">        [<span class="keyword">self</span> _performBatchUpdatesItemBlockApplied];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block used as the second param of -[UICollectionView performBatchUpdates:completion:]</span></span><br><span class="line">    <span class="keyword">void</span> (^batchUpdatesCompletionBlock)(<span class="built_in">BOOL</span>) = ^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">        IGListBatchUpdateData *oldApplyingUpdateData = <span class="keyword">self</span>.applyingUpdateData;</span><br><span class="line">        executeCompletionBlocks(finished);</span><br><span class="line"></span><br><span class="line">        [delegate listAdapterUpdater:<span class="keyword">self</span> didPerformBatchUpdates:oldApplyingUpdateData collectionView:collectionView];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// queue another update in case something changed during batch updates. this method will bail next runloop if</span></span><br><span class="line">        <span class="comment">// there are no changes</span></span><br><span class="line">        <span class="comment">// 如果 batch update 任务执行的过程中尤其比那话，则异步在下一个 runloop 周期执行相关更新动作</span></span><br><span class="line">        [<span class="keyword">self</span> _queueUpdateWithCollectionViewBlock:collectionViewBlock];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// block that executes the batch update and exception handling</span></span><br><span class="line">    <span class="keyword">void</span> (^performUpdate)(IGListIndexSetResult *) = ^(IGListIndexSetResult *result)&#123;</span><br><span class="line">        [collectionView layoutIfNeeded];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">@try</span> &#123;</span><br><span class="line">            <span class="comment">// 对外通知即将进行 batch update</span></span><br><span class="line">            [delegate  listAdapterUpdater:<span class="keyword">self</span></span><br><span class="line">willPerformBatchUpdatesWithCollectionView:collectionView</span><br><span class="line">                              fromObjects:fromObjects</span><br><span class="line">                                toObjects:toObjects</span><br><span class="line">                       listIndexSetResult:result];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (collectionView.dataSource == <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果数据源为空则不再刷新的 UICollectionview</span></span><br><span class="line">                batchUpdatesCompletionBlock(<span class="literal">NO</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result.changeCount &gt; <span class="number">100</span> &amp;&amp; IGListExperimentEnabled(experiments, IGListExperimentReloadDataFallback)) &#123;</span><br><span class="line">                <span class="comment">// 差分变化数量超过100，进行全量刷新</span></span><br><span class="line">                reloadDataFallback();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (animated) &#123;</span><br><span class="line">                <span class="comment">// 执行差分更新的批量动画</span></span><br><span class="line">                [collectionView performBatchUpdates:^&#123;</span><br><span class="line">                    batchUpdatesBlock(result);</span><br><span class="line">                &#125; completion:batchUpdatesCompletionBlock];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">                [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line">                [collectionView performBatchUpdates:^&#123;</span><br><span class="line">                    batchUpdatesBlock(result);</span><br><span class="line">                &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">                    [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">                    batchUpdatesCompletionBlock(finished);</span><br><span class="line">                &#125;];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">@catch</span> (<span class="built_in">NSException</span> *exception) &#123;</span><br><span class="line">            <span class="comment">// 异常对外通知</span></span><br><span class="line">            [delegate listAdapterUpdater:<span class="keyword">self</span></span><br><span class="line">                          collectionView:collectionView</span><br><span class="line">                  willCrashWithException:exception</span><br><span class="line">                             fromObjects:fromObjects</span><br><span class="line">                               toObjects:toObjects</span><br><span class="line">                              diffResult:result</span><br><span class="line">                                 updates:(<span class="keyword">id</span>)<span class="keyword">self</span>.applyingUpdateData];</span><br><span class="line">            <span class="keyword">@throw</span> exception;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IGListExperimentEnabled(experiments, IGListExperimentBackgroundDiffing)) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(QOS_CLASS_USER_INITIATED, <span class="number">0</span>), ^&#123;</span><br><span class="line">            <span class="comment">// 计算完差分部分</span></span><br><span class="line">            IGListIndexSetResult *result = performDiff();</span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="comment">//根据差分结果刷新 UICollectionView</span></span><br><span class="line">                performUpdate(result);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        IGListIndexSetResult *result = performDiff();</span><br><span class="line">        performUpdate(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该数据更新过程调用链大概是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|---performUpdatesAnimated:completion:</span><br><span class="line">    |---performUpdateWithCollectionViewBlock:fromObjects:toObjectsBlock:animated:objectTransitionBlock:completion:</span><br><span class="line">    |---_queueUpdateWithCollectionViewBlock:</span><br><span class="line">            |---performBatchUpdatesWithCollectionViewBlock:</span><br></pre></td></tr></table></figure><p>整个 performUpdates 的大部分逻辑都是由 <strong>IGListUpdater</strong> 完成，重中之重都几种放 <code>-performBatchUpdatesWithCollectionViewBlock:</code>方法：</p><pre><code>1. 判断 collectionView 是否在显示，若不在屏幕窗口上显示，直接全量刷新数据和视图；反之继续步骤2 2. 子线程调用 IGListDiffExperiment，计算数据的差分变化，计算完毕之后在主线程触发界面刷新逻辑 3. 通过代理对外通知即将进行 batch update 批量更新 4. 如果 collectionView 的 dataSource 为 nil，结束更新过程；反之继续 5. 差分变化的数据个数超过100，直接调用 reloadData 全量刷新数据/视图；若变化数据小于100，则调用 `-[UICollectionView performBatchUpdates:completion:]` 批量刷新数据/视图，刷新过程中会调用 `-_flushCollectionView:withDiffResult:batchUpdates:fromObjects:` 将数据源提供的数据和 diff 结果包装成批量更新的数据类型 IGListBatchUpdateData 以便 UICollectionView 进行读取</code></pre><h4 id="视图管理-lt-IGListAdapterPerformanceDelegate-gt"><a href="#视图管理-lt-IGListAdapterPerformanceDelegate-gt" class="headerlink" title="视图管理 &lt;IGListAdapterPerformanceDelegate&gt;:"></a>视图管理 <code>&lt;IGListAdapterPerformanceDelegate&gt;</code>:</h4><p>IGListAdapter 会作为 collectionView 属性的默认代理</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">IGListCollectionViewDelegateLayout</span> &lt;<span class="title">UICollectionViewDelegateFlowLayout</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IGListAdapter</span> (<span class="title">UICollectionView</span>)</span></span><br><span class="line">&lt;</span><br><span class="line"><span class="built_in">UICollectionViewDataSource</span>,</span><br><span class="line">IGListCollectionViewDelegateLayout</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>IGListAdapter 会实现相关代理方法，进行对 cell 级别的视图管理，包含视图 UICollectionView 滚动，cell 大小、cell 显示等事件，并通过 IGListAdapterPerformanceDelegate 对外通知</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGSize</span>)sizeForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">  <span class="comment">//...略</span></span><br><span class="line">  [performanceDelegate listAdapter:<span class="keyword">self</span> didCallSizeOnSectionController:sectionController atIndex:indexPath.item];</span><br><span class="line">  <span class="comment">//...略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView &#123;</span><br><span class="line">    <span class="keyword">id</span>&lt;IGListAdapterPerformanceDelegate&gt; performanceDelegate = <span class="keyword">self</span>.performanceDelegate;</span><br><span class="line">    [performanceDelegate listAdapterWillCallScroll:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...略</span></span><br><span class="line"></span><br><span class="line">    [performanceDelegate listAdapter:<span class="keyword">self</span> didCallScroll:scrollView];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">  <span class="keyword">id</span>&lt;IGListAdapterPerformanceDelegate&gt; performanceDelegate = <span class="keyword">self</span>.performanceDelegate;</span><br><span class="line">  [performanceDelegate listAdapterWillCallDequeueCell:<span class="keyword">self</span>];</span><br><span class="line">  <span class="comment">//...略</span></span><br><span class="line">  [performanceDelegate listAdapter:<span class="keyword">self</span> didCallDequeueCell:cell onSectionController:sectionController atIndex:indexPath.item];</span><br><span class="line">  <span class="comment">//...略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView willDisplayCell:(<span class="built_in">UICollectionViewCell</span> *)cell forItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">id</span>&lt;IGListAdapterPerformanceDelegate&gt; performanceDelegate = <span class="keyword">self</span>.performanceDelegate;</span><br><span class="line">    [performanceDelegate listAdapterWillCallDisplayCell:<span class="keyword">self</span>];</span><br><span class="line">    <span class="comment">// ...略</span></span><br><span class="line">    [performanceDelegate listAdapter:<span class="keyword">self</span> didCallDisplayCell:cell onSectionController:sectionController atIndex:indexPath.item];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView didEndDisplayingCell:(<span class="built_in">UICollectionViewCell</span> *)cell forItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    <span class="keyword">id</span>&lt;IGListAdapterPerformanceDelegate&gt; performanceDelegate = <span class="keyword">self</span>.performanceDelegate;</span><br><span class="line">    [performanceDelegate listAdapterWillCallEndDisplayCell:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...略</span></span><br><span class="line"></span><br><span class="line">    [performanceDelegate listAdapter:<span class="keyword">self</span> didCallEndDisplayCell:cell onSectionController:sectionController atIndex:indexPath.item];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="视图交互"><a href="#视图交互" class="headerlink" title="视图交互:"></a>视图交互:</h4><p>cell 的拖动会首先触发 UICollectionView 的代理方法 <code>-collectionView:moveItemAtIndexPath:toIndexPath</code> 。在这个方法中会判断拖动开始/结束位置，根据不同的情况进行数据刷新</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView</span><br><span class="line">   moveItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)sourceIndexPath</span><br><span class="line">           toIndexPath:(<span class="built_in">NSIndexPath</span> *)destinationIndexPath &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (@available(iOS <span class="number">9.0</span>, *)) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> sourceSectionIndex = sourceIndexPath.section;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> destinationSectionIndex = destinationIndexPath.section;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> sourceItemIndex = sourceIndexPath.item;</span><br><span class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> destinationItemIndex = destinationIndexPath.item;</span><br><span class="line"></span><br><span class="line">        IGListSectionController *sourceSectionController = [<span class="keyword">self</span> sectionControllerForSection:sourceSectionIndex];</span><br><span class="line">        IGListSectionController *destinationSectionController = [<span class="keyword">self</span> sectionControllerForSection:destinationSectionIndex];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sourceSectionController == destinationSectionController) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ([sourceSectionController canMoveItemAtIndex:sourceItemIndex toIndex:destinationItemIndex]) &#123;</span><br><span class="line">                <span class="comment">// 同一个 section 内的挪动</span></span><br><span class="line">                [<span class="keyword">self</span> moveInSectionControllerInteractive:sourceSectionController</span><br><span class="line">                                               fromIndex:sourceItemIndex</span><br><span class="line">                                                 toIndex:destinationItemIndex];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 撤销修改</span></span><br><span class="line">                [<span class="keyword">self</span> revertInvalidInteractiveMoveFromIndexPath:sourceIndexPath toIndexPath:destinationIndexPath];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨 section 移动， 如果 section 的 item 数目为1</span></span><br><span class="line">        <span class="keyword">if</span> ([sourceSectionController numberOfItems] == <span class="number">1</span> &amp;&amp; [destinationSectionController numberOfItems] == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            [<span class="keyword">self</span> moveSectionControllerInteractive:sourceSectionController</span><br><span class="line">                                         fromIndex:sourceSectionIndex</span><br><span class="line">                                           toIndex:destinationSectionIndex];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 撤销修改</span></span><br><span class="line">        [<span class="keyword">self</span> revertInvalidInteractiveMoveFromIndexPath:sourceIndexPath toIndexPath:destinationIndexPath];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成功拖动之后会触发 IGListUpdater 的 <code>-moveInSectionControllerInteractive</code> 或者  <code>-moveSectionControllerInteractive:fromIndex:toIndex</code>，在同一个 UICollectionView section 中拖动则触发前者，跨 section 之间则后者</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)moveInSectionControllerInteractive:(IGListSectionController *)sectionController</span><br><span class="line">                                 fromIndex:(<span class="built_in">NSInteger</span>)fromIndex</span><br><span class="line">                                   toIndex:(<span class="built_in">NSInteger</span>)toIndex <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0) &#123;</span><br><span class="line">  <span class="comment">//... 略</span></span><br><span class="line">    [sectionController moveObjectFromIndex:fromIndex toIndex:toIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在同一个 section 中拖动 UICollectionViewCell 比较简单，实现中回去调用对应 sectionController 的 <code>-moveObjectFromIndex:toIndex:</code>，使用者在自定义的 sectionController 中实现该代理方法，进行对应的数据刷新更新即可</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)moveSectionControllerInteractive:(IGListSectionController *)sectionController</span><br><span class="line">                               fromIndex:(<span class="built_in">NSInteger</span>)fromIndex</span><br><span class="line">                                 toIndex:(<span class="built_in">NSInteger</span>)toIndex <span class="built_in">NS_AVAILABLE_IOS</span>(<span class="number">9</span>_0) &#123;</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="keyword">if</span> (fromIndex != toIndex) &#123;</span><br><span class="line">        <span class="keyword">id</span>&lt;IGListAdapterDataSource&gt; dataSource = <span class="keyword">self</span>.dataSource;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSArray</span> *previousObjects = [<span class="keyword">self</span>.sectionMap objects];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isLastInteractiveMoveToLastSectionIndex) &#123;</span><br><span class="line">            <span class="comment">// 如果 item 是被移动到 UICollectionView 最底部</span></span><br><span class="line">            <span class="keyword">self</span>.isLastInteractiveMoveToLastSectionIndex = <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fromIndex &lt; toIndex) &#123;</span><br><span class="line">            toIndex -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *mutObjects = [previousObjects mutableCopy];</span><br><span class="line">        <span class="keyword">id</span> object = [previousObjects objectAtIndex:fromIndex];</span><br><span class="line">        [mutObjects removeObjectAtIndex:fromIndex];</span><br><span class="line">        [mutObjects insertObject:object atIndex:toIndex];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSArray</span> *objects = [mutObjects <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// inform the data source to update its model</span></span><br><span class="line">        [<span class="keyword">self</span>.moveDelegate listAdapter:<span class="keyword">self</span> moveObject:object from:previousObjects to:objects];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// update our model based on that provided by the data source</span></span><br><span class="line">        <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span>&lt;IGListDiffable&gt;&gt; *updatedObjects = [dataSource objectsForListAdapter:<span class="keyword">self</span>];</span><br><span class="line">        [<span class="keyword">self</span> _updateObjects:updatedObjects dataSource:dataSource];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 刷新 UI</span></span><br><span class="line">    <span class="comment">// 这里 from index 和 to index 可能是相同的, 但是实际上可能是以 section 的方式向上/下移动了一个 section</span></span><br><span class="line">    [<span class="keyword">self</span>.updater moveSectionInCollectionView:collectionView fromIndex:fromIndex toIndex:toIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跨 UICollectionView section 间拖动 UICollectionViewCell 需要对原始/目标 section 的位置/ item 数目进行相关判断，最后执行 IGListUpdater 的 <code>-moveSectionInCollectionView:fromIndex:toIndex:</code> 方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)moveSectionInCollectionView:(<span class="built_in">UICollectionView</span> *)collectionView</span><br><span class="line">                          fromIndex:(<span class="built_in">NSInteger</span>)fromIndex</span><br><span class="line">                            toIndex:(<span class="built_in">NSInteger</span>)toIndex &#123;</span><br><span class="line">    <span class="comment">// iOS 移动是以 item 为移动单位的拖动</span></span><br><span class="line">    <span class="comment">// 如果 originating section 中的 item 数量是1，将这个 item 拖动到 item 数目同样为1的 target section</span></span><br><span class="line">    <span class="comment">// 拖动之后 target section 的 item 数目为2， originating section 的数目为 0</span></span><br><span class="line">    <span class="comment">// 基于这种情况必须使用 reloadData</span></span><br><span class="line">    [collectionView reloadData];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 似乎在 UICollectionVie 的 -moveItemAtIndexPath 代理方法调用期间调用的 -reloadData 不会按预期重新加载所有单元格，</span></span><br><span class="line">    <span class="comment">// 因此，这里进一步重新加载了所有可见部分，以确保没有任何 item 上的数据与 dataSource 不同步。</span></span><br><span class="line">    <span class="keyword">id</span>&lt;IGListAdapterUpdaterDelegate&gt; delegate = <span class="keyword">self</span>.delegate;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSMutableIndexSet</span> *visibleSections = [<span class="built_in">NSMutableIndexSet</span> new];</span><br><span class="line">    <span class="built_in">NSArray</span> *visibleIndexPaths = [collectionView indexPathsForVisibleItems];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSIndexPath</span> *visibleIndexPath <span class="keyword">in</span> visibleIndexPaths) &#123;</span><br><span class="line">        [visibleSections addIndex:visibleIndexPath.section];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [delegate listAdapterUpdater:<span class="keyword">self</span> willReloadSections:visibleSections collectionView:collectionView];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// prevent double-animation from reloadData + reloadSections</span></span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">CATransaction</span> begin];</span><br><span class="line">    [<span class="built_in">CATransaction</span> setDisableActions:<span class="literal">YES</span>];</span><br><span class="line">    [collectionView performBatchUpdates:^&#123;</span><br><span class="line">        [collectionView reloadSections:visibleSections];</span><br><span class="line">    &#125; completion:^(<span class="built_in">BOOL</span> finished) &#123;</span><br><span class="line">        [<span class="built_in">CATransaction</span> commit];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>-moveSectionInCollectionView:fromIndex:toIndex:</code> 方法会现调用 <code>-[UICollectionView reloadDate]</code> 来规避 origin section item 数目为0的情况，之后还会对应当前屏幕显示区域进行 batch update 来规避 UICollectionView 不能及时刷新的 bug。</p><p>整个 UICollectionViewCell 拖动的调用栈大概为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|---collectionView:moveItemAtIndexPath:toIndexPath:</span><br><span class="line">|---moveInSectionControllerInteractive:fromIndex:toIndex: # section 内拖动</span><br><span class="line">|---moveObjectFromIndex:toIndex:</span><br><span class="line">|---moveSectionControllerInteractive:fromIndex:toIndex: # section 间拖动</span><br><span class="line">|---_updateObjects:dataSource</span><br><span class="line">|---moveSectionInCollectionView:fromIndex:toIndex # updater</span><br><span class="line">|---performBatchUpdates:completion: # UICollectionView</span><br></pre></td></tr></table></figure><p>总结来说，整个 IGListKit 结构可以用下图来概括:</p><p><img src="/2019/11/05/IGListKit/image-20191105162410295.png" alt="image-20191105170804580"></p><p>可以看出来，IGListAdapter 负责不同功能的属性都是通过面向协议来进行开发，不同的功能模块粒度都比较小，避免模块之间的循环依赖，实现数据跟视图的有效解耦。</p><p>不仅如此，IGListKit 通过 IGListDiffable 协议加上 diff 算法，对外隐藏数据更新的细节，用户只需关注业务数据，减轻了数据更新的操作。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>IGListKit 中还用到一些平时没有注意到的特性</p><p><strong>NSCountedSet</strong></p><p>插入 NSCountedSet 对象的每个不同的对象都有一个与之相关的计数器，同一个对象每加入一次 NSCountedSet 集合中，对应的 count 就会加1</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)_willDisplayReusableView:(<span class="built_in">UICollectionReusableView</span> *)view</span><br><span class="line">                 forListAdapter:(IGListAdapter *)listAdapter</span><br><span class="line">              sectionController:(IGListSectionController *)sectionController</span><br><span class="line">                         object:(<span class="keyword">id</span>)object</span><br><span class="line">                      indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</span><br><span class="line">    IGParameterAssert(view != <span class="literal">nil</span>);</span><br><span class="line">    IGParameterAssert(listAdapter != <span class="literal">nil</span>);</span><br><span class="line">    IGParameterAssert(object != <span class="literal">nil</span>);</span><br><span class="line">    IGParameterAssert(indexPath != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.visibleViewObjectMap setObject:object forKey:view];</span><br><span class="line">    <span class="built_in">NSCountedSet</span> *visibleListSections = <span class="keyword">self</span>.visibleListSections;</span><br><span class="line">    <span class="keyword">if</span> ([visibleListSections countForObject:sectionController] == <span class="number">0</span>) &#123;</span><br><span class="line">        [sectionController.displayDelegate listAdapter:listAdapter willDisplaySectionController:sectionController];</span><br><span class="line">        [listAdapter.delegate listAdapter:listAdapter willDisplayObject:object atIndex:indexPath.section];</span><br><span class="line">    &#125;</span><br><span class="line">    [visibleListSections addObject:sectionController];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IGListKit 中的 IGListDisplayHandler 利用 NSCountedSet 记录 UICollectionView section 的显示状态，旨在通知外部每个 section 的显示/消失事件。</p><p><strong>prefetchingEnabled</strong></p><p>当调用 <code>collectionView:didEndDisplayingCell:forItemAtIndexPath:</code> 后，cell 不会立刻进入复用队列，系统会<strong>keeps it around for a bit</strong>。相当于会缓存该 cell 一小段时间，在这段时间内如果该 cell 再次回到屏幕中，便不会重新调用 <code>cellForItemAtIndexPath:</code>，而是直接显示。</p><p>至于系统会缓存多久，官方并没有给出明确的时间，感觉跟程序运行时开销有关。</p><p>如果想关闭该功能，需要设置 <code>collectionView.prefetchingEnabled = NO;</code>。</p><p><strong>UICollectionViewLayoutInvalidationContext</strong></p><p>当改变 UICollectionView item 的时候，通过调用 <code>-invalidateLayout</code> 方法让 UICollectionView 布局失效，通过 Invalidation Context 声明了在布局失效时布局的哪些部分需要被更新，布局对象就可以根据该信息减小重新计算的数据量。</p><p>IGListKit 提供了自定义的 IGListCollectionViewLayout 类来优化 UICollectionView 的刷新，IGListCollectionViewLayout 实现和 UICollectionViewLayoutInvalidationContext 相关的方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">IGListCollectionViewLayoutInvalidationContext</span> : <span class="title">UICollectionViewLayoutInvalidationContext</span></span></span><br><span class="line"><span class="comment">// 追加视图</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> ig_invalidateSupplementaryAttributes;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> ig_invalidateAllAttributes;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>IGListCollectionViewLayoutInvalidationContext 类继承了 UICollectionViewLayoutInvalidationContext，用于记录刷新布局相关逻辑</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// -[UICollectionView setFrame:] / -[UICollectionView setBounds:] 会触发</span></span><br><span class="line">- (<span class="built_in">UICollectionViewLayoutInvalidationContext</span> *)invalidationContextForBoundsChange:(<span class="built_in">CGRect</span>)newBounds &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">CGRect</span> oldBounds = <span class="keyword">self</span>.collectionView.bounds;</span><br><span class="line">    </span><br><span class="line">    IGListCollectionViewLayoutInvalidationContext *context =</span><br><span class="line">    (IGListCollectionViewLayoutInvalidationContext *)[<span class="keyword">super</span> invalidationContextForBoundsChange:newBounds];</span><br><span class="line">  <span class="comment">// 每次都需要刷新 追加视图</span></span><br><span class="line">    context.ig_invalidateSupplementaryAttributes = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">CGSizeEqualToSize</span>(oldBounds.size, newBounds.size)) &#123;</span><br><span class="line">      <span class="comment">// size 改变之后，必须进行全量刷新</span></span><br><span class="line">        context.ig_invalidateAllAttributes = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> context;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-invalidationContextForBoundsChange:</code>  当 UICollectionView 发生变化的时候（比如视图 frame 发生改变），在进行视图刷新之前，会触发该方法返回 UICollectionViewLayoutInvalidationContext 对象来告诉UICollectionView 布局刷新的相关信息。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 context 中的信息重新计算布局改变的部分。</span></span><br><span class="line"><span class="comment">// -[UICollectionView setDataSource:] / -[UICollectionView setFrame:] 会触发该方法</span></span><br><span class="line"><span class="comment">// 也可以主动调用，强制刷新</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidateLayoutWithContext:(IGListCollectionViewLayoutInvalidationContext *)context &#123;</span><br><span class="line">    <span class="built_in">BOOL</span> hasInvalidatedItemIndexPaths = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">if</span> ([context respondsToSelector:<span class="keyword">@selector</span>(invalidatedItemIndexPaths)]) &#123;</span><br><span class="line">        hasInvalidatedItemIndexPaths = [context invalidatedItemIndexPaths].count &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// _minimumInvalidatedSection 用来记录指定从哪个 section 开始的布局失效，需要重新布局</span></span><br><span class="line">    <span class="keyword">if</span> (hasInvalidatedItemIndexPaths</span><br><span class="line">        || [context invalidateEverything]</span><br><span class="line">        || context.ig_invalidateAllAttributes) &#123;</span><br><span class="line">        <span class="comment">// invalidates all</span></span><br><span class="line">        _minimumInvalidatedSection = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([context invalidateDataSourceCounts] &amp;&amp; _minimumInvalidatedSection == <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">      <span class="comment">// invalidateDataSourceCounts 标记 layout 需要重新从 UICollectionView 查询 section 和 item 数目</span></span><br><span class="line">      <span class="comment">// UICollectionView 调用 -reloadData 或者插入/删除 item 的时候 invalidateDataSourceCounts = YES</span></span><br><span class="line">      <span class="comment">// 如果 layout 需要重新 UICollectionView 的信息或者没有找到重新刷新的 section 启动，则刷新起点 section 默认为0</span></span><br><span class="line">        _minimumInvalidatedSection = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (context.ig_invalidateSupplementaryAttributes) &#123;</span><br><span class="line">      <span class="comment">// 清空追加视图的布局信息缓存</span></span><br><span class="line">        [<span class="keyword">self</span> _resetSupplementaryAttributesCache];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">super</span> invalidateLayoutWithContext:context];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-invalidateLayoutWithContext:</code> 方法在 UICollectionView 布局信息发生变化会被系统调用，IGListCollectionViewLayout 实现了该方法，在调用的过程中会对一些布局缓存进行更新（主要是缓存 UICollectionViewLayoutAttributes 对象），具体细节不再展开。</p><p>除此之外，UICollectionViewLayoutInvalidationContext 本身提供了几个方法，用户可以主动调用来进行局部 UI 刷新</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用此方法以标识布局中需要更新的特定单元格。 </span></span><br><span class="line"><span class="comment">// 指定的更新的所有 indexPath 对象将添加到属性 invalidatedItemIndexPaths 中。</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidateItemsAtIndexPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *)indexPaths API_AVAILABLE(ios(<span class="number">8.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新计算一个或者多个追加视图的布局</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidateSupplementaryElementsOfKind:(<span class="built_in">NSString</span> *)elementKind atIndexPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *)indexPaths API_AVAILABLE(ios(<span class="number">8.0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重新计算一个或者多个装饰视图的布局</span></span><br><span class="line">- (<span class="keyword">void</span>)invalidateDecorationElementsOfKind:(<span class="built_in">NSString</span> *)elementKind atIndexPaths:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSIndexPath</span> *&gt; *)indexPaths API_AVAILABLE(ios(<span class="number">8.0</span>));</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从汇编角度分析objc_msgSend的hook过程</title>
      <link href="/2019/07/13/hook-objc-MsgSend/"/>
      <url>/2019/07/13/hook-objc-MsgSend/</url>
      
        <content type="html"><![CDATA[<p><code>objc_msgSend</code> 是基于汇编实现的，hook <code>objc_msgSend</code> 和我们平时 hook OC 方法不一样，在 github 上有开源的<a href="https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/GCDFetchFeed/Lib/SMLagMonitor/SMCallTraceCore.c" target="_blank" rel="noopener">项目</a>通过 hook <code>objc_msgSend</code> 来监控每个函数的耗时情况。这篇文章对其 hook 逻辑的主要代码进行分析记录。阅读前建议先了解开源库 fishhook 的源码。</p><a id="more"></a><h3 id="主流程"><a href="#主流程" class="headerlink" title="主流程"></a>主流程</h3><p>先看开源 <a href="https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/GCDFetchFeed/Lib/SMLagMonitor/SMCallTraceCore.c" target="_blank" rel="noopener">项目</a> 主要代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#define call(b, value) \</span><br><span class="line">__asm volatile (&quot;stp x8, x9, [sp, #-16]!\n&quot;); \</span><br><span class="line">__asm volatile (&quot;mov x12, %0\n&quot; :: &quot;r&quot;(value)); \</span><br><span class="line">__asm volatile (&quot;ldp x8, x9, [sp], #16\n&quot;); \</span><br><span class="line">__asm volatile (#b &quot; x12\n&quot;);</span><br><span class="line"></span><br><span class="line">#define save() \</span><br><span class="line">__asm volatile ( \</span><br><span class="line">&quot;stp x8, x9, [sp, #-16]!\n&quot; \</span><br><span class="line">&quot;stp x6, x7, [sp, #-16]!\n&quot; \</span><br><span class="line">&quot;stp x4, x5, [sp, #-16]!\n&quot; \</span><br><span class="line">&quot;stp x2, x3, [sp, #-16]!\n&quot; \</span><br><span class="line">&quot;stp x0, x1, [sp, #-16]!\n&quot;);</span><br><span class="line"></span><br><span class="line">#define load() \</span><br><span class="line">__asm volatile ( \</span><br><span class="line">&quot;ldp x0, x1, [sp], #16\n&quot; \</span><br><span class="line">&quot;ldp x2, x3, [sp], #16\n&quot; \</span><br><span class="line">&quot;ldp x4, x5, [sp], #16\n&quot; \</span><br><span class="line">&quot;ldp x6, x7, [sp], #16\n&quot; \</span><br><span class="line">&quot;ldp x8, x9, [sp], #16\n&quot; );</span><br><span class="line"></span><br><span class="line">#define link(b, value) \</span><br><span class="line">__asm volatile (&quot;stp x8, lr, [sp, #-16]!\n&quot;); \</span><br><span class="line">__asm volatile (&quot;sub sp, sp, #16\n&quot;); \</span><br><span class="line">call(b, value); \</span><br><span class="line">__asm volatile (&quot;add sp, sp, #16\n&quot;); \</span><br><span class="line">__asm volatile (&quot;ldp x8, lr, [sp], #16\n&quot;);</span><br><span class="line"></span><br><span class="line">#define ret() __asm volatile (&quot;ret\n&quot;);</span><br><span class="line"></span><br><span class="line">__attribute__((__naked__))</span><br><span class="line">static void hook_Objc_msgSend() &#123;</span><br><span class="line">    // Save parameters.</span><br><span class="line">    /// Step 1</span><br><span class="line">    save()</span><br><span class="line">    </span><br><span class="line">    /// Step 2</span><br><span class="line">    __asm volatile (&quot;mov x2, lr\n&quot;);</span><br><span class="line">    __asm volatile (&quot;mov x3, x4\n&quot;);</span><br><span class="line">    </span><br><span class="line">    // Call our before_objc_msgSend.</span><br><span class="line">    /// Step 3</span><br><span class="line">    call(blr, &amp;before_objc_msgSend)</span><br><span class="line">    </span><br><span class="line">    // Load parameters.</span><br><span class="line">    /// Step 4</span><br><span class="line">    load()</span><br><span class="line">    </span><br><span class="line">    // Call through to the original objc_msgSend.</span><br><span class="line">    /// Step 5</span><br><span class="line">    call(blr, orig_objc_msgSend)</span><br><span class="line">    </span><br><span class="line">    // Save original objc_msgSend return value.</span><br><span class="line">    /// Step 6</span><br><span class="line">    save()</span><br><span class="line">    </span><br><span class="line">    // Call our after_objc_msgSend.</span><br><span class="line">    /// Step 7</span><br><span class="line">    call(blr, &amp;after_objc_msgSend)</span><br><span class="line">    </span><br><span class="line">    // restore lr</span><br><span class="line">    /// Step 8</span><br><span class="line">    __asm volatile (&quot;mov lr, x0\n&quot;);</span><br><span class="line">    </span><br><span class="line">    // Load original objc_msgSend return value.</span><br><span class="line">    /// Step 9</span><br><span class="line">    load()</span><br><span class="line">    </span><br><span class="line">    // return</span><br><span class="line">    /// Step 10</span><br><span class="line">    ret()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对以上代码我们分步骤来看</p><ol><li><p><code>save()</code> 保存函数入参(x0-x8)到栈内存，因为接下来你的函数调用修改原有参数。这里源码里面看到 x9 的值也被保存了，这里的原因是因为栈指针移动必须满足 <code>SP Mod 16 = 0</code> 的条件，而在 x8 寄存器只占用8个字节，剩余8个字节控件由 x9 来填充</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define save() \</span><br><span class="line">__asm volatile ( \</span><br><span class="line">&quot;stp x8, x9, [sp, #-16]!\n&quot; \</span><br><span class="line">&quot;stp x6, x7, [sp, #-16]!\n&quot; \</span><br><span class="line">&quot;stp x4, x5, [sp, #-16]!\n&quot; \</span><br><span class="line">&quot;stp x2, x3, [sp, #-16]!\n&quot; \</span><br><span class="line">&quot;stp x0, x1, [sp, #-16]!\n&quot;);</span><br></pre></td></tr></table></figure></li><li><p>保存 lr 到 x2，以便 <code>call(blr, &amp;before_objc_msgSend)</code> 的调用，保存到 x2 是因为 <code>before_objc_msgSend</code> 函数第三个参数需要传入 lr，方便后续返回；<code>blr</code> 指令会改变 lr 寄存器的值，所以调用前先保存 lr</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#define call(b, value) \</span><br><span class="line">__asm volatile (&quot;stp x8, x9, [sp, #-16]!\n&quot;); \</span><br><span class="line">__asm volatile (&quot;mov x12, %0\n&quot; :: &quot;r&quot;(value)); \</span><br><span class="line">__asm volatile (&quot;ldp x8, x9, [sp], #16\n&quot;); \</span><br><span class="line">__asm volatile (#b &quot; x12\n&quot;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void before_objc_msgSend(id self, SEL _cmd, uintptr_t lr) &#123;</span><br><span class="line">    push_call_record(self, object_getClass(self), _cmd, lr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static inline void push_call_record(id _self, Class _cls, SEL _cmd, uintptr_t lr) &#123;</span><br><span class="line">    thread_call_stack *cs = get_thread_call_stack();</span><br><span class="line">    if (cs) &#123;</span><br><span class="line">        int nextIndex = (++cs-&gt;index);</span><br><span class="line">        if (nextIndex &gt;= cs-&gt;allocated_length) &#123;</span><br><span class="line">            cs-&gt;allocated_length += 64;</span><br><span class="line">            cs-&gt;stack = (thread_call_record *)realloc(cs-&gt;stack, cs-&gt;allocated_length * sizeof(thread_call_record));</span><br><span class="line">        &#125;</span><br><span class="line">        thread_call_record *newRecord = &amp;cs-&gt;stack[nextIndex];</span><br><span class="line">        newRecord-&gt;self = _self;</span><br><span class="line">        newRecord-&gt;cls = _cls;</span><br><span class="line">        newRecord-&gt;cmd = _cmd;</span><br><span class="line">        newRecord-&gt;lr = lr;</span><br><span class="line">        if (cs-&gt;is_main_thread &amp;&amp; _call_record_enabled) &#123;</span><br><span class="line">            struct timeval now;</span><br><span class="line">            gettimeofday(&amp;now, NULL);</span><br><span class="line">            newRecord-&gt;time = (now.tv_sec % 100) * 1000000 + now.tv_usec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>__asm volatile (&quot;mov x3, x4\n&quot;);</code> 目前个人认为是冗余代码，在整个流程中貌似并没有实际作用。</p></li><li><p>通过 <code>blr</code> 指令 跳转执行 <code>before_objc_msgSend</code> 函数。这里会先保存 x8、x9 寄存器的值，原因是<code>__asm volatile (&quot;mov x12, %0\n&quot; :: &quot;r&quot;(value))</code> 执行命令过程中会通过 x8 来保存函数地址，再进行跳转，所以这里会先要保存 x8，和步骤1相同，栈指针移动必须满足 <code>SP Mod 16 = 0</code> 的条件，所以 x9 也被保存。执行完之后 x8、x9 恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define call(b, value) \</span><br><span class="line">__asm volatile (&quot;stp x8, x9, [sp, #-16]!\n&quot;); \</span><br><span class="line">__asm volatile (&quot;mov x12, %0\n&quot; :: &quot;r&quot;(value)); \</span><br><span class="line">__asm volatile (&quot;ldp x8, x9, [sp], #16\n&quot;); \</span><br><span class="line">__asm volatile (#b &quot; x12\n&quot;);</span><br></pre></td></tr></table></figure><p>在 <code>__asm volatile (&quot;mov x12, %0\n&quot; :: &quot;r&quot;(value))</code> 下断点可以看到 cpu 是通过 <code>adrp</code> + <code>add</code> 2个指令结合寻址到函数的地址并执行，过程中改变了 x8 的值</p><p><img src="/2019/07/13/hook-objc-MsgSend/adrp_add.png" alt="image-20190713185417531"></p></li></ol><ol start="4"><li><p>Step 4 到 Step 6，恢复原有入参，执行原函数，然后保存入参</p></li><li><p><code>call(blr, &amp;after_objc_msgSend)</code> 和步骤3相似，执行 hook 收尾的函数，主要是通过 TSD 返回步骤3保存的原来 lr 寄存器保存的内容，也就是hook前的 lr 寄存器值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">static inline uintptr_t pop_call_record() &#123;</span><br><span class="line">    thread_call_stack *cs = get_thread_call_stack();</span><br><span class="line">    int curIndex = cs-&gt;index;</span><br><span class="line">    int nextIndex = cs-&gt;index--;</span><br><span class="line">    thread_call_record *pRecord = &amp;cs-&gt;stack[nextIndex];</span><br><span class="line">    </span><br><span class="line">    if (cs-&gt;is_main_thread &amp;&amp; _call_record_enabled) &#123;</span><br><span class="line">        struct timeval now;</span><br><span class="line">        gettimeofday(&amp;now, NULL);</span><br><span class="line">        uint64_t time = (now.tv_sec % 100) * 1000000 + now.tv_usec;</span><br><span class="line">        if (time &lt; pRecord-&gt;time) &#123;</span><br><span class="line">            time += 100 * 1000000;</span><br><span class="line">        &#125;</span><br><span class="line">        uint64_t cost = time - pRecord-&gt;time;</span><br><span class="line">        if (cost &gt; _min_time_cost &amp;&amp; cs-&gt;index &lt; _max_call_depth) &#123;</span><br><span class="line">            if (!_smCallRecords) &#123;</span><br><span class="line">                _smRecordAlloc = 1024;</span><br><span class="line">                _smCallRecords = malloc(sizeof(smCallRecord) * _smRecordAlloc);</span><br><span class="line">            &#125;</span><br><span class="line">            _smRecordNum++;</span><br><span class="line">            if (_smRecordNum &gt;= _smRecordAlloc) &#123;</span><br><span class="line">                _smRecordAlloc += 1024;</span><br><span class="line">                _smCallRecords = realloc(_smCallRecords, sizeof(smCallRecord) * _smRecordAlloc);</span><br><span class="line">            &#125;</span><br><span class="line">            smCallRecord *log = &amp;_smCallRecords[_smRecordNum - 1];</span><br><span class="line">            log-&gt;cls = pRecord-&gt;cls;</span><br><span class="line">            log-&gt;depth = curIndex;</span><br><span class="line">            log-&gt;sel = pRecord-&gt;cmd;</span><br><span class="line">            log-&gt;time = cost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pRecord-&gt;lr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>__asm volatile (&quot;mov lr, x0\n&quot;);</code> 将步骤5返回的值(原来lr的初始值)到lr寄存器</p></li><li><p>Step 9 - Step 10 恢复寄存器值，并返回。主要目的是还原原始函数的执行之后的状态。</p></li></ol><h3 id="遗留问题："><a href="#遗留问题：" class="headerlink" title="遗留问题："></a>遗留问题：</h3><p>以上就是整个汇编 hook <code>objc_msgSend</code> 的主要过程，目前遗留一个问题是：</p><ol><li><code>__asm volatile (&quot;mov x3, x4\n&quot;);</code> 这行代码是否属于冗余代码呢？</li></ol><p>参考文章：</p><p><a href="https://juejin.im/post/5d14623ef265da1bb47d7635" target="_blank" rel="noopener">arm64程序调用规则</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入了解Objective-C消息发送与转发过程</title>
      <link href="/2019/06/02/objc-msgSend-forward/"/>
      <url>/2019/06/02/objc-msgSend-forward/</url>
      
        <content type="html"><![CDATA[<p>在 Objective-C 语言中，对象/类(其实类也是一个对象) 执行方法最后会转化成给对象发送消息: </p><p><code>objc_msgSend(receiver, @selector(message))</code> </p><p>如果 <code>reveiver</code> 中没有找到对应方法 <code>message</code>, 则会开始消息转发的过程，也就是过程：</p><ol><li>动态方法解析 Method Resolution</li><li>快速转发 Fast Rorwarding</li><li>完整消息转发 Normal Forwarding</li></ol><p>接下来通过OC的源码来分析以上几个步骤具体的调用过程</p><a id="more"></a><h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><p>当在 OC 中给对象执行方法，如 <code>[object foo]</code>，会被翻译为 <code>objc_msgSend(object, @selector(foo))</code>，<code>@seletor</code> 会将 foo 方法生成对应的选择子(SEL)，选择子只跟方法名有关系，不同的类之间可以存在相同的方法选择子，但是同一个类(及类的继承体系)中，不能存在2个同名的方法，即使参数类型不同也不行，也就是说 OC 中不支持像 C++ 那样的函数重载。</p><blockquote><p><em>当编译器遇到一个方法调用时，它会将方法的调用翻译成以下函数中的一个</em> <code>objc_msgSend</code><em>、</em><code>objc_msgSend_stret</code><em>、</em><code>objc_msgSendSuper</code> <em>和</em> <code>objc_msgSendSuper_stret</code><em>。 发送给对象的父类的消息会使用</em> <code>objc_msgSendSuper</code> <em>有数据结构作为返回值的方法会使用</em> <code>objc_msgSendSuper_stret</code> <em>或</em> <code>objc_msgSend_stret</code> <em>其它的消息都是使用</em> <code>objc_msgSend</code> <em>发送的</em></p></blockquote><p><code>objc_msgSend</code> 的具体实现是由汇编语言编写的，其中具体过程细节可以参考我另一篇文章<a href="https://chipengliu.github.io/2019/04/07/objc-msg-armd64/">objc-msg-arm64源码深入分析</a></p><p><code>objc_msgSend</code> 函数执行过程中，如果根据 SEL 在接受者(object)方法列表的 cache 缓存中没有查找到对应的方法 IMP，会执行 C 语言函数 <code>__class_lookupMethodAndLoadCache3</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> lookUpImpOrForward(cls, sel, obj, </span><br><span class="line">                              YES<span class="comment">/*initialize*/</span>, NO<span class="comment">/*cache*/</span>, YES<span class="comment">/*resolver*/</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法只允许被 <code>_objc_msgSend</code> 内部调度，其他方式应该使用 <code>lookUpImp</code> 此函数将忽略缓存查询，因为执行此函数之前能确保已经查询过对应的内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IMP <span class="title">lookUpImpOrForward</span><span class="params">(Class cls, SEL sel, id inst, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Class curClass;</span><br><span class="line">    IMP imp = nil;</span><br><span class="line">    Method meth;</span><br><span class="line">    <span class="keyword">bool</span> triedResolver = NO;</span><br><span class="line"></span><br><span class="line">    runtimeLock.assertUnlocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optimistic cache lookup</span></span><br><span class="line">    <span class="comment">// 这里传入cache==false，因为objc_msgSend汇编阶段已经查找过缓存，故直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (cache) &#123;</span><br><span class="line">        imp = cache_getImp(cls, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) <span class="keyword">return</span> imp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现对应的类，设置父类、元类等等相关信息，分配可读写结构体 class_rw_t 的空间</span></span><br><span class="line">    <span class="keyword">if</span> (!cls-&gt;isRealized()) &#123;</span><br><span class="line">        <span class="keyword">rwlock_writer_t</span> lock(runtimeLock);</span><br><span class="line">        realizeClass(cls);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 判断类别是否已经初始化过，初始化过程会触发+initialize</span></span><br><span class="line">    <span class="keyword">if</span> (initialize  &amp;&amp;  !cls-&gt;isInitialized()) &#123;</span><br><span class="line">        _class_initialize (_class_getNonMetaClass(cls, inst));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里加锁是因为OC在运行时能动态添加方法，</span></span><br><span class="line">  <span class="comment">// 比方说分类 category 添加方法是在运行时期添加</span></span><br><span class="line">  <span class="comment">// 如果此时不添加锁进行原子读操作，很可能因为新方法添加导致缓存被冲洗（flush）</span></span><br><span class="line"> retry:</span><br><span class="line">    runtimeLock.read();<span class="comment">//加读锁</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持GC的环境需要对一些方法进行忽略，比如retain、release...等等</span></span><br><span class="line">    <span class="keyword">if</span> (ignoreSelector(sel)) &#123;</span><br><span class="line">        imp = _objc_ignored_method;</span><br><span class="line">        cache_fill(cls, sel, imp, inst);</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try this class's cache.</span></span><br><span class="line">    <span class="comment">// 再次查询缓存</span></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 这里为什么会再次查询缓存列表？一开始cache==NO直接忽略了缓存查询，为什么加锁之后却要重新从缓存查询</span></span><br><span class="line">    <span class="comment">// 结合加锁的逻辑，是否因为调度的时候是并列的，但是读的时候是原子，很可能加锁之后因为上一次查找过程中重新更新了方法列表缓存？</span></span><br><span class="line">    imp = cache_getImp(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (imp) <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Try this class's method lists.</span></span><br><span class="line">    <span class="comment">// 缓存没有查到，到方法列表中查询</span></span><br><span class="line">    meth = getMethodNoSuper_nolock(cls, sel);</span><br><span class="line">    <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">        <span class="comment">// 查到就更新缓存列表</span></span><br><span class="line">        log_and_fill_cache(cls, meth-&gt;imp, sel, inst, cls);</span><br><span class="line">        imp = meth-&gt;imp;</span><br><span class="line">        <span class="keyword">goto</span> done;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始在父类中进行查找</span></span><br><span class="line">    curClass = cls;</span><br><span class="line">    <span class="keyword">while</span> ((curClass = curClass-&gt;superclass)) &#123;</span><br><span class="line">        <span class="comment">// 从父类缓存中查询</span></span><br><span class="line">        imp = cache_getImp(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (imp) &#123;</span><br><span class="line">            <span class="comment">// 如果是 _objc_msgForward_impcache 则不进行缓存</span></span><br><span class="line">            <span class="keyword">if</span> (imp != (IMP)_objc_msgForward_impcache) &#123;</span><br><span class="line">                <span class="comment">// 在父类查询到也存在本类的缓存中</span></span><br><span class="line">                log_and_fill_cache(cls, imp, sel, inst, curClass);</span><br><span class="line">                <span class="keyword">goto</span> done;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 如果查找到的 IMP 为 _objc_msgForward_impcache 直接结束查找</span></span><br><span class="line">              <span class="comment">// 并执行 -resolveInstanceMethod: / +resolveClassMethod:</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从父类方法列表中查</span></span><br><span class="line">        meth = getMethodNoSuper_nolock(curClass, sel);</span><br><span class="line">        <span class="keyword">if</span> (meth) &#123;</span><br><span class="line">            log_and_fill_cache(cls, meth-&gt;imp, sel, inst, curClass);</span><br><span class="line">            imp = meth-&gt;imp;</span><br><span class="line">            <span class="keyword">goto</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父类中也没有找到方法</span></span><br><span class="line">    <span class="keyword">if</span> (resolver  &amp;&amp;  !triedResolver) &#123;</span><br><span class="line">        runtimeLock.unlockRead();</span><br><span class="line">        <span class="comment">// 进行 -resolveInstanceMethod: / +resolveClassMethod: 动态添加方法 </span></span><br><span class="line">        _class_resolveMethod(cls, sel, inst);</span><br><span class="line">        <span class="comment">// 动态实现完了之后，因为之前锁已经解锁，方法列表可能已经更新了，所以会从新进行一轮方法查找</span></span><br><span class="line">        triedResolver = YES;</span><br><span class="line">        <span class="keyword">goto</span> retry;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// No implementation found, and method resolver didn't help. </span></span><br><span class="line">    <span class="comment">// Use forwarding.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行方法转发并对其结果进行缓存</span></span><br><span class="line">    imp = (IMP)_objc_msgForward_impcache;</span><br><span class="line">    cache_fill(cls, sel, imp, inst);</span><br><span class="line"></span><br><span class="line"> done:</span><br><span class="line">    runtimeLock.unlockRead();</span><br><span class="line"></span><br><span class="line">    assert(!(ignoreSelector(sel)  &amp;&amp;  imp != (IMP)&amp;_objc_ignored_method));</span><br><span class="line"></span><br><span class="line">    assert(imp != _objc_msgSend_uncached_impcache);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个方法查找的过程，可以简单的概括为以下几个步骤</p><ol><li>实现、初始化对应的类</li><li>根据是否支持垃圾回收机制(GC)判断是否忽略当前的方法调用</li><li>从cache中查找方法</li><li>cache中没有找到对应的方法，则到方法列表中查，查到则缓存</li><li>如果本类中查询到没有结果，则遍历所有父类重复上面的查找过程</li><li>最后都没有找到的方法的话，则执行 <code>_class_resolveMethod</code> 让调用者动态添加方法，并重复一轮查询方法的过程</li><li>若第六步没有完成动态添加方法，则把 _objc_msgForward_impcache 作为对应 SEL 的方法进行缓存，然后调用 _objc_msgForward_impcache 方法</li></ol><h2 id="动态方法解析"><a href="#动态方法解析" class="headerlink" title="动态方法解析"></a>动态方法解析</h2><p>消息发送的过程中，如果没有找到先进行 <code>_class_resolveMethod</code> 允许开发者动态的根据 SEL 实现对应的 IMP，实现前先执行 <code>runtimeLock.unlockRead()</code> 打开了读锁，所以开发者在此动态实现的过程添加了方法实现，故不需要缓存方法；</p><p> <code>_class_resolveMethod</code> 调用过程又是非原子性的，执行完的时候方法列表可能已经更新了，所以执行完了之后需要重复一轮查询方法的过程</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _class_resolveMethod(Class cls, SEL sel, <span class="keyword">id</span> inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (! cls-&gt;isMetaClass()) &#123;</span><br><span class="line">        <span class="comment">// try [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// try [nonMetaClass resolveClassMethod:sel]</span></span><br><span class="line">        <span class="comment">// and [cls resolveInstanceMethod:sel]</span></span><br><span class="line">        _class_resolveClassMethod(cls, sel, inst);</span><br><span class="line">        <span class="keyword">if</span> (!lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                            <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            _class_resolveInstanceMethod(cls, sel, inst);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 cls 不是元类，则执行 <code>_class_resolveInstanceMethod</code> 函数；否则 cls 属于元类则会调用 <code>_class_resolveClassMethod</code> ，然后执行 <code>lookUpImpOrNil</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IMP lookUpImpOrNil(Class cls, SEL sel, <span class="keyword">id</span> inst, </span><br><span class="line">                   <span class="keyword">bool</span> initialize, <span class="keyword">bool</span> cache, <span class="keyword">bool</span> resolver)</span><br><span class="line">&#123;</span><br><span class="line">    IMP imp = lookUpImpOrForward(cls, sel, inst, initialize, cache, resolver);</span><br><span class="line">    <span class="keyword">if</span> (imp == _objc_msgForward_impcache) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> imp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lookUpImpOrNil</code> 和 <code>lookUpImpOrForward</code> 类似，前者内部是先调用后者函数，判断返回 imp 结果是否和 _objc_msgForward_impcache 相同，如果相同返回 nil，反之返回 imp。</p><p>需要注意的是在 <code>lookUpImpOrNil</code> 中并不会对 cls 进行初始化(initialize)或者是方法动态实现过程(resolver)，若 <code>lookUpImpOrNil</code> 返回了nil，则会调用 <code>_class_resolveInstanceMethod</code></p><p>这里以非元类来分析</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _class_resolveInstanceMethod(Class cls, SEL sel, <span class="keyword">id</span> inst)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果类没有实现 +resolveInstanceMethod 方法则返回nil</span></span><br><span class="line">    <span class="keyword">if</span> (! lookUpImpOrNil(cls-&gt;ISA(), SEL_resolveInstanceMethod, cls, </span><br><span class="line">                         <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 objc_msgSend 来执行  resolveInstanceMethod 方法</span></span><br><span class="line">    <span class="built_in">BOOL</span> (*msg)(Class, SEL, SEL) = (<span class="keyword">typeof</span>(msg))objc_msgSend;</span><br><span class="line">    <span class="keyword">bool</span> resolved = msg(cls, SEL_resolveInstanceMethod, sel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// resolveInstanceMethod 执行过程中肯能会动态添加方法， lookUpImpOrNil 会缓存最新的imp(不管是否是开发者动态实现)，</span></span><br><span class="line">  <span class="comment">// 这样做可以下次方法调用的时候，不会再次执行动态方法解析的过程</span></span><br><span class="line">    IMP imp = lookUpImpOrNil(cls, sel, inst, </span><br><span class="line">                             <span class="literal">NO</span><span class="comment">/*initialize*/</span>, <span class="literal">YES</span><span class="comment">/*cache*/</span>, <span class="literal">NO</span><span class="comment">/*resolver*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ......忽略相关日志代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，消息转发前的逻辑已经全部走完，简单总结一下各个函数调用的顺序作用：</p><ol><li>汇编入口 <code>_objc_msgSend</code> 为消息发送的入口</li><li>找不到方法则跳转到 <code>__objc_msgSend_uncached_impcache</code> ，对栈进行相关操作</li><li>跳转 <code>_class_lookupMethodAndLoadCache3</code> (objc-runtime-new.mm)</li><li>第一次执行 <code>lookUpImpOrForward</code>, 对相关类进行 initialize 相关操作，忽略缓存列表去查找方法，如果找不到会进行 reslover 动态方法解析</li><li>步骤4会一直从本类到父类进行重复查找，如果都没有找到方法则调用 <code>_class_resolveMethod</code> 进行方法动态解析</li><li>如果是非元类，则直接跳转到 <code>_class_resolveInstanceMethod</code> ，函数内部会先调用 <code>lookUpImpOrNil</code> 来判断类有没有实现 <code>+resolveInstanceMethod</code> 方法，这里的查找结果也会缓存到 cache 中，内部查找也是通过 <code>lookUpImpOrForward</code> 来实现，根据返回的imp是否为 <code>_objc_msgForward_impcache</code> ，若是则返回 nil，然后 <code>_class_resolveClassMethod</code> 会直接return，结束动态解析过程</li><li>若 <code>+resolveClassMethod</code> 被实现，则同过 <code>objc_msgSend</code> 来执行 <code>+resolveClassMethod</code> 方法；缓存结果，减少 <code>_class_resolveClassMethod</code> 过程调用</li></ol><h2 id="消息转发"><a href="#消息转发" class="headerlink" title="消息转发"></a>消息转发</h2><p>在第一次执行 <code>lookUpImpOrForward</code> 过程中，动态解析方法完了之后，还没有找到方法，则放回 <code>_objc_msgForward_impcache</code></p><p><code>__objc_msgSend_uncached_impcache</code> 汇编代码会利用 br 指令跳转到 <code>_objc_msgForward_impcache</code> ，后者内部是通过 b 指令跳转到 <code>__objc_msgForward</code>，最后会调用 <code>_objc_forward_handler</code> 函数(objc-runtime.h)</p><p><code>_objc_msgSend_uncached_impcache</code> 的默认实现为 <code>objc_defaultForwardHandler</code> </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noreturn)) <span class="keyword">void</span> </span><br><span class="line">objc_defaultForwardHandler(<span class="keyword">id</span> <span class="keyword">self</span>, SEL sel)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_fatal(<span class="string">"%c[%s %s]: unrecognized selector sent to instance %p "</span></span><br><span class="line">                <span class="string">"(no message forward handler is installed)"</span>, </span><br><span class="line">                class_isMetaClass(object_getClass(<span class="keyword">self</span>)) ? <span class="string">'+'</span> : <span class="string">'-'</span>, </span><br><span class="line">                object_getClassName(<span class="keyword">self</span>), sel_getName(sel), <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> *_objc_forward_handler = (<span class="keyword">void</span>*)objc_defaultForwardHandler;</span><br></pre></td></tr></table></figure><p>从代码实现中可以看到熟悉的报错日志：<strong>unrecognized selector sent to instance</strong></p><p>要自定义转发过程则需要通过 <code>objc_setForwardHandler</code> 来重写 <code>objc_defaultForwardHandler</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> objc_setForwardHandler(<span class="keyword">void</span> *fwd, <span class="keyword">void</span> *fwd_stret)</span><br><span class="line">&#123;</span><br><span class="line">    _objc_forward_handler = fwd;</span><br><span class="line"><span class="meta">#if SUPPORT_STRET</span></span><br><span class="line">    _objc_forward_stret_handler = fwd_stret;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>objc_setForwardHandler</code> 的调用是在 <strong>Core Foundation</strong> 中实现，但在其开源代码中，苹果删除了件 <code>__CFInitialize()</code> 中调用 <code>objc_setForwardHandler</code> 的代码。具体可以参考文章<a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="noopener">Objective-C 消息发送与转发机制原理</a></p><p>消息转发的过程大概可以分为以下几步:</p><ol><li>快速转发：开发者通过重写 <code>forwardingTargetForSelector:</code> 方法提供新的接受者(forwardingTarget)来重新执行 seletor；如果 forwardingTarget 和旧的接受者相同或者为nil，则进入下一步</li><li>完整消息转发：重写 <code>methodSignatureForSelector:</code> 方法获取方法签名并新建一个 <strong>NSInvocation</strong> 对象 invocation，invocation作为参数传入开发者重写的 <code>forwardInvocation:</code> 方法从而完成整个消息的转发</li><li>若步骤2没有完成转发则会调用 <code>doesNotRecognizeSelector</code> 方法，抛出异常</li></ol><h2 id="消息转发特性能做什么？"><a href="#消息转发特性能做什么？" class="headerlink" title="消息转发特性能做什么？"></a>消息转发特性能做什么？</h2><p>了解过消息转发的过程，那我们能利用这特性解决什么问题呢？</p><h3 id="1-AOP"><a href="#1-AOP" class="headerlink" title="1. AOP"></a>1. AOP</h3><p>既然能接管消息转发的过程，很容易联想到通过消息转发在原有方法执行的过程中插入需要的代码逻辑，从而实现切面编程，具体可以参考<a href="https://halfrost.com/objc_runtime_objc_msgsend/#forwardinvocation" target="_blank" rel="noopener">forwardInvocation的例子</a></p><h3 id="2-解决NSTimer强引用Target导致循环引用"><a href="#2-解决NSTimer强引用Target导致循环引用" class="headerlink" title="2.解决NSTimer强引用Target导致循环引用"></a>2.解决NSTimer强引用Target导致循环引用</h3><p>跟第一个例子相似，也是通过 NSProxy 进行消息转发，在原有 NSTimer 和target 之间加入一层proxy解决循环引用问题</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> _weakObject;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)invocation &#123;</span><br><span class="line">    <span class="keyword">void</span> *null = <span class="literal">NULL</span>;</span><br><span class="line">    [invocation setReturnValue:&amp;null];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector &#123;</span><br><span class="line">    <span class="keyword">return</span> [_weakObject respondsToSelector:aSelector];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考文章:</p><ol><li><a href="https://juejin.im/post/5ae96e8c6fb9a07ac85a3860" target="_blank" rel="noopener">iOS开发·runtime原理与实践: 消息转发篇(Message Forwarding)</a></li><li><a href="https://draveness.me/message" target="_blank" rel="noopener">从源代码看 ObjC 中消息的发送</a></li><li><a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="noopener">Objective-C 消息发送与转发机制原理</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Objective-C </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>objc-msg-arm64源码深入分析</title>
      <link href="/2019/04/07/objc-msg-armd64/"/>
      <url>/2019/04/07/objc-msg-armd64/</url>
      
        <content type="html"><![CDATA[<p>在 Objective-C 语言中，实例对象执行方法，而执行方法的过程也可以称为给实例对象发送消息。发送消息的过程执行在编译阶段会转化成对 <code>objc_msgSend</code> 函数的调用。本文将分析 <code>objc_msgSend</code> 汇编部分主要部分(fast path)。</p><p>文章中用到的汇编指令可以参考我个人的<a href="https://chipengliu.github.io/2019/04/05/asm-note">汇编学习笔记</a></p><a id="more"></a><h2 id="Objective-C-实例对象执行方法步骤"><a href="#Objective-C-实例对象执行方法步骤" class="headerlink" title="Objective-C 实例对象执行方法步骤"></a>Objective-C 实例对象执行方法步骤</h2><p><code>objc_msgSend</code> 前2个传入参数有对象实例 <code>receiver</code> 和方法名 <code>selector</code>，执行过程可以简单概括为:</p><ol><li>获取 <code>receiver</code> 对应的类 Class</li><li>在 Class 缓存列表中根据选择子 <code>selector</code> 查找 IMP</li><li>若缓存中没有找到，则在方法列表中继续查找</li><li>若方法列表没有，则从父类查找，重复以上步骤</li><li>若最终没有找到，则进行消息转发操作</li></ol><h2 id="objc-msgSend-汇编源码内部逻辑"><a href="#objc-msgSend-汇编源码内部逻辑" class="headerlink" title="objc_msgSend 汇编源码内部逻辑"></a>objc_msgSend 汇编源码内部逻辑</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">ENTRY _objc_msgSend// _objc_msgSend 入口</span><br><span class="line">MESSENGER_START</span><br><span class="line"></span><br><span class="line">cmpx0, #0// nil check and tagged pointer check, cmp 指令执行完，设置Z-flag(零标志)</span><br><span class="line">b.leLNilOrTagged// 如果 x0 的值==0，CPSR寄存器的 Z 标识==1，跳转标签判断是否 self 是否为 nil 或者是 tagged pointer 类型</span><br><span class="line">//跳转之前 lr 寄存器会保存 pc 寄存器当前内容</span><br><span class="line">ldrx13, [x0]// x13 = isa，把 self 指针赋值到 x13，self 是 objc_object 结构体，结构体第一个属性是 isa，所以这里 x13 指向了 isa</span><br><span class="line">andx9, x13, #ISA_MASK// x9 = class，与运算来移除掉这些多余的信息，将一个真实指向类的指针保存在 x9 里</span><br><span class="line">LGetIsaDone:</span><br><span class="line">CacheLookup NORMAL// calls imp or objc_msgSend_uncached</span><br><span class="line"></span><br><span class="line">LNilOrTagged:// 执行到这里说明 self 的值等于 0。小于零则代表为 Tagged Pointer 情况，等于说明为 nil</span><br><span class="line">b.eqLReturnZero// nil check，判断 self 是否为 nil</span><br><span class="line"></span><br><span class="line">// tagged</span><br><span class="line">// 这里加载了 _objc_debug_taggedpointer_classes 的地址，即 Tagged Pointer 主表</span><br><span class="line">// ARM64 需要两条指令来加载一个符号的地址。这是 RISC 样架构上的一个标准技术。</span><br><span class="line">// AMR64 上的指针是 64 位宽的，指令是 32 位宽。所以一个指令无法保存一个完整的指针</span><br><span class="line"></span><br><span class="line">adrpx10, _objc_debug_taggedpointer_classes@PAGE// 将页(前半部分)的基址存在 x10</span><br><span class="line">addx10, x10, _objc_debug_taggedpointer_classes@PAGEOFF // 将页(后半部分)的基址存在 x10</span><br><span class="line">ubfxx11, x0, #60, #4// 它从 self 中的第 60 位开始，提取 4 位，保存到 x11 中。</span><br><span class="line">ldrx9, [x10, x11, LSL #3]// x9 = x10 + (x11&lt;&lt;3)，这里通过 x11 里的索引到 x10 所指向的 Tagged Pointer 表中查找具体的类</span><br><span class="line">bLGetIsaDone</span><br><span class="line"></span><br><span class="line">LReturnZero:</span><br><span class="line">// x0 is already zero</span><br><span class="line">// 因为近来之前已经通过 `cmp x0, #0` 判断，所以 x0 寄存器的值是0</span><br><span class="line"></span><br><span class="line">// 整型的返回值保存在 x0 和 x1 中</span><br><span class="line">// 浮点型的返回值会被保存在 v0 到 v3 这几个向量寄存器中，</span><br><span class="line">// d0 到 d3这几个寄存器是相关v寄存器的后半部分，向他们存值的时候会将对应 v 寄存器的前半部分置 0</span><br><span class="line"></span><br><span class="line">movx1, #0 // 1、首先先把 x1 清空，x0 这里是 self，已经是0，所以不需要清空，</span><br><span class="line">movid0, #0// 2、清空 v 寄存器</span><br><span class="line">movid1, #0</span><br><span class="line">movid2, #0</span><br><span class="line">movid3, #0</span><br><span class="line">MESSENGER_END_NIL</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">END_ENTRY _objc_msgSend</span><br></pre></td></tr></table></figure><p><code>_objc_msgSend</code> 函数可以分解2个主线</p><ol><li>receiver 为 nil 或者属于 tagged pointer 类型</li><li>receiver 不为空，正常查找 IMP</li></ol><h3 id="receiver-不为空"><a href="#receiver-不为空" class="headerlink" title="receiver 不为空"></a>receiver 不为空</h3><p>首先先分析 receiver 不为空的情况</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. ldrx13, [x0]</span><br><span class="line">2. andx9, x13, #ISA_MASK</span><br><span class="line">3. LGetIsaDone:</span><br><span class="line">CacheLookup NORMAL</span><br></pre></td></tr></table></figure><ol><li><code>x0</code> 当前存储的是 self 指针，ldr 指令 self 指针所指向的内存位置读取数据并保存到  <code>x13</code> 寄存器中，这时候 <code>x13</code> 存储了 isa</li><li><p>isa 和 ISA_MASK 做与运算，移除掉这些多余的信息得到 Class 并存储到 <code>x9</code></p></li><li><p>开始从 Class 缓存中查找 IMP</p></li></ol><p>CacheLookup 是一个宏</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.macro CacheLookup</span><br><span class="line">// x1 = SEL, x9 = isa</span><br><span class="line">// x9 保存着 objc_class 指针</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">.endmacro</span><br></pre></td></tr></table></figure><p>进入宏之前，<code>x1</code> 保存了 SEL (ARM寄存器 x0-x7 寄存器是用来传递参数的，objc_msgSend 函数的前2个参数分别是 self 和 _cmd)，还有之前处理得到的 isa 保存在 x9。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldpx10, x11, [x9, #CACHE]// x10 = buckets, x11 = occupied|mask</span><br><span class="line">andw12, w1, w11// x12 = _cmd &amp; mask</span><br><span class="line">addx12, x10, x12, LSL #4// x12 = buckets + ((_cmd &amp; mask)&lt;&lt;4)</span><br></pre></td></tr></table></figure><ol><li><p><code>ldp x10, x11, [x9, #CACHE]</code>：CACHE 是一个常数(0x10)，以 objc_class 地址为基准，然后读 16 字节的数据（可以参考 objc-runtime-new.h objc_class 结构体），x10 = buckets，x11 = occupied|mask (高32位：occupied，低32位：mask)；</p><p>mask 代表哈希表的位数，它的值总是2 - 1的幂，或者用二进制表示就是000000001111111，末尾有一个可变的1</p></li><li><p><code>and w12, w1, w11</code>：进行 AND 运算，得到选择子的查询索引</p></li><li><p><code>add x12, x10, x12, LSL #4</code>: <code>x12</code> 左移4位也就是乘以16，这是因为每个哈希表的 bucket 是 16 字节，计算得出要搜索位置的 <strong>第一个</strong> bucket 的<strong>地址</strong>并保存在 <code>x12</code> 中</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ldpx16, x17, [x12]// &#123;x16, x17&#125; = *bucket</span><br><span class="line">1:cmpx16, x1// if (bucket-&gt;sel != _cmd)</span><br><span class="line">b.ne2f//     scan more</span><br><span class="line">CacheHit $0// call or return imp</span><br><span class="line"></span><br><span class="line">2:// not hit: x12 = not-hit bucket</span><br><span class="line">CheckMiss $0// miss if bucket-&gt;cls == 0</span><br><span class="line">cmpx12, x10// wrap if bucket == buckets</span><br><span class="line">b.eq3f</span><br><span class="line">ldpx16, x17, [x12, #-16]!</span><br><span class="line">b1b// loop</span><br><span class="line"></span><br><span class="line">3:// wrap: x12 = first bucket, w11 = mask</span><br><span class="line">addx12, x12, w11, UXTW #4// x12 = buckets+(mask&lt;&lt;4)</span><br></pre></td></tr></table></figure><ol><li><p><code>ldp x16, x17, [x12]</code>: 从 bucket 指针指向的内存地址读取数据，<code>x16</code> 存储要查找 bucket 中的 key（选择子），<code>x17</code> 存储了 IMP</p></li><li><p><code>cmp x16, x1</code>: 判断第一个 bucket 中的 sel 跟参数 _cmd 是否相同</p><ul><li>相同: 跳转到 CacheHit 继续执行，改标签中会执行指令 <code>br x17</code>，也就是执行 IMP </li><li>不相同: 跳转到 CheckMiss 继续执行 <code>cbz x16, __objc_msgSend_uncached_impcache</code>，cbz 指令比较寄存器值是否等于0，如果是0则跳转；这里 <code>x16</code> 中记录了从 bucket 加载到的选择子。首先先将其与 0 进行比较，如果等于 0 则会跳转至 C 函数 <code>__objc_msgSend_uncached_impcache</code> 进行更复杂的查找</li></ul></li><li><p><code>cmp x12, x10</code>: 判断当前的 bucket 指针是不是和数组 buckets 指针相同，相同则说明在列表头</p></li><li><p>判断当前 bucket 的位置：</p><ol><li><p>如果 bucket == buckets，则把指针指向 buckets 列表尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b.eq3f</span><br><span class="line">addx12, x12, w11, UXTW #4</span><br><span class="line">ldpx16, x17, [x12]</span><br></pre></td></tr></table></figure><p>cmp 指令执行之后如果，如果 x12 - x10 == 0，csrp 寄存器 Z 标志位置位1，反之为0。</p><p>b.eq 当 Z 标志位为 1，跳转到 3f，执行 <code>add x12, x12, w11, UXTW #4</code></p><p>x12 存储了 buckets 指针，指向了第一个 bucket，w11 是存储表的掩码，描述了表的大小，相加之后当前指针指向最后一个 bucket</p></li><li><p>如果 bucket != buckets， </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldpx16, x17, [x12, #-16]!</span><br><span class="line">b1b// loop</span><br></pre></td></tr></table></figure><p>x12-16 获取新的 bucket 地址并重新写入到 x12 中 (!符号代表寄存器回写)，指向前一个 bucket，<code>x16</code> 存储要查找 bucket 中的 key（选择子 ，<code>x17</code> 存储了 IMP，然后重复之前的步骤</p></li></ol></li></ol><p>接着上面的4.1步骤，bucket 指针指向 buckets 列表尾</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1:cmpx16, x1// if (bucket-&gt;sel != _cmd)</span><br><span class="line">b.ne2f//     scan more</span><br><span class="line">CacheHit $0// call or return imp</span><br><span class="line"></span><br><span class="line">2:// not hit: x12 = not-hit bucket</span><br><span class="line">CheckMiss $0// miss if bucket-&gt;cls == 0</span><br><span class="line">cmpx12, x10// wrap if bucket == buckets</span><br><span class="line">b.eq3f</span><br><span class="line">ldpx16, x17, [x12, #-16]!// &#123;x16, x17&#125; = *--bucket</span><br><span class="line">b1b// loop</span><br><span class="line"></span><br><span class="line">3:// double wrap</span><br><span class="line">JumpMiss $0</span><br></pre></td></tr></table></figure><ol><li>判断当前 bucket 的选择子和传入参数 _cmd 是否相同，相同则跳转到 CacheHit 执行对应的 IMP，不相同则往下走</li><li>执行 CheckMiss 宏判断 bucket 的选择子是否为空，若未空跳转执行 <code>__objc_msgSend_uncached_impcache</code> C 函数</li><li><code>cmp x12, x10</code> ，检查是否在 buckets 表头循环搜索完 或者 是hash碰撞，如果是则跳转到 JumpMiss，最终会执行 <code>__objc_msgSend_uncached_impcache</code> 函数执行，进行更复杂的查找</li><li>若步骤3不成立，则 bucket 指针前移，重复1-3的步骤</li></ol><p>recever 不为空的情况下， <code>objc_msgSend</code> 全部过程分析到此完毕</p><h3 id="receiver-等于-nil"><a href="#receiver-等于-nil" class="headerlink" title="receiver 等于 nil"></a>receiver 等于 nil</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LNilOrTagged:// 执行到这里说明 self 的值小于等于 0。小于零则代表为 Tagged Pointer 情况，等于说明为 nil</span><br><span class="line">b.eqLReturnZero// nil check，判断 self 是否为 nil</span><br></pre></td></tr></table></figure><p><code>objc_msgSend</code> 开始会将利用 <code>cmp</code> 指令将 receiver 和 0 做比较，若结果是小于等于0则会跳转到 LNilOrTagged 执行。</p><p>若 receiver == 0，则跳转到 LReturnZero</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">LReturnZero:</span><br><span class="line">// x0 is already zero</span><br><span class="line">// 因为近来之前已经通过 `cmp x0, #0` 判断，所以 x0 寄存器的值是0</span><br><span class="line"></span><br><span class="line">// 整型的返回值保存在 x0 和 x1 中</span><br><span class="line">// 浮点型的返回值会被保存在 v0 到 v3 这几个向量寄存器中，</span><br><span class="line">// d0 到 d3这几个寄存器是相关v寄存器的后半部分，向他们存值的时候会将对应 v 寄存器的前半部分置 0</span><br><span class="line"></span><br><span class="line">movx1, #0 // 1、首先先把 x1 清空，x0 这里是 self，已经是0，所以不需要清空，</span><br><span class="line">movid0, #0// 2、清空 v 寄存器</span><br><span class="line">movid1, #0</span><br><span class="line">movid2, #0</span><br><span class="line">movid3, #0</span><br><span class="line">MESSENGER_END_NIL</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>这里先后把整形寄存器和向量寄存器都置为0，这样做的好处是：</p><p><code>objc_msgSend</code> 不知道调用者希望获得什么类型的返回值，是一个整型？两个？还是浮点类型或是其他类型？把所有返回值的寄存器都覆盖为0，后面调用者不管是想得到整型还是浮点型，都是0值。</p><p>那么如果调用者需要的返回值类型不是属于整型/浮点型，比如是寄存器不够存储的，更大结构的返回值需要调用者在内存中分配合适的内存空间并把内存地址传入 <code>x8</code>，函数通过写入这块内存来返回值。</p><p><code>objc_msgSend</code> 执行过程中并不知道 <code>x8</code> 内存，所以在 LReturnZero 中并没有清除内存。解决办法是编译器生成代码会 <code>objc_msgSend</code> 执行前用0填满这块内存。</p><h3 id="Tagged-pointer-处理"><a href="#Tagged-pointer-处理" class="headerlink" title="Tagged pointer 处理"></a>Tagged pointer 处理</h3><p><code>Tagged Pointer</code> 通过在其最后一个 bit 位设置一个特殊标记，用于将数据直接保存在指针本身中。具体细节可以参考<a href="https://www.infoq.cn/article/deep-understanding-of-tagged-pointer" target="_blank" rel="noopener">深入理解 Tagged Pointer</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// tagged</span><br><span class="line">// 这里加载了 _objc_debug_taggedpointer_classes 的地址，即 Tagged Pointer 主表</span><br><span class="line">// ARM64 需要两条指令来加载一个符号的地址。这是 RISC 样架构上的一个标准技术。</span><br><span class="line">// AMR64 上的指针是 64 位宽的，指令是 32 位宽。所以一个指令无法保存一个完整的指针</span><br><span class="line"></span><br><span class="line">adrpx10, _objc_debug_taggedpointer_classes@PAGE// 将页(前半部分)的基址存在 x10</span><br><span class="line">addx10, x10, _objc_debug_taggedpointer_classes@PAGEOFF // 将页(后半部分)的基址存在 x10</span><br><span class="line">ubfxx11, x0, #60, #4// 它从 self 中的第 60 位开始，提取 4 位，保存到 x11 中。</span><br><span class="line">ldrx9, [x10, x11, LSL #3]// x9 = x10 + (x11&lt;&lt;3)</span><br><span class="line">bLGetIsaDone</span><br></pre></td></tr></table></figure><ol><li>通过 <code>adrp</code> 指令计算 _objc_debug_taggedpointer_classes 表(存储可用的 Tagged Pointer 的类)的数据地址到当前pc寄存器值相对偏移。</li><li>AMR64 上的指针是 64 位宽的，指令是 32 位宽。所以一个指令无法保存一个完整的指针，于是还要通过 <code>add</code> 指令把后半部分读取存储到 <code>x10</code> 中</li><li><code>ubfx</code> 指令读取 <code>x11</code> 中最后4位数据，也就是 Tagged pointer 表所以标志</li><li><code>x9 = x10 + (x11&lt;&lt;3)</code>，这里通过 x11 里的索引到 x10 所指向的 Tagged pointer 表中查找具体的 Tagged pointer 类</li><li>获取到 isa 之后进行 CacheLookup 步骤</li></ol><p>自此 <code>objc_msgSend</code> 过程已经全部分析完，整个流程可以用下图表示：</p><p><img src="/2019/04/07/objc-msg-armd64/sequence.png" alt="sequence"></p><h2 id="为什么要用汇编实现"><a href="#为什么要用汇编实现" class="headerlink" title="为什么要用汇编实现"></a>为什么要用汇编实现</h2><p><code>objc_msgSend</code> 函数实现并不是用 Objective-C、C 或者 C++ 实现的，而是利用汇编语言开发。</p><p>那为什么会采用汇编语言实现呢？首先看一个例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUInteger</span> n = [array count];</span><br><span class="line"><span class="keyword">id</span> obj = [array objectAtIndex:<span class="number">1</span>];</span><br></pre></td></tr></table></figure><p>我们可以理解上面2行代码编译时期会转化为：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUInteger</span> n = objc_msgSend(array,  <span class="keyword">@selector</span>(count));</span><br><span class="line"><span class="keyword">id</span> obj = objc_msgSend(array, <span class="keyword">@selector</span>(objectAtIndex:), <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>假设 <code>objc_msgSend</code> 是 C 或者 C++ 实现的，这里不可能编译成功，因为返回值也不能同时是 <code>NSUInteger</code> 和 <code>id</code>；这里可以使用类型强制转化来解决:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSUInteger</span> n = (<span class="built_in">NSUInteger</span> (*)(<span class="keyword">id</span>, SEL))objc_msgSend(array,  <span class="keyword">@selector</span>(count));</span><br><span class="line"><span class="keyword">id</span> obj = (<span class="keyword">id</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">NSUInteger</span>))objc_msgSend(array, <span class="keyword">@selector</span>(objectAtIndex:), <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>从例子上可以看的出，<code>objc_msgSend</code> 有2个特点：</p><ol><li>可以调用任意参数类型、数量的任意函数</li><li>支持不同类型的返回值</li></ol><p>对于特点1，调用 objc_msgSend 的之前，栈帧（stack frame）的状态、数据，和各个寄存器的组合形式、数据，跟调用具体的函数指针（IMP）时所需的状态、数据，是完全一致的。</p><p>基于这个前提，遍历并找到 IMP 之后，只要所有的对栈、寄存器的操作回复到调用 objc_msgSend 之前的状态，通过 jump/call 指令执行函数即可。</p><p>在 ARM 上，IMP 函数执行完， <code>r0</code> 寄存器会保存其返回值，能满足其返回不同类型返回值的需求</p><p>参考文章:</p><p><a href="https://blog.csdn.net/u011342466/article/details/52741003" target="_blank" rel="noopener">为什么objc_msgSend必须用汇编实现</a></p><p><a href="https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html" target="_blank" rel="noopener">Dissecting objc_msgSend on ARM64</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> Runtime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言学习笔记</title>
      <link href="/2019/04/05/asm-note/"/>
      <url>/2019/04/05/asm-note/</url>
      
        <content type="html"><![CDATA[<p>此篇文章是学习分析 objc-msg-arm64.s 源码过程中需要用到的汇编知识的一点记录</p><a id="more"></a><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>在内存中有两种字节排布顺序，大端序(BE)或者小端序(LE)。两者的主要不同是对象中的每个字节在内存中的存储顺序存在差异。一般X86中是小端序，最低的字节存储在最低的地址上。在大端机中最高的字节存储在最低的地址上。</p><p><img src="/2019/04/05/asm-note/endian.png" alt="endian"></p><p>在版本3之前，ARM使用的是小端序，但在这之后就都是使用大端序了，但也允许切换回小端序。在我们样例代码所在的ARMv6中，指令代码是以<a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.ddi0301h/Cdfbbchb.html" target="_blank" rel="noopener">[小端序排列对齐]</a>。但是数据访问时采取大端序还是小端序使用程序状态寄存器(CPSR)的第9比特位来决定的。</p><p><img src="/2019/04/05/asm-note/endian2.png" alt="endian2"></p><h2 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h2><p>ARM 32位处理器有16个寄存器，从 r0 到 r15，每一个都是32位比特。调用约定指定他们其中的一些寄存器有特殊的用途，例如：</p><ul><li>r0-r3：用于存放传递给函数的参数；</li><li>r4-r11：用于存放函数的本地参数；</li><li>r12：是内部程序调用暂时寄存器。这个寄存器很特别是因为可以通过函数调用来改变它；</li><li>r13：栈指针sp(stack pointer)。在计算机科学内栈是非常重要的术语。寄存器存放了一个指向<strong>栈顶</strong>的指针。看<a href="https://link.jianshu.com?t=http://en.wikipedia.org/wiki/Call_stack" target="_blank" rel="noopener">这里</a>了解更多关于栈的信息；</li><li>r14：是链接寄存器lr(link register)。它保存了当目前函数返回时下一个函数的地址；</li><li>r15：是程序计数器pc(program counter)。它存放了当前执行指令的地址。在每个指令执行完成后会自动增加；</li></ul><blockquote><p>ARM寄存器 r0, r1, r2, r3四个寄存器是用来传递参数的; r4, r5, …, r11这些寄存器是通用的，在函数内部可以使用，<strong>但是用完需要恢复</strong>，所以一般函数里面会先把需要使用的寄存器入栈，比如如要使用r7作为临时变量，那么会有下面的调用： push {r7, lr} 即把r7和返回地址入栈，等到函数要返回前，再出栈恢复r7寄存器。 pop {r7, lr} r12 r13：sp栈指针寄存器，ARM使用FD栈，sp指向栈顶数据，且向下增长。 r14：lr保存返回地址——即调用该函数后下一条指令的地址 r15：pc——当前执行的指令地址</p></blockquote><p>64位处理器有34个寄存器，包括31个通用寄存器、SP、PC、CPSR。</p><table><thead><tr><th><strong>寄存器</strong></th><th><strong>位数</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>x0-x30</td><td>64bit</td><td>通用寄存器，如果有需要可以当做32bit使用：wO-w30</td></tr><tr><td>FP(x29)</td><td>64bit</td><td>保存栈帧地址(栈底指针)</td></tr><tr><td>LR(x30)</td><td>64bit</td><td>通常称 <code>x30</code> 为程序链接寄存器，保存子程序结束后需要执行的下一条指令</td></tr><tr><td>SP</td><td>64bit</td><td>保存栈指针,使用 SP/WSP 来进行对 SP 寄存器的访问。严格来说叫栈顶指针，永远指向栈的顶部。</td></tr><tr><td>PC</td><td>64bit</td><td>程序计数器，俗称 PC 指针，总是指向即将要执行的下一条指令,在 arm64 中，软件是不能改写 PC 寄存器的。</td></tr><tr><td>CPSR</td><td>64bit</td><td>状态寄存器</td></tr></tbody></table><ul><li><p>x0-x7: 用于子程序调用时的参数传递，<code>x0</code> 还用于返回值传递</p></li><li><p><code>x0 - x30</code> 是31个通用整形寄存器。每个寄存器可以存取一个64位大小的数。 当使用 <code>r0 - r30</code> 访问时，它就是一个64位的数。当使用 <code>w0 - w30</code> 访问时，访问的是这些寄存器的低32位</p><p><img src="https://upload-images.jianshu.io/upload_images/1117042-e3fabfec65c187f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt="img"></p></li></ul><h3 id="浮点寄存器"><a href="#浮点寄存器" class="headerlink" title="浮点寄存器"></a>浮点寄存器</h3><p>因为浮点数的存储以及其运算的特殊性，CPU提供浮点数寄存器来处理浮点数；</p><p>128位的浮点向量寄存器可分为5种:</p><ul><li>用作8位寄存器时记作  :Bn; (Byte,字节)</li><li>用作16位寄存器时记作 :Hn; (Half Word,半字)</li><li>用作32位寄存器时记作 :Sn; (Single Word,单字)</li><li>用作64位寄存器时记作 :Dn; (Double Word,双字)</li><li>用作128位寄存器时记作:Qn; (Quad Word,四字)<br>n=0 … 30;</li></ul><h2 id="伪操作"><a href="#伪操作" class="headerlink" title="伪操作"></a>伪操作</h2><h3 id="text"><a href="#text" class="headerlink" title=".text:"></a>.text:</h3><p>段保存代码，是只读和可执行的，后面那些指令都属于 <code>.text</code> 段。</p><h3 id="global"><a href="#global" class="headerlink" title=".global"></a>.global</h3><p> 让一个符号对链接器可见，可以供其他链接对象模块使用。</p><h3 id="extern"><a href="#extern" class="headerlink" title=".extern"></a>.extern</h3><p><code>.extern</code> FUNC 说明 FUNC 为外部函数，调用的时候可以遍访所有文件找到该函数并且使用它。</p><h3 id="section"><a href="#section" class="headerlink" title=".section"></a>.section</h3><p>分段，用户可以通过 <code>.section</code> 伪操作来自定义一个段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.section expr; // expr 可以是 .text/.data/.bss</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">.text将定义符开始的代码编译到代码段</span><br><span class="line">.data 将定义符开始的数据编译到数据段</span><br><span class="line">.bss  将变量存放到.bss段，bss段通常是指用来存放程序中未初始化的全局变量的一块内存区域 数据段通常是指用来存放程序中已初始化的全局变量的一块内存区域</span><br><span class="line"></span><br><span class="line">注意：源程序中.bss段应该在.text之前</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h3 id="quad"><a href="#quad" class="headerlink" title=".quad"></a>.quad</h3><p>定义8字节的数据</p><h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="b"><a href="#b" class="headerlink" title="b"></a>b</h3><p>b {条件} 目标地址</p><p>b 指令是最简单的跳转指令。一旦遇到一个 <code>b</code> 指令，ARM 处理器将立即跳转到给定的目标地址，从那里继<br>续执行。注意存储在跳转指令中的实际值是相对当前 PC 值的一个偏移量，而不是一个绝对地址，它的值由汇编器来计算（参考寻址方式中的相对寻址）。它是 24 位有符号数，左移两位后有符号扩展为 32 位，表示的有效偏移为 26 位(前后32MB 的地址空间)。以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b Label//程序无条件跳转到标号 Label 处执行</span><br><span class="line">cmp R1, ＃0 //当 CPSR 寄存器中的 Z 条件码置位时，程序跳转到标号 Label 处执行</span><br><span class="line">beq Label</span><br></pre></td></tr></table></figure><h3 id="bl"><a href="#bl" class="headerlink" title="bl"></a>bl</h3><p>branch with link</p><p>bl{条件} 目标地址</p><p>bl 是另一个跳转指令，但跳转之前，会在寄存器 r14(lr) 中保存 <code>pc</code> 的当前内容，因此，可以通过将 <code>r14</code> 的内容重新加载到 <code>pc</code> 中，来返回到跳转指令之后的那个指令处执行。该指令是实现子程序调用的一个基本但常用的手段。以下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bl Label //当程序无条件跳转到标号 Label 处执行时，同时将当前的 pc 值保存到 r14 中</span><br></pre></td></tr></table></figure><h3 id="bx"><a href="#bx" class="headerlink" title="bx"></a>bx</h3><p>bx{条件} 目标地址</p><p>跳转到指令中所指定的目标地址，目标地址处的指令既可以是 ARM 指令，也可以是 Thumb 指令。</p><h3 id="blx"><a href="#blx" class="headerlink" title="blx"></a>blx</h3><p>blx 指令从 ARM 指令集跳转到指令中所指定的目标地址，并将处理器的工作状态有 ARM 状态切换到 Thumb 状态，该指令同时将 pc 的当前内容保存到寄存器 <code>r14</code> 中。因此，当子程序使用 Thumb 指令集，而调用者使用ARM 指令集时，可以通过 BLX 指令实现子程序的调用和处理器工作状态的切换。</p><h3 id="br"><a href="#br" class="headerlink" title="br"></a>br</h3><p>无条件的跳转命令，用于跳转到 reg 内容地址</p><h3 id="adrp"><a href="#adrp" class="headerlink" title="adrp"></a>adrp</h3><p>计算指定的数据地址到当前pc寄存器值相对偏移</p><h3 id="movw"><a href="#movw" class="headerlink" title="movw"></a>movw</h3><p>mov word，把16位立即数放到寄存器的底16位，<strong>高16位清0</strong></p><h3 id="movt"><a href="#movt" class="headerlink" title="movt"></a>movt</h3><p>把16位立即数放到寄存器的高16位，<strong>低16位不影响</strong></p><h3 id="movs"><a href="#movs" class="headerlink" title="movs"></a>movs</h3><p>用一个<strong>字节</strong>长度值来填充寄存器</p><h3 id="ldr"><a href="#ldr" class="headerlink" title="ldr"></a>ldr</h3><p>把数据从内存中某处读取到寄存器；mov不能实现这个功能，mov只能在寄存器之间移动数据，或者把立即数移动到寄存器中</p><h3 id="ldp-stp"><a href="#ldp-stp" class="headerlink" title="ldp/stp"></a>ldp/stp</h3><p>从栈取/存数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldp x29, x30, [sp], #16;// 把 x29, x30的值存到 sp-16的地址上，并且把 sp-=16. </span><br><span class="line">stp x29, x30, [sp, #-16]!;// 把 x29, x30的值存到 sp-16的地址上，并且把 sp-=16.</span><br></pre></td></tr></table></figure><h3 id="SBFX-UBFX"><a href="#SBFX-UBFX" class="headerlink" title="SBFX/UBFX"></a>SBFX/UBFX</h3><p>有符号和无符号位域提取。 将一个寄存器中相邻的位复制到另一个寄存器的最低有效位，并用符号或零扩展到 32 位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">op&#123;cond&#125; Rd(目标寄存器), Rn(源寄存器), #lsb, #width</span><br><span class="line">// lsb: 是位域中的最低有效位的位编码，范围从 0 到 31</span><br><span class="line">// width: 是位域宽度，范围从 1 到 (32–lsb)。</span><br></pre></td></tr></table></figure><p>不要将 <code>r15</code> 用作 <code>Rd</code> 或 <code>Rn</code>。</p><h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h3><p>cmp 操作对象1, 操作对象2</p><p>计算 操作对象1 - 操作对象2 但不保存结果，只是根据结果修改相应的标志位。</p><h3 id="cbz-cbnz"><a href="#cbz-cbnz" class="headerlink" title="cbz/cbnz"></a>cbz/cbnz</h3><p>cbz比较，为零则跳转；</p><p>cbnz比较，为非零则跳转。</p><h3 id="UXTH"><a href="#UXTH" class="headerlink" title="UXTH"></a>UXTH</h3><p>无符号（Unsigned）扩展一个半字（Half）到 32位，相当于左移 4 位。</p><h3 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h3><p>返回；默认使用 lr 寄存器的值，通过底层指令指示 CPU 此处作为下条指令地址</p><h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mov r0, r1 =&gt; r0 = r1</span><br><span class="line">mov r0, #10 =&gt; r0 = 10</span><br><span class="line">ldr r0, [sp] =&gt; r0 = *sp</span><br><span class="line">str r0, [sp] =&gt; *sp = r0</span><br><span class="line">add r0, r1, r2 =&gt; r0 = r1 + r2</span><br><span class="line">add r0, r1 =&gt; r0 = r0 + r1</span><br><span class="line">push &#123;r0, r1, r2&#125; =&gt; r0, r1, r2 入栈</span><br><span class="line">pop &#123;r0, r1, r2&#125; =&gt; 栈顶出三个, 并赋值给r0, r1 and r2.</span><br><span class="line">b _label =&gt; pc = _label</span><br><span class="line">bl _label =&gt; lr = pc + 4; pc = _label</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ldr = 加载字，宽度四字节</span><br><span class="line">ldrh = 加载无符号的半字，宽度两字节</span><br><span class="line">ldrsh = 加载有符号的半字，宽度两字节</span><br><span class="line">ldrb = 加载无符号的字节</span><br><span class="line">ldrsb = 加载有符号的字节</span><br><span class="line">str = 存储字，宽度四字节</span><br><span class="line">strh = 存储无符号的半字，宽度两字节</span><br><span class="line">strsh = 存储有符号的半字，宽度两字节</span><br><span class="line">strb = 存储无符号的字节</span><br><span class="line">strsb = 存储有符号的字节</span><br></pre></td></tr></table></figure><p><img src="/2019/04/05/asm-note/work.png" alt="数据类型"></p><h2 id="分析样例"><a href="#分析样例" class="headerlink" title="分析样例"></a>分析样例</h2><h4 id="样例一"><a href="#样例一" class="headerlink" title="样例一"></a>样例一</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> addFunction(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">    .globl  _addFunction</span><br><span class="line">    .align  2</span><br><span class="line">    .code   16                      @ @addFunction</span><br><span class="line">    .thumb_func _addFunction</span><br><span class="line">_addFunction:</span><br><span class="line">    .cfi_startproc</span><br><span class="line">Lfunc_begin0:</span><br><span class="line">    .loc    1 13 0                  @ main.m:13:0</span><br><span class="line">@ BB#0:</span><br><span class="line">    sub sp, #12</span><br><span class="line">    str r0, [sp, #8]</span><br><span class="line">    str r1, [sp, #4]</span><br><span class="line">    .loc    1 14 18 prologue_end    @ main.m:14:18</span><br><span class="line">Ltmp0:</span><br><span class="line">    ldr r0, [sp, #8]</span><br><span class="line">    ldr r1, [sp, #4]</span><br><span class="line">    add r0, r1</span><br><span class="line">    str r0, [sp]</span><br><span class="line">    .loc    1 15 5                  @ main.m:15:5</span><br><span class="line">    ldr r0, [sp]</span><br><span class="line">    add sp, #12</span><br><span class="line">    bx  lr</span><br><span class="line">Ltmp1:</span><br><span class="line">Lfunc_end0:</span><br><span class="line">    .cfi_endproc</span><br></pre></td></tr></table></figure><ol><li>.号开始的行都不是汇编指令而是作用于汇编器，可忽略</li><li>以冒号为结束的行，是汇编的<strong>标签</strong>，作用是方便代码进行路由而无需知道指令的位置；当链接生成二进制文件的时候，链接器会将标签转换成实际内存地址</li><li>在汇编代码之后，以@开头的是对应代码文件的行数</li></ol><p>忽略掉注释和标签，重要的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_addFunction:</span><br><span class="line">@ 1:</span><br><span class="line">    sub sp, #12</span><br><span class="line">@ 2:</span><br><span class="line">    str r0, [sp, #8]</span><br><span class="line">    str r1, [sp, #4]</span><br><span class="line">@ 3:</span><br><span class="line">    ldr r0, [sp, #8]</span><br><span class="line">    ldr r1, [sp, #4]</span><br><span class="line">@ 4:</span><br><span class="line">    add r0, r1</span><br><span class="line">@ 5:</span><br><span class="line">    str r0, [sp]</span><br><span class="line">    ldr r0, [sp]</span><br><span class="line">@ 6:</span><br><span class="line">    add sp, #12</span><br><span class="line">@ 7:</span><br><span class="line">    bx  lr</span><br></pre></td></tr></table></figure><ol><li>分配 12 个字节长度的内存，sp = sp - 12</li><li><code>r0</code> 和 <code>r1</code> 存放着函数的2个参数，如果入参有四个参数，那么 <code>r2</code> 和 <code>r3</code> 就会分别存放第三和第四个参数。如果函数超过四个参数，或者一些例如结构体的参数超过了32位比特，那么参数将会通过栈来传递。这里通过 str 指令将 <code>r0</code> 和 <code>r1</code> 存储的值保存到 sp+8 和 sp+4 的栈内存位置</li><li>和 <code>str</code> 指令相反的，<code>ldr</code> 指令是从一个内存中加载内容到寄存器。这里分别将栈内存 sp+8 和 sp+4 的值赋值给 <code>r0</code> 和 <code>r1</code>，这里和2重复了，编译器会对这里进行优化</li><li>r0 = r0 + r1</li><li><em>sp = r0, ro = </em>sp，重复操作会被编译器优化</li><li>sp 指针地址增加12字节，sp = sp + 12，作用是为了回收步骤1申请的内存</li><li>返回到调用函数，<code>lr</code> (link register)存放了调用函数执行完当前函数(addFunction)的下一条指令</li></ol><h4 id="样例二"><a href="#样例二" class="headerlink" title="样例二"></a>样例二</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__attribute__((noinline))</span><br><span class="line"><span class="keyword">int</span> addFunction(<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> fooFunction() &#123;</span><br><span class="line">    <span class="keyword">int</span> add = addFunction(<span class="number">12</span>, <span class="number">34</span>);</span><br><span class="line">    printf(<span class="string">"add = %i"</span>, add);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">_fooFunction:</span><br><span class="line">@ 1:</span><br><span class="line">    push    &#123;r7, lr&#125;//推入栈, sp减去8字节</span><br><span class="line">@ 2:</span><br><span class="line">    movs    r0, #12</span><br><span class="line">    movs    r1, #34</span><br><span class="line">@ 3:</span><br><span class="line">    mov r7, sp</span><br><span class="line">@ 4:</span><br><span class="line">    bl  _addFunction</span><br><span class="line">@ 5:</span><br><span class="line">    mov r1, r0</span><br><span class="line">@ 6:</span><br><span class="line">    movw    r0, :lower16:(L_.str-(LPC1_0+4))</span><br><span class="line">    movt    r0, :upper16:(L_.str-(LPC1_0+4))</span><br><span class="line">LPC1_0:</span><br><span class="line">    add r0, pc</span><br><span class="line">@ 7:</span><br><span class="line">    blx _printf</span><br><span class="line">@ 8:</span><br><span class="line">    pop &#123;r7, pc&#125;</span><br></pre></td></tr></table></figure><ol><li><code>r7</code> 和 <code>lr</code> 被推入到栈，意味着 <code>sp</code>（栈指针）<strong>减掉了8字节</strong>（栈指针始终指向<strong>栈顶</strong>，所以在 push 的时候会变小），因为 <code>r7</code> 和 <code>lr</code> 都是4字节。栈指针向<strong>低地址</strong>增长而且通过一个指令<strong>存储了两个值</strong>。<code>r7</code> 的值需要存储起来的原因是之后函数执行时它会被使用到并重写。</li><li>通过 movs 指令将常量读取到 <code>r0</code> 和 <code>r1</code> 中(r0=12, r1=34)，这里用 movs 是直接以一个字节的长度去读取值并填充到寄存器中。此时 <code>r0</code> 和 <code>r1</code> 就是函数 addFunction 的2个参数</li><li>调用函数 addFunction 前，先将 <code>sp</code>(栈指针) 保存起来，又因为 <code>r7</code> 寄存器存放函数的本地参数。你会发现剩余的函数代码中并没有使用栈指针或者r7，因此这是个小小的多余处理。有时候开启了优化也优化不掉。</li><li>执行 <code>bl</code> 指令调用函数 addFunction，<code>lr</code>（链接寄存器）置为当前函数的下一个指令。</li><li>此时 <code>r0</code> 保存了 addFunction 函数的返回值（样例一 @5），这个值会作为 printf 函数的第二个参数，所以用 mov 赋值给 <code>r1</code></li><li>printf 函数的第一个参数是一个字符串。这三条指令作用是将字符串的<strong>开始地址</strong>的指针到 <code>r0</code> 寄存器。字符串存储在二进制文件中的『数据段』，只有最终二进制被链接时才能知道该数据的具体位置。字符串可以在main.m 生成的目标文件例找到。如果你在生成的汇编代码内搜索 <code>L.str</code>，便可找到它。前两个指令加载常量的地址，并减去标签的地址（LPC1_0+4字节，<code>add r0, pc</code> 指令占用4个字节）。r0 = r0 + pc（程序计数器），这样无论L.str在二进制文件的什么位置都能够准确的存放字符串的位置。 下面的图展示了内存分布。<code>L_.str - (LPC1_0 + 4)</code> 差值可以随便变动，但是加载r0的代码却不用变化。</li><li><code>blx</code> 跟 <code>bl</code> 略有区别，x代表处理器工作状态。</li><li>最后一条指令是推出<u>第一条指令推入</u>的值。这次寄存器的值是用栈中的值填充的，且栈指针增加了。回想下，<code>r7</code> 和 <code>lr</code> 之前是被推入到栈中，那么此时为何是推出来的值存入到了r7和pc中，而不是r7和lr呢？ 好的，记得lr是存储当前函数执行完成后的下一个指令地址吧。当你把lr推出栈赋值给pc后，执行将会从本函数调用的地方继续执行。这通常是一个函数返回的实现方式，而不是像 <code>addFunction</code> 那样切分支的方式。</li></ol><p>参考文章：</p><ol><li><a href="https://www.jianshu.com/p/544464a5e630" target="_blank" rel="noopener">iOS汇编教程：理解ARM</a></li><li><a href="https://blog.csdn.net/bytxl/article/details/49883103" target="_blank" rel="noopener">汇编跳转指令B、BL、BX、BLX 和 BXJ的区别</a></li><li><a href="https://blog.cnbluebox.com/blog/2017/07/24/arm64-start/" target="_blank" rel="noopener">iOS开发同学的arm64汇编入门</a></li><li><a href="http://infocenter.arm.com/help/index.jsp" target="_blank" rel="noopener">arm developer</a></li><li><a href="https://blog.csdn.net/Lcloud671/article/details/78232401" target="_blank" rel="noopener">C语言栈区的讲解(基于ARM)以及ARM sp,fp寄存器的作用</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 汇编 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactiveCocoa-RACChannel</title>
      <link href="/2019/04/01/ReactiveCocoa-RACChannel/"/>
      <url>/2019/04/01/ReactiveCocoa-RACChannel/</url>
      
        <content type="html"><![CDATA[<p>之前分析过 RACSignal，数据流向是单向而且是1对1的，如果想使用双向绑定的效果，可以使用 ReactiveCocoa 框架中提供的 RACChannel；接来下分析 RACChannel 底层的实现原理。</p><a id="more"></a><p>我们以一个例子开始分析，比如将视图控制器中的 UITextField text 属性和 viewModel 中的 inputText 属性进行双向绑定，一般会这么做：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACChannelTo(viewModel, inputText) = textField.rac_newTextChannel;</span><br></pre></td></tr></table></figure><p>绑定之后，当 textField 的输入内容变化之后，会通知到 viewModel 的 inputText 进行变化，同样的当</p><p>inputText 被主动修改之后 textField 的输入框文本也会同步修改</p><p><img src="/2019/04/01/ReactiveCocoa-RACChannel/example.png" alt="image-20190401151228767"></p><h2 id="RACChannel"><a href="#RACChannel" class="headerlink" title="RACChannel"></a>RACChannel</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACChannel</span>&lt;<span class="title">ValueType</span>&gt; : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACChannelTerminal&lt;ValueType&gt; *leadingTerminal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACChannelTerminal&lt;ValueType&gt; *followingTerminal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACChannelTerminal</span>&lt;<span class="title">ValueType</span>&gt; : <span class="title">RACSignal</span>&lt;<span class="title">ValueType</span>&gt; &lt;<span class="title">RACSubscriber</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init __attribute__((unavailable(<span class="string">"Instantiate a RACChannel instead"</span>)));</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">nullable</span> ValueType)value;</span><br></pre></td></tr></table></figure><p>RACChannel 持有2个 RACChannelTerminal 类型的只读属性 <code>leadingTerminal</code>、<code>followingTerminal</code>，RACChannelTerminal 是 RACChannel 的子类并实现了 RACSubscriber 协议</p><p>对 viewModel 的数据进行的操作会发送给 <code>leadingTerminal</code> 再通过内部转发给 <code>followingTerminal</code>，由于 textField 是 <code>followingTerminal</code> 的订阅者，所以消息最终会发送到视图上</p><p>类似的当 textField 输入内容发生变化的时候会把数据发送给 <code>followingTerminal</code>，然后内部转发给 <code>leadingTerminal</code>，因为 viewModel 是 <code>leadingTerminal</code> 的订阅者，所以数据最终会通知给 viewModel。</p><h3 id="RACChannelTerminal"><a href="#RACChannelTerminal" class="headerlink" title="RACChannelTerminal"></a>RACChannelTerminal</h3><p>在这个过程中，RACChannelTerminal 作用类似管道(pipe)和网络连接中的 socket，都表示连接中的一端；RACChannelTerminal 执行 sendNext，类似 socket 进行 write 给对端发送数据，类似的 subscribe 可以类比成 socket read。</p><p>了解了大概作用之后，在看看 RACChannelTerminal 的具体实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACChannelTerminal</span>&lt;<span class="title">ValueType</span>&gt; ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// The values for this terminal.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;ValueType&gt; *values;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A subscriber will will send values to the other terminal.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;RACSubscriber&gt; otherTerminal;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithValues:(RACSignal&lt;ValueType&gt; *)values otherTerminal:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)otherTerminal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RACChannelTerminal</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark Lifecycle</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithValues:(RACSignal *)values otherTerminal:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)otherTerminal &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(values != <span class="literal">nil</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(otherTerminal != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_values = values;</span><br><span class="line">_otherTerminal = otherTerminal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark RACSignal</span></span><br><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span>.values subscribe:subscriber];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark <span class="meta-string">&lt;RACSubscriber&gt;</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">[<span class="keyword">self</span>.otherTerminal sendNext:value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">[<span class="keyword">self</span>.otherTerminal sendError:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendCompleted &#123;</span><br><span class="line">[<span class="keyword">self</span>.otherTerminal sendCompleted];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable &#123;</span><br><span class="line">[<span class="keyword">self</span>.otherTerminal didSubscribeWithDisposable:disposable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>RACChannelTerminal 定义了2个私有属性：</p><ul><li>values：RACSignal，是所发送数据的信号源</li><li>otherTerminal：RACChannelTerminal类型，接受 values 发出信号的对端端点</li></ul><p>RACChannelTerminal 被订阅，比如订阅者调用 <code>-subscribeNext:</code> 等方法的时候，会执行 <code>-subscribe</code> 方法，于是最终订阅者会订阅 values 信号；当 RACChannelTerminal 发送信号的时候则会转发给对端断点 otherTerminal。</p><h3 id="RACChannel-初始化"><a href="#RACChannel-初始化" class="headerlink" title="RACChannel 初始化"></a>RACChannel 初始化</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// We don't want any starting value from the leadingSubject, but we do want</span></span><br><span class="line"><span class="comment">// error and completion to be replayed.</span></span><br><span class="line">RACReplaySubject *leadingSubject = [[RACReplaySubject replaySubjectWithCapacity:<span class="number">0</span>] setNameWithFormat:<span class="string">@"leadingSubject"</span>];</span><br><span class="line">RACReplaySubject *followingSubject = [[RACReplaySubject replaySubjectWithCapacity:<span class="number">1</span>] setNameWithFormat:<span class="string">@"followingSubject"</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate errors and completion to everything.</span></span><br><span class="line">[[leadingSubject ignoreValues] subscribe:followingSubject];</span><br><span class="line">[[followingSubject ignoreValues] subscribe:leadingSubject];</span><br><span class="line"></span><br><span class="line">_leadingTerminal = [[[RACChannelTerminal alloc] initWithValues:leadingSubject otherTerminal:followingSubject] setNameWithFormat:<span class="string">@"leadingTerminal"</span>];</span><br><span class="line">_followingTerminal = [[[RACChannelTerminal alloc] initWithValues:followingSubject otherTerminal:leadingSubject] setNameWithFormat:<span class="string">@"followingTerminal"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>初始化过程中首先会先初始化2个 RACReplaySubject 变量：</p><ol><li><p>leadingSubject：capacity为0，订阅者只能收到订阅之后 leadingSubject 发送的信号</p></li><li><p>followingSubject：capacity为1，订阅者订阅之后马上会搜到 followingSubject 之前最新发送的一个信号</p></li><li><p>将 followingSubject 设置成 leadingSubject 的订阅者，只接受 followingSubject 发送的 sendCompleted / sendError；同理 leadingSubject 也是 followingSubject 的订阅者并且只会收到 sendCompleted / sendError 事件。</p><p>处理后，当 leadingSubject(followingSubject) 发送 sendCompleted / sendError 之后，followingSubject(leadingSubject) 的 订阅者会收到相关信号。</p></li><li><p>初始化 leadingTerminal 和 followingTerminal，leadingTerminal/followingTerminal 被订阅的时候，实际上是订阅私有属性 values 的信号，leadingTerminal/followingTerminal 执行 sendNext 发送信号的时候会，其订阅者不会收到信号，而是转发给私有属性 otherTerminal 发送给它的订阅者</p></li></ol><h3 id="RACChannel-双向传输过程"><a href="#RACChannel-双向传输过程" class="headerlink" title="RACChannel 双向传输过程"></a>RACChannel 双向传输过程</h3><p>分析完 RACChannel 初始化过程之后，回到文章开头的例子</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RACChannelTo(viewModel, inputText) = textField.rac_newTextChannel;</span><br></pre></td></tr></table></figure><p>首先看宏 <code>RACChannelTo</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define RACChannelTo(TARGET, ...) \</span></span><br><span class="line">    metamacro_if_eq(<span class="number">1</span>, metamacro_argcount(__VA_ARGS__)) \</span><br><span class="line">        (RACChannelTo_(TARGET, __VA_ARGS__, <span class="literal">nil</span>)) \</span><br><span class="line">        (RACChannelTo_(TARGET, __VA_ARGS__))</span><br><span class="line"></span><br><span class="line"><span class="meta">#define RACChannelTo_(TARGET, KEYPATH, NILVALUE) \</span></span><br><span class="line">    [[RACKVOChannel alloc] initWithTarget:(TARGET) keyPath:@keypath(TARGET, KEYPATH) nilValue:(NILVALUE)][@keypath(RACKVOChannel.new, followingTerminal)]</span><br></pre></td></tr></table></figure><p>内部是调用了 RACKVOChannel 的方法 <code>-initWithTarget:keyPath:nilValue:</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RACKVOChannel alloc] initWithTarget:(TARGET) keyPath:@keypath(TARGET, KEYPATH) nilValue:(NILVALUE)][@keypath(RACKVOChannel.new, followingTerminal)]</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithTarget:(__<span class="keyword">weak</span> <span class="built_in">NSObject</span> *)target keyPath:(<span class="built_in">NSString</span> *)keyPath nilValue:(<span class="keyword">id</span>)nilValue &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(keyPath.rac_keyPathComponents.count &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSObject</span> *strongTarget = target;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_target = target;</span><br><span class="line">_keyPath = [keyPath <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (strongTarget == <span class="literal">nil</span>) &#123;</span><br><span class="line">[<span class="keyword">self</span>.leadingTerminal sendCompleted];</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RACDisposable *observationDisposable = [strongTarget rac_observeKeyPath:keyPath options:<span class="built_in">NSKeyValueObservingOptionInitial</span> observer:<span class="literal">nil</span> block:^(<span class="keyword">id</span> value, <span class="built_in">NSDictionary</span> *change, <span class="built_in">BOOL</span> causedByDealloc, <span class="built_in">BOOL</span> affectedOnlyLastComponent) &#123;</span><br><span class="line"><span class="keyword">if</span> (!causedByDealloc &amp;&amp; affectedOnlyLastComponent &amp;&amp; <span class="keyword">self</span>.currentThreadData.ignoreNextUpdate) &#123;</span><br><span class="line">[<span class="keyword">self</span> destroyCurrentThreadData];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.leadingTerminal sendNext:value];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[[<span class="keyword">self</span>.leadingTerminal</span><br><span class="line">finally:^&#123;</span><br><span class="line">[observationDisposable dispose];</span><br><span class="line">&#125;]</span><br><span class="line">subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="built_in">NSObject</span> *object = (keyPathComponentsCount &gt; <span class="number">1</span> ? [<span class="keyword">self</span>.target valueForKeyPath:keyPathByDeletingLastKeyPathComponent] : <span class="keyword">self</span>.target);</span><br><span class="line"><span class="keyword">if</span> (object == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">[object setValue:x ?: nilValue forKey:lastKeyPathComponent];</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"><span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"Received error in %@: %@"</span>, <span class="keyword">self</span>, error);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Received error in %@: %@"</span>, <span class="keyword">self</span>, error);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">@weakify(<span class="keyword">self</span>);</span><br><span class="line"></span><br><span class="line">[strongTarget.rac_deallocDisposable addDisposable:[RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">@strongify(<span class="keyword">self</span>);</span><br><span class="line">[<span class="keyword">self</span>.leadingTerminal sendCompleted];</span><br><span class="line"><span class="keyword">self</span>.target = <span class="literal">nil</span>;</span><br><span class="line">&#125;]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>省略部分代码，其主要流程：</p><ol><li>首先判断 taget 是否为空，如果是 nil 则 leadingTerminal 发送 sendCompleted，followingTerminal 的订阅者此时会收到 sendCompleted 事件。反之则执行步骤2</li><li>调用 KVO 监听到 target 对应 keyPath 变化的时候，leadingTerminal 发送 value，followingTerminal 订阅者会收到该 value</li><li>订阅 leadingTerminal 收到 value 之后利用 KVC 赋值到 target 对应的属性</li></ol><p><img src="/2019/04/01/ReactiveCocoa-RACChannel/RACKVOChannel.png" alt="image-20190402215557859"></p><p>初始化完 RACKVOChannel 之后，RACChannelTo 宏后半部分 <code>[@keypath(RACKVOChannel.new, followingTerminal)]</code> 直接上会调用其重载的函数 <code>-objectForKeyedSubscript:</code> 并返回 followingTerminal 对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (RACChannelTerminal *)objectForKeyedSubscript:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(key != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">RACChannelTerminal *terminal = [<span class="keyword">self</span> valueForKey:key];</span><br><span class="line"><span class="built_in">NSCAssert</span>([terminal isKindOfClass:RACChannelTerminal.class], <span class="string">@"Key \"%@\" does not identify a channel terminal"</span>, key);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> terminal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样例代码可以改变成</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[RACKVOChannel alloc] initWithTarget:viewModel keyPath:<span class="string">@"inputText"</span> nilValue:<span class="literal">nil</span>][<span class="string">@"followingTerminal"</span>] = [[RACKVOChannel alloc] initWithTarget:textField keyPath:<span class="string">@"text"</span> nilValue:<span class="literal">nil</span>][<span class="string">@"followingTerminal"</span>];</span><br></pre></td></tr></table></figure><p>这里进行 = 号进行复制，最终会执行重载方法 <code>- (void)setObject:forKeyedSubscript:</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setObject:(RACChannelTerminal *)otherTerminal forKeyedSubscript:(<span class="built_in">NSString</span> *)key &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(otherTerminal != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">RACChannelTerminal *selfTerminal = [<span class="keyword">self</span> objectForKeyedSubscript:key];</span><br><span class="line">[otherTerminal subscribe:selfTerminal];</span><br><span class="line">[[selfTerminal skip:<span class="number">1</span>] subscribe:otherTerminal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据样例代码分析，这里 selfTerminal 是 viewModel 侧的 followingTerminal，otherTerminal 则是 textField 侧的 followingTerminal；</p><p>otherTerminal 把订阅者设置为 selfTerminal，otherTerminal 执行 sendNext 的时候，selfTerminal 的订阅者会收到信号；</p><p>同理 selfTerminal 把订阅者设置为 otherTerminal，selfTerminal 执行 sendNext 的时候，otherTerminal 的订阅者会收到信号，但是只会收到 selfTerminal 第二个信号及其后续信号。</p><p><img src="/2019/04/01/ReactiveCocoa-RACChannel/RACKVOChannel2.png" alt="image-20190403111110637"></p><p>至此，RACChannel 双向通信大概过程分析已经完成</p><p>备注：</p><p> <code>- (void)setObject:forKeyedSubscript:</code> 和  <code>-objectForKeyedSubscript:</code> 相关资料可参考： <a href="https://nshipster.cn/object-subscripting/" target="_blank" rel="noopener">对象下标索引</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactiveCocoa </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactiveCocoa-RACScheduler底层实现分析</title>
      <link href="/2019/03/26/ReactiveCocoa-RACScheduler/"/>
      <url>/2019/03/26/ReactiveCocoa-RACScheduler/</url>
      
        <content type="html"><![CDATA[<p><code>RACScheduler</code> ReactiveCocoa 框架中的调度器，ReactiveCocoa 中的信号可以在 <code>RACScheduler</code> 上执行任务、发送结果； <code>RACScheduler</code> 的实现主要是基于 GCD 封装，提供了 GCD 不具备的特性。</p><a id="more"></a><p>RACScheduler 有 4 个子类:</p><ul><li><p>RACTestScheduler</p></li><li><p>RACSubscriptionScheduler</p></li><li><p>RACImmediateScheduler</p></li><li><p>RACQueueScheduler</p></li></ul><p>接下来会分析平时使用中常接触到的 RACImmediateScheduler、RACQueueScheduler 和 RACSubscriptionScheduler 3个子类</p><h2 id="RACScheduler"><a href="#RACScheduler" class="headerlink" title="RACScheduler"></a>RACScheduler</h2><p>基类提供了5个构造方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (RACScheduler *)schedulerWithPriority:(RACSchedulerPriority)priority name:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)name;</span><br><span class="line"></span><br><span class="line">+ (RACScheduler *)schedulerWithPriority:(RACSchedulerPriority)priority;</span><br><span class="line"></span><br><span class="line">+ (RACScheduler *)scheduler;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">nullable</span> RACScheduler *)currentScheduler;</span><br><span class="line"></span><br><span class="line">+ (RACScheduler *)immediateScheduler;</span><br><span class="line"></span><br><span class="line">+ (RACScheduler *)mainThreadScheduler;</span><br></pre></td></tr></table></figure><p><code>+schedulerWithPriority:name:</code>、<code>+schedulerWithPriority:</code>、<code>+scheduler</code> 三个方法细线逻辑相差不大</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (RACScheduler *)schedulerWithPriority:(RACSchedulerPriority)priority name:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACTargetQueueScheduler alloc] initWithName:name targetQueue:dispatch_get_global_queue(priority, <span class="number">0</span>)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (RACScheduler *)schedulerWithPriority:(RACSchedulerPriority)priority &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> schedulerWithPriority:priority name:<span class="string">@"org.reactivecocoa.ReactiveObjC.RACScheduler.backgroundScheduler"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (RACScheduler *)scheduler &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> schedulerWithPriority:RACSchedulerPriorityDefault];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>+schedulerWithPriority:name:</code>: 指定线程的优先级和名称，返回的 RACTargetQueueScheduler 对象，RACTargetQueueScheduler 是 RACQueueScheduler 的子类</li><li><code>+schedulerWithPriority:</code>: 指定线程的优先级，线程名称设置为 org.reactivecocoa.ReactiveObjC.RACScheduler.backgroundScheduler</li><li><code>+scheduler</code>: 线程的优先级设置为 RACSchedulerPriorityDefault，线程名称设置为 org.reactivecocoa.ReactiveObjC.RACScheduler.backgroundScheduler</li></ol><h3 id="currentScheduler："><a href="#currentScheduler：" class="headerlink" title="+currentScheduler："></a>+currentScheduler：</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+ (RACScheduler *)currentScheduler &#123;</span><br><span class="line">RACScheduler *scheduler = <span class="built_in">NSThread</span>.currentThread.threadDictionary[RACSchedulerCurrentSchedulerKey];</span><br><span class="line"><span class="keyword">if</span> (scheduler != <span class="literal">nil</span>) <span class="keyword">return</span> scheduler;</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.class isOnMainThread]) <span class="keyword">return</span> RACScheduler.mainThreadScheduler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isOnMainThread &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="built_in">NSOperationQueue</span>.currentQueue isEqual:<span class="built_in">NSOperationQueue</span>.mainQueue] || [<span class="built_in">NSThread</span> isMainThread];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是从当前线程的线程字典获取对应的 RACScheduler 对象，如果为 nil 则判断当前线程是否为主线程，如果是在主线程上，就返回 mainThreadScheduler。如果既不在主线程上，则返回 nil。</p><h3 id="immediateScheduler"><a href="#immediateScheduler" class="headerlink" title="+immediateScheduler:"></a>+immediateScheduler:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (RACScheduler *)immediateScheduler &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="keyword">static</span> RACScheduler *immediateScheduler;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">immediateScheduler = [[RACImmediateScheduler alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> immediateScheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一个单例方法，返回了 RACImmediateScheduler 对象</p><h3 id="mainThreadScheduler"><a href="#mainThreadScheduler" class="headerlink" title="+mainThreadScheduler"></a>+mainThreadScheduler</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (RACScheduler *)mainThreadScheduler &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="keyword">static</span> RACScheduler *mainThreadScheduler;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">mainThreadScheduler = [[RACTargetQueueScheduler alloc] initWithName:<span class="string">@"org.reactivecocoa.ReactiveObjC.RACScheduler.mainThreadScheduler"</span> targetQueue:dispatch_get_main_queue()];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> mainThreadScheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样是一个单例方法，返回的是 RACTargetQueueScheduler 对象，并将其名称赋值为 org.reactivecocoa.ReactiveObjC.RACScheduler.mainThreadScheduler</p><h3 id="subscriptionScheduler"><a href="#subscriptionScheduler" class="headerlink" title="+subscriptionScheduler"></a>+subscriptionScheduler</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (RACScheduler *)subscriptionScheduler &#123;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="keyword">static</span> RACScheduler *subscriptionScheduler;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">subscriptionScheduler = [[RACSubscriptionScheduler alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> subscriptionScheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是一个单例方法，返回了 RACSubscriptionScheduler 对象。</p><p>RACScheduler 还提供了5个实例方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> RACDisposable *)schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> RACDisposable *)after:(<span class="built_in">NSDate</span> *)date schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> RACDisposable *)afterDelay:(<span class="built_in">NSTimeInterval</span>)delay schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> RACDisposable *)after:(<span class="built_in">NSDate</span> *)date repeatingEvery:(<span class="built_in">NSTimeInterval</span>)interval withLeeway:(<span class="built_in">NSTimeInterval</span>)leeway schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> RACDisposable *)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock;</span><br></pre></td></tr></table></figure><ol><li><p><code>schedule:</code>: 传入 block 并根据相关条件来触发 block</p></li><li><p><code>after:schedule:</code>: 延迟执行 block，传入的延迟时间是 NSDate 类型</p></li><li><p><code>afterDelay:schedule:</code>: 延迟执行 block，传入的延迟时间是 NSTimeInterval 类型</p></li><li><p><code>after:repeatingEvery:withLeeway:schedule:</code>: 创建定时任务，循环间隔由参数 interval 决定</p></li><li><p><code>scheduleRecursiveBlock:</code>: 递归触发 block</p></li></ol><p>上面5个方法除了 <code>-scheduleRecursiveBlock:addingToDisposable:</code> 都是由子类进行具体实现</p><h3 id="scheduleRecursiveBlock-addingToDisposable"><a href="#scheduleRecursiveBlock-addingToDisposable" class="headerlink" title="-scheduleRecursiveBlock:addingToDisposable:"></a>-scheduleRecursiveBlock:addingToDisposable:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock addingToDisposable:(RACCompoundDisposable *)disposable &#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">RACCompoundDisposable *selfDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">[disposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">__<span class="keyword">weak</span> RACDisposable *weakSelfDisposable = selfDisposable;</span><br><span class="line"></span><br><span class="line">RACDisposable *schedulingDisposable = [<span class="keyword">self</span> schedule:^&#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="comment">// 已经触发之后，weakSelfDisposable 已经没有作用，故移除</span></span><br><span class="line">[disposable removeDisposable:weakSelfDisposable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (disposable.disposed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^reallyReschedule)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line"><span class="keyword">if</span> (disposable.disposed) <span class="keyword">return</span>;</span><br><span class="line">[<span class="keyword">self</span> scheduleRecursiveBlock:recursiveBlock addingToDisposable:disposable];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Protects the variables below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This doesn't actually need to be __block qualified, but Clang</span></span><br><span class="line"><span class="comment">// complains otherwise. :C</span></span><br><span class="line">__block <span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">lock.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %s"</span>, <span class="keyword">self</span>, sel_getName(_cmd)];</span><br><span class="line"></span><br><span class="line">__block <span class="built_in">NSUInteger</span> rescheduleCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 同步操作执行完后会赋值为YES，然后执行reallyReschedule闭包</span></span><br><span class="line">__block <span class="built_in">BOOL</span> rescheduleImmediately = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">recursiveBlock(^&#123;</span><br><span class="line">[lock lock];</span><br><span class="line"><span class="built_in">BOOL</span> immediate = rescheduleImmediately;</span><br><span class="line"><span class="keyword">if</span> (!immediate) ++rescheduleCount;</span><br><span class="line">[lock unlock];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (immediate) reallyReschedule();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[lock lock];</span><br><span class="line"><span class="built_in">NSUInteger</span> synchronousCount = rescheduleCount;</span><br><span class="line">rescheduleImmediately = <span class="literal">YES</span>;</span><br><span class="line">[lock unlock];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; synchronousCount; i++) &#123;</span><br><span class="line">reallyReschedule();</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[selfDisposable addDisposable:schedulingDisposable];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段函数实现中有几个关键的变量/参数：</p><ul><li>reallyReschedule：递归执行函数的闭包</li><li><p>recursiveBlock：函数传参，该闭包的参数也是一个闭包(block)，recursiveBlock 执行完之后会触发传入的闭包 block</p></li><li><p>rescheduleCount：递归的次数</p></li><li>rescheduleImmediately：是否立即执行递归闭包 reallyReschedule</li></ul><p>主要流程:</p><ol><li>初始化相关变量之后，执行 recursiveBlock ，第一次 rescheduleImmediately 为 NO，rescheduleCount 递增</li><li>recursiveBlock 执行完后 rescheduleImmediately 赋值为 YES</li><li>递归执行 reallyReschedule 闭包 rescheduleCount 次</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)performAsCurrentScheduler:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we're using a concurrent queue, we could end up in here concurrently,</span></span><br><span class="line"><span class="comment">// in which case we *don't* want to clear the current scheduler immediately</span></span><br><span class="line"><span class="comment">// after our block is done executing, but only *after* all our concurrent</span></span><br><span class="line"><span class="comment">// invocations are done.</span></span><br><span class="line"></span><br><span class="line">RACScheduler *previousScheduler = RACScheduler.currentScheduler;</span><br><span class="line"><span class="built_in">NSThread</span>.currentThread.threadDictionary[RACSchedulerCurrentSchedulerKey] = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">block();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (previousScheduler != <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="built_in">NSThread</span>.currentThread.threadDictionary[RACSchedulerCurrentSchedulerKey] = previousScheduler;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">[<span class="built_in">NSThread</span>.currentThread.threadDictionary removeObjectForKey:RACSchedulerCurrentSchedulerKey];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>执行 block 之前将当前线程的 scheduler 保存下来为 previousScheduler，然后设置自己为新的 scheduler</li><li>执行完 block 之后恢复现场，如果 previousScheduler 不为空，则重新复制为当前线程的 scheduler，否则从 threadDictionary 移除 RACSchedulerCurrentSchedulerKey 对应的对象，也就是当前 scheduler</li></ol><h2 id="RACImmediateScheduler"><a href="#RACImmediateScheduler" class="headerlink" title="RACImmediateScheduler"></a>RACImmediateScheduler</h2><p>RACImmediateScheduler 是一个私有类，主要特点是将加入的 block 立即(Immediate)进行调度</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">block();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)after:(<span class="built_in">NSDate</span> *)date schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(date != <span class="literal">nil</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">[<span class="built_in">NSThread</span> sleepUntilDate:date];</span><br><span class="line">block();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)after:(<span class="built_in">NSDate</span> *)date repeatingEvery:(<span class="built_in">NSTimeInterval</span>)interval withLeeway:(<span class="built_in">NSTimeInterval</span>)leeway schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"+[RACScheduler immediateScheduler] does not support %@."</span>, <span class="built_in">NSStringFromSelector</span>(_cmd));</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock &#123;</span><br><span class="line"><span class="keyword">for</span> (__block <span class="built_in">NSUInteger</span> remaining = <span class="number">1</span>; remaining &gt; <span class="number">0</span>; remaining--) &#123;</span><br><span class="line">recursiveBlock(^&#123;</span><br><span class="line">remaining++;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>-schedule</code> 方法会立即触发传入的 block；</li><li><code>-after:schedule:</code> 方法会将当前线程休眠到指定时间后执行 block；</li><li><code>-after:repeatingEvery:withLeeway:schedule:</code> 不支持</li><li><code>-scheduleRecursiveBlock:</code> 循环不断执行传入的 block</li></ul><h2 id="RACQueueScheduler"><a href="#RACQueueScheduler" class="headerlink" title="RACQueueScheduler"></a>RACQueueScheduler</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">RACDisposable *disposable = [[RACDisposable alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line"><span class="keyword">if</span> (disposable.disposed) <span class="keyword">return</span>;</span><br><span class="line">[<span class="keyword">self</span> performAsCurrentScheduler:block];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-schedule</code> 在 self.queue 队列中异步调用了 <code>-performAsCurrentScheduler</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)after:(<span class="built_in">NSDate</span> *)date schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(date != <span class="literal">nil</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">RACDisposable *disposable = [[RACDisposable alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_after([<span class="keyword">self</span>.class wallTimeWithDate:date], <span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line"><span class="keyword">if</span> (disposable.disposed) <span class="keyword">return</span>;</span><br><span class="line">[<span class="keyword">self</span> performAsCurrentScheduler:block];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (dispatch_time_t)wallTimeWithDate:(<span class="built_in">NSDate</span> *)date &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(date != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> seconds = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> frac = modf(date.timeIntervalSince1970, &amp;seconds);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> timespec walltime = &#123;</span><br><span class="line">.tv_sec = (time_t)fmin(fmax(seconds, LONG_MIN), LONG_MAX),</span><br><span class="line">.tv_nsec = (<span class="keyword">long</span>)fmin(fmax(frac * <span class="built_in">NSEC_PER_SEC</span>, LONG_MIN), LONG_MAX)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dispatch_walltime(&amp;walltime, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>调用 wallTimeWithDate 方法将 NSDate 转化成 dispatch_time_t</li><li>调用 dispatch_after 将 block 放进队列 self.queue 中延迟执行</li><li>block 执行过程中是通过 <code>-performAsCurrentScheduler:</code> 方法触发，触发前判断 disposable 是否被取消，取消则直接返回</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)after:(<span class="built_in">NSDate</span> *)date repeatingEvery:(<span class="built_in">NSTimeInterval</span>)interval withLeeway:(<span class="built_in">NSTimeInterval</span>)leeway schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(date != <span class="literal">nil</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(interval &gt; <span class="number">0.0</span> &amp;&amp; interval &lt; INT64_MAX / <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(leeway &gt;= <span class="number">0.0</span> &amp;&amp; leeway &lt; INT64_MAX / <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">uint64_t intervalInNanoSecs = (uint64_t)(interval * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line">uint64_t leewayInNanoSecs = (uint64_t)(leeway * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"></span><br><span class="line">dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.queue);</span><br><span class="line">dispatch_source_set_timer(timer, [<span class="keyword">self</span>.class wallTimeWithDate:date], intervalInNanoSecs, leewayInNanoSecs);</span><br><span class="line">dispatch_source_set_event_handler(timer, block);</span><br><span class="line">dispatch_resume(timer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">dispatch_source_cancel(timer);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是通过 GCD 创建定时任务，然后通过 dispatch_source_set_event_handler 把参数 block 和 计时器关联起来，任务被取消的时候取消对应的定时器</p><h2 id="RACTargetQueueScheduler"><a href="#RACTargetQueueScheduler" class="headerlink" title="RACTargetQueueScheduler"></a>RACTargetQueueScheduler</h2><p>RACTargetQueueScheduler 继承于 RACQueueScheduler，提供了一新的初始化方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithName:(<span class="built_in">NSString</span> *)name targetQueue:(<span class="built_in">dispatch_queue_t</span>)targetQueue &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(targetQueue != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (name == <span class="literal">nil</span>) &#123;</span><br><span class="line">name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"org.reactivecocoa.ReactiveObjC.RACTargetQueueScheduler(%s)"</span>, dispatch_queue_get_label(targetQueue)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(name.UTF8String, DISPATCH_QUEUE_SERIAL);</span><br><span class="line"><span class="keyword">if</span> (queue == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">dispatch_set_target_queue(queue, targetQueue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">super</span> initWithName:name queue:queue];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化方法创建了串行队列 queue，然后通过 dispatch_set_target_queue 把 targetQueue 和 queue 关联起来</p><p>dispatch_set_target_queue 有2个作用:</p><ol><li><p>初始化方法内 queue 是通过 dispatch_queue_create 创建，无法设置优先级，dispatch_set_target_queue 可以将 queue 优先级设置为 targetQueue 的优先级</p></li><li><p>设置队列的层次体系，可以理解为 queue 中的任务会派发给 targetQueue；比如如果 targetQueue 是 DISPATCH_QUEUE_SERIAL 串行队列，则 queue 中的任务也是串行执行；如果多个 queue 都指定同一个 targetQueue 串行队列，那么多个 queue 的任务是同步执行的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testSetTarget &#123;</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> targetQueue = dispatch_queue_create(<span class="string">"targetQueue"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">"queue1"</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue2 = dispatch_queue_create(<span class="string">"queue2"</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_set_target_queue(queue1, targetQueue);</span><br><span class="line">    dispatch_set_target_queue(queue2, targetQueue);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1. queue1 excute"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue1, ^&#123;</span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">1.</span>f];</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2. queue1 excute"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"1. queue2 excute"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(queue2, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"2. queue2 excute"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">dispatch_async</span>(targetQueue, ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"target queue"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-03-31 19:47:32.441322+0800 AppTest[42843:1630586] 1. queue1 excute</span><br><span class="line">2019-03-31 19:47:33.446694+0800 AppTest[42843:1630586] 2. queue1 excute</span><br><span class="line">2019-03-31 19:47:33.446917+0800 AppTest[42843:1630586] 1. queue2 excute</span><br><span class="line">2019-03-31 19:47:33.447003+0800 AppTest[42843:1630586] 2. queue2 excute</span><br><span class="line">2019-03-31 19:47:33.447095+0800 AppTest[42843:1630586] target queue</span><br></pre></td></tr></table></figure></li></ol><h2 id="RACSubscriptionScheduler"><a href="#RACSubscriptionScheduler" class="headerlink" title="RACSubscriptionScheduler"></a>RACSubscriptionScheduler</h2><p>相对于父类，主要添加了一个私有的属性:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACScheduler *backgroundScheduler;</span><br></pre></td></tr></table></figure><p>在其初始化的时候会创建 backgroundScheduler</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> initWithName:<span class="string">@"org.reactivecocoa.ReactiveObjC.RACScheduler.subscriptionScheduler"</span>];</span><br><span class="line"></span><br><span class="line">_backgroundScheduler = [RACScheduler scheduler];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RACScheduler.currentScheduler == <span class="literal">nil</span>) <span class="keyword">return</span> [<span class="keyword">self</span>.backgroundScheduler schedule:block];</span><br><span class="line"></span><br><span class="line">block();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)after:(<span class="built_in">NSDate</span> *)date schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">RACScheduler *scheduler = RACScheduler.currentScheduler ?: <span class="keyword">self</span>.backgroundScheduler;</span><br><span class="line"><span class="keyword">return</span> [scheduler after:date schedule:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)after:(<span class="built_in">NSDate</span> *)date repeatingEvery:(<span class="built_in">NSTimeInterval</span>)interval withLeeway:(<span class="built_in">NSTimeInterval</span>)leeway schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">RACScheduler *scheduler = RACScheduler.currentScheduler ?: <span class="keyword">self</span>.backgroundScheduler;</span><br><span class="line"><span class="keyword">return</span> [scheduler after:date repeatingEvery:interval withLeeway:leeway schedule:block];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他的方法大体逻辑都是判断当前线程有没有对应的 RACScheduler，如果有任务则在当前线程对应的 RACScheduler 执行，若没有则在 backgroundScheduler 上执行</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactiveCocoa </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactiveCocoa-RACCommand原理分析</title>
      <link href="/2019/03/23/ReactiveCocoa-RACCommand/"/>
      <url>/2019/03/23/ReactiveCocoa-RACCommand/</url>
      
        <content type="html"><![CDATA[<p>在项目中，经常会把用户操作动作和业务操作进行绑定，比如点击登录按钮会进行登录网络请求、点击下载图片等等。ReactiveCocoa 中提供捆绑副作用和信号的 RACCommand，开发者可以利用 RACCommand 来实现类似这种 动作-响应 绑定的功能。</p><a id="more"></a><h2 id="RACCommand-定义"><a href="#RACCommand-定义" class="headerlink" title="RACCommand 定义"></a>RACCommand 定义</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// RACCommand.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACCommand</span>&lt;<span class="title">__contravariant</span> <span class="title">InputType</span>, <span class="title">__covariant</span> <span class="title">ValueType</span>&gt; : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;RACSignal&lt;ValueType&gt; *&gt; *executionSignals;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;<span class="built_in">NSNumber</span> *&gt; *executing;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;<span class="built_in">NSNumber</span> *&gt; *enabled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal&lt;<span class="built_in">NSError</span> *&gt; *errors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (atomic, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> allowsConcurrentExecution;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSignalBlock:(RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input))signalBlock;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithEnabled:(<span class="keyword">nullable</span> RACSignal&lt;<span class="built_in">NSNumber</span> *&gt; *)enabledSignal signalBlock:(RACSignal&lt;ValueType&gt; * (^)(InputType _Nullable input))signalBlock;</span><br><span class="line"></span><br><span class="line">- (RACSignal&lt;ValueType&gt; *)execute:(<span class="keyword">nullable</span> InputType)input;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>头文件中，RACCommand 对外暴露了5个属性，作用分别是：</p><ol><li>executionSignals：高阶信号，当执行 <code>-execute:</code> 方法的时候，会创建新的信号，这个信号通过 executionSignals 发送出去</li><li>executing：发送的是布尔值，标志着 RACCommand 是否正在执行中，信号值是布尔值</li><li>enabled：标志 RACCommand 是否可以执行 <code>-execute:</code></li><li>errors：执行 <code>-execute:</code> 方法，过程中出现的 error 都由此发送</li><li>allowsConcurrentExecution：是否允许 RACCommand 并发执行，atomic 修饰，getter/setter方法是原子性的</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// RACCommand.m</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACCommand</span> () </span>&#123;</span><br><span class="line"><span class="comment">// Atomic backing variable for `allowsConcurrentExecution`.</span></span><br><span class="line"><span class="keyword">volatile</span> uint32_t _allowsConcurrentExecution;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A subject that sends added execution signals.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSubject *addedExecutionSignalsSubject;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A subject that sends the new value of `allowsConcurrentExecution` whenever it changes.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSubject *allowsConcurrentExecutionSubject;</span><br><span class="line"></span><br><span class="line"><span class="comment">// `enabled`, but without a hop to the main thread.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Values from this signal may arrive on any thread.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACSignal *immediateEnabled;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The signal block that the receiver was initialized with.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) RACSignal * (^signalBlock)(<span class="keyword">id</span> input);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>RACCommand 实现文件中定义了4个属性以及1个实例变量：</p><ol><li><p>_allowsConcurrentExecution：头文件属性 <code>allowsConcurrentExecution</code> 对应的实例变量，用 volatile 修饰，结合头文件属性的 atomic 关键子保证读写的原子性</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)allowsConcurrentExecution &#123;</span><br><span class="line"><span class="keyword">return</span> _allowsConcurrentExecution != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setAllowsConcurrentExecution:(<span class="built_in">BOOL</span>)allowed &#123;</span><br><span class="line"><span class="keyword">if</span> (allowed) &#123;</span><br><span class="line">OSAtomicOr32Barrier(<span class="number">1</span>, &amp;_allowsConcurrentExecution);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">OSAtomicAnd32Barrier(<span class="number">0</span>, &amp;_allowsConcurrentExecution);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.allowsConcurrentExecutionSubject sendNext:@(_allowsConcurrentExecution)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 setter 方法中，当 allowed == YES，采用 OSAtomicOr32Barrier 对 _allowsConcurrentExecution 和 1 做或运算；否则就执行 OSAtomicAnd32Barrier 和 0进行与运算；OSAtomicOr32Barrier/OSAtomicAnd32Barrier 都是原子运算</p></li><li><p>allowsConcurrentExecutionSubject：当 _allowsConcurrentExecution 被修改的时候会通过该信号给订阅发送修改后的 _allowsConcurrentExecution 值</p></li><li><p>addedExecutionSignalsSubject：执行 <code>-execute:</code> 方法的时候会创建一个新的 RACSignal 信号并将其通过 addedExecutionSignalsSubject 发送出去</p></li><li><p>immediateEnabled：判断 <code>-execute:</code> 方法创建的 RACSignal 是否能被订阅，immediateEnabled 会任意的线程给订阅者发送信号值</p></li><li><p>RACSignal * (^signalBlock)(id input)：执行 <code>-execute:</code> 方法的时候，会根据 signalBlock 创建RACSignal</p></li></ol><h2 id="RACCommand-初始化"><a href="#RACCommand-初始化" class="headerlink" title="RACCommand 初始化"></a>RACCommand 初始化</h2><p>RACCommand 提供了2个初始化方法：</p><ol><li><code>- (instancetype)initWithSignalBlock:(RACSignal&lt;id&gt; * (^)(id input))signalBlock</code></li><li><code>- (instancetype)initWithEnabled:(RACSignal *)enabledSignal signalBlock:(RACSignal&lt;id&gt; * (^)(id input))signalBlock</code></li></ol><p>第一个初始化方法是基于第二个进行封装，所以这里直接分析第二个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithEnabled:(RACSignal *)enabledSignal signalBlock:(RACSignal&lt;<span class="keyword">id</span>&gt; * (^)(<span class="keyword">id</span> input))signalBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(signalBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_addedExecutionSignalsSubject = [RACSubject new];</span><br><span class="line">_allowsConcurrentExecutionSubject = [RACSubject new];</span><br><span class="line">_signalBlock = [signalBlock <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">_executionSignals = [[[<span class="keyword">self</span>.addedExecutionSignalsSubject</span><br><span class="line">map:^(RACSignal *signal) &#123;</span><br><span class="line"><span class="keyword">return</span> [signal catchTo:[RACSignal empty]];</span><br><span class="line">&#125;]</span><br><span class="line">deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">setNameWithFormat:<span class="string">@"%@ -executionSignals"</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// `errors` needs to be multicasted so that it picks up all</span></span><br><span class="line"><span class="comment">// `activeExecutionSignals` that are added.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In other words, if someone subscribes to `errors` _after_ an execution</span></span><br><span class="line"><span class="comment">// has started, it should still receive any error from that execution.</span></span><br><span class="line">RACMulticastConnection *errorsConnection = [[[<span class="keyword">self</span>.addedExecutionSignalsSubject</span><br><span class="line">flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line"><span class="keyword">return</span> [[signal</span><br><span class="line">ignoreValues]</span><br><span class="line">catch:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"><span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:error];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;]</span><br><span class="line">deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">publish];</span><br><span class="line"></span><br><span class="line">_errors = [errorsConnection.signal setNameWithFormat:<span class="string">@"%@ -errors"</span>, <span class="keyword">self</span>];</span><br><span class="line">[errorsConnection connect];</span><br><span class="line"></span><br><span class="line">RACSignal *immediateExecuting = [[[[<span class="keyword">self</span>.addedExecutionSignalsSubject</span><br><span class="line">flattenMap:^(RACSignal *signal) &#123;</span><br><span class="line"><span class="keyword">return</span> [[[signal</span><br><span class="line">catchTo:[RACSignal empty]]</span><br><span class="line">then:^&#123;</span><br><span class="line"><span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:@<span class="number">-1</span>];</span><br><span class="line">&#125;]</span><br><span class="line">startWith:@<span class="number">1</span>];</span><br><span class="line">&#125;]</span><br><span class="line">scanWithStart:@<span class="number">0</span> reduce:^(<span class="built_in">NSNumber</span> *running, <span class="built_in">NSNumber</span> *next) &#123;</span><br><span class="line"><span class="keyword">return</span> @(running.integerValue + next.integerValue);</span><br><span class="line">&#125;]</span><br><span class="line">map:^(<span class="built_in">NSNumber</span> *count) &#123;</span><br><span class="line"><span class="keyword">return</span> @(count.integerValue &gt; <span class="number">0</span>);</span><br><span class="line">&#125;]</span><br><span class="line">startWith:@NO];</span><br><span class="line"></span><br><span class="line">_executing = [[[[[immediateExecuting</span><br><span class="line">deliverOn:RACScheduler.mainThreadScheduler]</span><br><span class="line"><span class="comment">// This is useful before the first value arrives on the main thread.</span></span><br><span class="line">startWith:@NO]</span><br><span class="line">distinctUntilChanged]</span><br><span class="line">replayLast]</span><br><span class="line">setNameWithFormat:<span class="string">@"%@ -executing"</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">RACSignal *moreExecutionsAllowed = [RACSignal</span><br><span class="line"><span class="keyword">if</span>:[<span class="keyword">self</span>.allowsConcurrentExecutionSubject startWith:@NO]</span><br><span class="line">then:[RACSignal <span class="keyword">return</span>:@YES]</span><br><span class="line"><span class="keyword">else</span>:[immediateExecuting not]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (enabledSignal == <span class="literal">nil</span>) &#123;</span><br><span class="line">enabledSignal = [RACSignal <span class="keyword">return</span>:@YES];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">enabledSignal = [enabledSignal startWith:@YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_immediateEnabled = [[[[RACSignal</span><br><span class="line">combineLatest:@[ enabledSignal, moreExecutionsAllowed ]]</span><br><span class="line">and]</span><br><span class="line">takeUntil:<span class="keyword">self</span>.rac_willDeallocSignal]</span><br><span class="line">replayLast];</span><br><span class="line"></span><br><span class="line">_enabled = [[[[[<span class="keyword">self</span>.immediateEnabled</span><br><span class="line">take:<span class="number">1</span>]</span><br><span class="line">concat:[[<span class="keyword">self</span>.immediateEnabled skip:<span class="number">1</span>] deliverOn:RACScheduler.mainThreadScheduler]]</span><br><span class="line">distinctUntilChanged]</span><br><span class="line">replayLast]</span><br><span class="line">setNameWithFormat:<span class="string">@"%@ -enabled"</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在初始化方法中对定义的属性进行初始化</p><h3 id="executionSignals"><a href="#executionSignals" class="headerlink" title="executionSignals"></a>executionSignals</h3><p>executionSignals 是通过对 addedExecutionSignalsSubject 信号值进行 map 操作，这里如果捕捉到 addedExecutionSignalsSubject 发送了 error 就转换成 RACEmptySignal 返回。executionSignals 所有信号都在主线程发送。</p><p>executionSignals 是高阶信号，当 _allowsConcurrentExecution == NO，可以通过 <code>-switchToLatest</code> 来进行降阶操作；反之需要用 <code>-flatten</code> 方法降阶 </p><h3 id="errors"><a href="#errors" class="headerlink" title="errors"></a>errors</h3><p>errors 信号也是对 addedExecutionSignalsSubject 进行转换后的新信号。</p><ol><li>对 addedExecutionSignalsSubject 进行 flattenMap 将 addedExecutionSignalsSubject 发送的信号进行  ignoreValues 处理，也就是忽略常规的信号</li><li>后面通过 <code>-catch:</code> 捕获 signal 发送的 NSError，包装成RACSignal</li><li>将所有信号都放在主线程发送给订阅者</li></ol><p>概括来说，errors 信号主要作用是把 RACCommand 执行过程中产出的 NSError 发送给订阅者</p><h3 id="immediateExecuting"><a href="#immediateExecuting" class="headerlink" title="immediateExecuting"></a>immediateExecuting</h3><ol><li>对 addedExecutionSignalsSubject 进行 <code>-flatten:</code> 操作，对其发送的信号进行 <code>-catchTo:</code> 操作，捕获到 error 会转化成 RACEmptySignal。</li><li>通过 <code>-then:</code> 方法将所有信号值再转化成 -1 发送出去。</li><li>步骤2发送序列之前在头部插入 1</li><li>对步骤3的序列进行迭代相加</li><li>判断步骤四的序列值是否大于0，返回 BOOL 值信号序列，并且头部插入 NO</li></ol><p>大概过程如图所示(_allowsConcurrentExecution == NO)：</p><p><img src="/2019/03/23/ReactiveCocoa-RACCommand/image-20190323202025627.png" alt="image-20190323202025627"></p><h3 id="executing"><a href="#executing" class="headerlink" title="executing"></a>executing</h3><p>该信号是通过封装 immediateExecuting 信号并将其在主线程发送，首先会在信号序列里插入 NO，然后当 immediateExecuting 信号值发生变化的时候会给订阅者发送信号值，并且每次被订阅都可以收到最新的一次信号值。</p><p>executing 表示 RACCommand 当前是否有正在执行的任务</p><h3 id="moreExecutionsAllowed"><a href="#moreExecutionsAllowed" class="headerlink" title="moreExecutionsAllowed"></a>moreExecutionsAllowed</h3><p>如果收到 allowsConcurrentExecutionSubject 信号值且为 YES，则会执行 <code>-then:</code> 给订阅者发送 YES，反之给订阅发送 immediateExecuting 最新信号值的取反结果</p><p>moreExecutionsAllowed 表示当前 RACCommand 是否允许并发执行多个任务</p><h3 id="immediateEnabled"><a href="#immediateEnabled" class="headerlink" title="immediateEnabled"></a>immediateEnabled</h3><p>immediateEnabled 发送的信号值是通过将参数 enabledSignal 和 moreExecutionsAllowed 这个2个信号的最新信号值做与运算后得到的结果</p><p><img src="/2019/03/23/ReactiveCocoa-RACCommand/image-20190323202159063.png" alt="image-20190323202159063"></p><h3 id="enabled"><a href="#enabled" class="headerlink" title="enabled"></a>enabled</h3><p>enabled 是通过封装 immediateEnabled 获取，与后者的主要区别是，enabled 会将除了第一个信号外的信号放在主线程发送。</p><h2 id="RACCommand-执行"><a href="#RACCommand-执行" class="headerlink" title="RACCommand 执行"></a>RACCommand 执行</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)execute:(<span class="keyword">id</span>)input &#123;</span><br><span class="line"><span class="comment">// `immediateEnabled` is guaranteed to send a value upon subscription, so</span></span><br><span class="line"><span class="comment">// -first is acceptable here.</span></span><br><span class="line"><span class="built_in">BOOL</span> enabled = [[<span class="keyword">self</span>.immediateEnabled first] boolValue];</span><br><span class="line"><span class="keyword">if</span> (!enabled) &#123;</span><br><span class="line"><span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:RACCommandErrorDomain code:RACCommandErrorNotEnabled userInfo:@&#123;</span><br><span class="line"><span class="built_in">NSLocalizedDescriptionKey</span>: <span class="built_in">NSLocalizedString</span>(<span class="string">@"The command is disabled and cannot be executed"</span>, <span class="literal">nil</span>),</span><br><span class="line">RACUnderlyingCommandErrorKey: <span class="keyword">self</span></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACSignal error:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RACSignal *signal = <span class="keyword">self</span>.signalBlock(input);</span><br><span class="line"><span class="built_in">NSCAssert</span>(signal != <span class="literal">nil</span>, <span class="string">@"nil signal returned from signal block for value: %@"</span>, input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// We subscribe to the signal on the main thread so that it occurs _after_</span></span><br><span class="line"><span class="comment">// -addActiveExecutionSignal: completes below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This means that `executing` and `enabled` will send updated values before</span></span><br><span class="line"><span class="comment">// the signal actually starts performing work.</span></span><br><span class="line">RACMulticastConnection *connection = [[signal</span><br><span class="line">subscribeOn:RACScheduler.mainThreadScheduler]</span><br><span class="line">multicast:[RACReplaySubject subject]];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.addedExecutionSignalsSubject sendNext:connection.signal];</span><br><span class="line"></span><br><span class="line">[connection connect];</span><br><span class="line"><span class="keyword">return</span> [connection.signal setNameWithFormat:<span class="string">@"%@ -execute: %@"</span>, <span class="keyword">self</span>, RACDescription(input)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>同步获取 immediateEnabled 信号的第一个值，判断是否当前是否可以执行任务，不能则返回 RACErrorSignal</p></li><li><p>通过初始化保存的 signalBlock 闭包创建 RACSignal 类型对象 signal，断言判断 signal 是否为空</p></li><li><p>signal 在主线程订阅并将其转化成热信号 (connection.signal)</p></li><li><p>connection.signal 被订阅之前通过 addedExecutionSignalsSubject 发送，更新 executing 和 enabled 信号</p></li><li><p>执行 <code>[connection connect]</code>，signal 被订阅，最后返回 connection.signal</p></li></ol><p><strong>备注：</strong> <code>-execute:</code> 方法和 executionSignals 信号都是返回最终信号 connection.signal；但是 executionSignals 是热信号，它最终信号被订阅之前发送，所以要通过 executionSignals 获取当前执行的最终信号，需要在 <code>-execute:</code> 执行之前进行订阅。</p><h2 id="RACCommand-对于系统类的扩展"><a href="#RACCommand-对于系统类的扩展" class="headerlink" title="RACCommand 对于系统类的扩展"></a>RACCommand 对于系统类的扩展</h2><h3 id="UIButton-RACCommandSupport"><a href="#UIButton-RACCommandSupport" class="headerlink" title="UIButton+RACCommandSupport"></a>UIButton+RACCommandSupport</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (RACCommand *)rac_command &#123;</span><br><span class="line"><span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="built_in">UIButtonRACCommandKey</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setRac_command:(RACCommand *)command &#123;</span><br><span class="line">objc_setAssociatedObject(<span class="keyword">self</span>, <span class="built_in">UIButtonRACCommandKey</span>, command, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for stored signal in order to remove it and add a new one</span></span><br><span class="line">RACDisposable *disposable = objc_getAssociatedObject(<span class="keyword">self</span>, <span class="built_in">UIButtonEnabledDisposableKey</span>);</span><br><span class="line">[disposable dispose];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (command == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">disposable = [command.enabled setKeyPath:@keypath(<span class="keyword">self</span>.enabled) onObject:<span class="keyword">self</span>];</span><br><span class="line">objc_setAssociatedObject(<span class="keyword">self</span>, <span class="built_in">UIButtonEnabledDisposableKey</span>, disposable, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> rac_hijackActionAndTargetIfNeeded];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)rac_hijackActionAndTargetIfNeeded &#123;</span><br><span class="line">SEL hijackSelector = <span class="keyword">@selector</span>(rac_commandPerformAction:);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSString</span> *selector <span class="keyword">in</span> [<span class="keyword">self</span> actionsForTarget:<span class="keyword">self</span> forControlEvent:<span class="built_in">UIControlEventTouchUpInside</span>]) &#123;</span><br><span class="line"><span class="keyword">if</span> (hijackSelector == <span class="built_in">NSSelectorFromString</span>(selector)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> addTarget:<span class="keyword">self</span> action:hijackSelector forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)rac_commandPerformAction:(<span class="keyword">id</span>)sender &#123;</span><br><span class="line">[<span class="keyword">self</span>.rac_command execute:sender];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>-setRac_command:</code> 通过对象关联把 RACCommand 和 RACDisposable 绑定到 UIButton 中，绑定新 RACDisposable 前会将旧的先进行 dispose，如果 command 为空直接返回</li><li>对 command 的 enabled 信号调用 <code>-setKeyPath:onObject:</code> 方法，把 UIButton 的 enable 属性和 enabled 信号进行绑定</li><li>执行 <code>rac_hijackActionAndTargetIfNeeded</code> ，检查是否有对应的 action 为 <code>rac_commandPerformAction</code>，若没有则设置 target 和 action 为 @selector(rac_commandPerformAction) 的点击事件。</li><li>按钮点击会触发 rac_command</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)setKeyPath:(<span class="built_in">NSString</span> *)keyPath onObject:(<span class="built_in">NSObject</span> *)object nilValue:(<span class="keyword">id</span>)nilValue &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(keyPath != <span class="literal">nil</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(object != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">keyPath = [keyPath <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Purposely not retaining 'object', since we want to tear down the binding</span></span><br><span class="line"><span class="comment">// when it deallocates normally.</span></span><br><span class="line">__block <span class="keyword">void</span> * <span class="keyword">volatile</span> objectPtr = (__bridge <span class="keyword">void</span> *)object;</span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="comment">// Possibly spec, possibly compiler bug, but this __bridge cast does not</span></span><br><span class="line"><span class="comment">// result in a retain here, effectively an invisible __unsafe_unretained</span></span><br><span class="line"><span class="comment">// qualifier. Using objc_precise_lifetime gives the __strong reference</span></span><br><span class="line"><span class="comment">// desired. The explicit use of __strong is strictly defensive.</span></span><br><span class="line">__<span class="keyword">strong</span> <span class="built_in">NSObject</span> *object __attribute__((objc_precise_lifetime)) = (__bridge __<span class="keyword">strong</span> <span class="keyword">id</span>)objectPtr;</span><br><span class="line">[object setValue:x ?: nilValue forKeyPath:keyPath];</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">__<span class="keyword">strong</span> <span class="built_in">NSObject</span> *object __attribute__((objc_precise_lifetime)) = (__bridge __<span class="keyword">strong</span> <span class="keyword">id</span>)objectPtr;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"Received error from %@ in binding for key path \"%@\" on %@: %@"</span>, <span class="keyword">self</span>, keyPath, object, error);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Log the error if we're running with assertions disabled.</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"Received error from %@ in binding for key path \"%@\" on %@: %@"</span>, <span class="keyword">self</span>, keyPath, object, error);</span><br><span class="line"></span><br><span class="line">[disposable dispose];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[disposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:subscriptionDisposable];</span><br><span class="line"></span><br><span class="line">RACDisposable *clearPointerDisposable = [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line"><span class="keyword">void</span> *ptr = objectPtr;</span><br><span class="line"><span class="keyword">if</span> (OSAtomicCompareAndSwapPtrBarrier(ptr, <span class="literal">NULL</span>, &amp;objectPtr)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:clearPointerDisposable];</span><br><span class="line"></span><br><span class="line">[object.rac_deallocDisposable addDisposable:disposable];</span><br><span class="line"></span><br><span class="line">RACCompoundDisposable *objectDisposable = object.rac_deallocDisposable;</span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[objectDisposable removeDisposable:disposable];</span><br><span class="line">[disposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>-setKeyPath:onObject:nilValue:</code> 主要作用是将 object 对应的 keypath 值和信号绑定到一起，主要有以下几个流程</p><ol><li><p>先订阅原信号，当收到原信号 sendNext 的时候，参数 object 根据 keypath 通过 KVO 赋值成对应的信号值。</p></li><li><p>当 object 被销毁的时候，会将 objectPtr 赋值为 NULL，取消步骤 1 的订阅</p></li><li><p>为了订阅的过程避免 object 被提前销毁，作者使用了 objc_precise_lifetime 修饰关键字来精确地控制 object 生命周期。注释中作者描述这可能是编译器的 bug：</p><p>即使显示使用 __strong 修饰 object，在这里也不会对 object 进行一次 retain，相反实际效果和 unsafe_unretain 相似。所以这里使用 objc_precise_lifetime 明确告诉编译器 object 不会在 didSubcribe 闭包中销毁</p></li></ol><h3 id="UIRefreshControl-RACCommandSupport"><a href="#UIRefreshControl-RACCommandSupport" class="headerlink" title="UIRefreshControl+RACCommandSupport"></a>UIRefreshControl+RACCommandSupport</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (RACCommand *)rac_command &#123;</span><br><span class="line"><span class="keyword">return</span> objc_getAssociatedObject(<span class="keyword">self</span>, <span class="built_in">UIRefreshControlRACCommandKey</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setRac_command:(RACCommand *)command &#123;</span><br><span class="line">objc_setAssociatedObject(<span class="keyword">self</span>, <span class="built_in">UIRefreshControlRACCommandKey</span>, command, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Dispose of any active command associations.</span></span><br><span class="line">[objc_getAssociatedObject(<span class="keyword">self</span>, <span class="built_in">UIRefreshControlDisposableKey</span>) dispose];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (command == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Like RAC(self, enabled) = command.enabled; but with access to disposable.</span></span><br><span class="line">RACDisposable *enabledDisposable = [command.enabled setKeyPath:@keypath(<span class="keyword">self</span>.enabled) onObject:<span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line">RACDisposable *executionDisposable = [[[[[<span class="keyword">self</span></span><br><span class="line">rac_signalForControlEvents:<span class="built_in">UIControlEventValueChanged</span>]</span><br><span class="line">map:^(<span class="built_in">UIRefreshControl</span> *x) &#123;</span><br><span class="line"><span class="keyword">return</span> [[[command</span><br><span class="line">execute:x]</span><br><span class="line">catchTo:[RACSignal empty]]</span><br><span class="line">then:^&#123;</span><br><span class="line"><span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:x];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] <span class="comment">// mapSignal</span></span><br><span class="line">concat]</span><br><span class="line">deliverOnMainThread]</span><br><span class="line">subscribeNext:^(<span class="built_in">UIRefreshControl</span> *x) &#123;</span><br><span class="line">[x endRefreshing];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACDisposable *commandDisposable = [RACCompoundDisposable compoundDisposableWithDisposables:@[ enabledDisposable, executionDisposable ]];</span><br><span class="line">objc_setAssociatedObject(<span class="keyword">self</span>, <span class="built_in">UIRefreshControlDisposableKey</span>, commandDisposable, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>同样也是通过关联属性的方法把 command 和 RACDisposable 关联到 UIRefreshControl 中，UIRefreshControl 的 enable 和 command.enable 绑定到一起</li><li>订阅 UIRefreshControl 控件 UIControlEventValueChanged 事件信号，并对其事件信号进行 map 处理(返回的暂且称为mapSignal)，在 block 中 将信号值 x 也就是 UIRefreshControl 对象自己，作为参数执行 command的 <code>-execute:</code> 方法，方法返回的 RACSignal 执行 <code>catchTo:</code> 忽略其中的 error，然后进行 then 来将 UIRefreshControl 包装成RACSignal 返回。</li><li>mapSignal 利用 concat 操作进行降阶，并把最终信号值放在主线程中发送。订阅最终信号，收到 sendNext 事件 UIRefreshControl 结束刷新</li></ol><p>参考文章：</p><p><a href="https://halfrost.com/reactivecocoa_raccommand/#2racsignalexecuting" target="_blank" rel="noopener">ReactiveCocoa 中 RACCommand 底层实现分析</a></p><p><a href="https://draveness.me/raccommand" target="_blank" rel="noopener">优雅的 RACCommand</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactiveCocoa </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReactiveCocoa的冷信号与热信号</title>
      <link href="/2019/03/12/ReactiveCocoa-cold-hot/"/>
      <url>/2019/03/12/ReactiveCocoa-cold-hot/</url>
      
        <content type="html"><![CDATA[<p>ReactiveX 中将信号分为冷信号和热信号，本文结合 ReactiveCocoa 分析其中的冷、热信号的异同。</p><a id="more"></a><h2 id="冷、热信号的区别"><a href="#冷、热信号的区别" class="headerlink" title="冷、热信号的区别"></a>冷、热信号的区别</h2><p>ReactiveX 文档中是这样描述冷、热信号的：</p><blockquote><p>When does an Observable begin emitting its sequence of items? It depends on the Observable. A “hot” Observable may begin emitting items as soon as it is created, and so any observer who later subscribes to that Observable may start observing the sequence somewhere in the middle. A “cold” Observable, on the other hand, waits until an observer subscribes to it before it begins to emit items, and so such an observer is guaranteed to see the whole sequence from the beginning.</p></blockquote><p>简单归纳两者主要区别：</p><ol><li>冷信号的发送是被动触发的，只有被订阅之后才会发送信号；热信号的发送是主动的，不受订阅动作的时间点影响</li><li>每次订阅冷信号，订阅者都会收到完整且相同的信号序列；订阅热信号，订阅者只会收到订阅动作时候发送的信号序列</li></ol><p>冷信号订阅示意图：</p><p><img src="/2019/03/12/ReactiveCocoa-cold-hot/cold.png" alt="Cold"></p><p>热信号订阅示意图：</p><p><img src="/2019/03/12/ReactiveCocoa-cold-hot/hot.png" alt="Hot"></p><h2 id="RACSubject"><a href="#RACSubject" class="headerlink" title="RACSubject"></a>RACSubject</h2><p>在 ReactiveCocoa 中， <code>RACSignal</code> 冷信号，当订阅者对其进行订阅后都会接受到；<code>RACSubject</code> 代表热信号，订阅者接收到多少值取决于它订阅的时间与 <code>RACSubject</code> 发送信号的时机。</p><p><code>RACSubject</code> 是继承于 <code>RACSignal</code>，同事它有3个子类分别是：</p><ol><li>RACReplaySubject</li><li>RACGroupedSignal</li><li>RACBehaviorSubject</li></ol><h3 id="RACSubject-底层实现"><a href="#RACSubject-底层实现" class="headerlink" title="RACSubject 底层实现"></a>RACSubject 底层实现</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(subscriber != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STEP 1</span></span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="keyword">self</span> disposable:disposable];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STEP 2</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *subscribers = <span class="keyword">self</span>.subscribers;</span><br><span class="line"><span class="keyword">@synchronized</span> (subscribers) &#123;</span><br><span class="line">[subscribers addObject:subscriber];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// STEP 3</span></span><br><span class="line">[disposable addDisposable:[RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (subscribers) &#123;</span><br><span class="line"><span class="comment">// Since newer subscribers are generally shorter-lived, search</span></span><br><span class="line"><span class="comment">// starting from the end of the list.</span></span><br><span class="line"><span class="built_in">NSUInteger</span> index = [subscribers indexOfObjectWithOptions:<span class="built_in">NSEnumerationReverse</span> passingTest:^ <span class="built_in">BOOL</span> (<span class="keyword">id</span>&lt;RACSubscriber&gt; obj, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">return</span> obj == subscriber;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index != <span class="built_in">NSNotFound</span>) [subscribers removeObjectAtIndex:index];</span><br><span class="line">&#125;</span><br><span class="line">&#125;]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACSubject 重写了父类的 <code>-subscribe:</code> 方法：</p><ol><li>利用 RACPassthroughSubscriber 将原始订阅者 subscriber 和自身的 disposable 关联，包装成新的 subscriber，当原始订阅者订阅取消之后会触发 disposable 的 dispose 动作</li><li>将所有 subscriber 存在可变数组 subscribers 中</li><li>创建一个 <code>RACDisposable</code> 对象加入到步骤1中创建的 disposable ，在当前 <code>subscriber</code> 销毁时，disposable 会触发 dispose 动作，然后把对应的 subscriber 从数组中移除</li></ol><p>RACSubject 能够发送信号是因为其实现了 <code>RACSubscriber</code> 协议：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">[<span class="keyword">self</span> enumerateSubscribersUsingBlock:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendNext:value];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">[<span class="keyword">self</span>.disposable dispose];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> enumerateSubscribersUsingBlock:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendCompleted &#123;</span><br><span class="line">[<span class="keyword">self</span>.disposable dispose];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> enumerateSubscribersUsingBlock:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sendNext/sendError/sendCompleted 都会对数组 subscribers 进行遍历，然后将信号事件透传给订阅者</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)enumerateSubscribersUsingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))block &#123;</span><br><span class="line"><span class="built_in">NSArray</span> *subscribers;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>.subscribers) &#123;</span><br><span class="line">subscribers = [<span class="keyword">self</span>.subscribers <span class="keyword">copy</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber <span class="keyword">in</span> subscribers) &#123;</span><br><span class="line">block(subscriber);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-enumerateSubscribersUsingBlock:</code> 中是通过 @synchronized 包装数据的线程安全</p><h2 id="RACBehaviorSubject"><a href="#RACBehaviorSubject" class="headerlink" title="RACBehaviorSubject"></a>RACBehaviorSubject</h2><p>RACBehaviorSubject 每次被订阅的时候会向订阅者发送最新的信号</p><p>初始化的时候，可以设置第一个最新信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)behaviorSubjectWithDefaultValue:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">RACBehaviorSubject *subject = [<span class="keyword">self</span> subject];</span><br><span class="line">subject.currentValue = value;</span><br><span class="line"><span class="keyword">return</span> subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>currentValue 属性保存着最新的信号值</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">RACDisposable *subscriptionDisposable = [<span class="keyword">super</span> subscribe:subscriber];</span><br><span class="line"></span><br><span class="line">RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">[subscriber sendNext:<span class="keyword">self</span>.currentValue];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line">[schedulingDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 RACBehaviorSubject 被订阅的时候，先执行了父类的方法，然后给订阅者发送 currentValue</p><p><img src="/2019/03/12/ReactiveCocoa-cold-hot/RACBehaviorSubject.png" alt="RACBehaviorSubject"></p><h2 id="RACReplaySubject"><a href="#RACReplaySubject" class="headerlink" title="RACReplaySubject"></a>RACReplaySubject</h2><p>RACReplaySubject 可以看做是 RACBehaviorSubject 的升级版，不过细节上略有差别</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACReplaySubject</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>, <span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span> capacity;</span><br><span class="line"></span><br><span class="line"><span class="comment">// These properties should only be modified while synchronized on self.</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="built_in">NSMutableArray</span> *valuesReceived;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> hasCompleted;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> hasError;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><ul><li>capacity: 确定保存最近发送过的信号值个数</li><li>valuesReceived: 保存最近发送过的信号值</li><li>hasCompleted: 是否发送过 sendCompleted</li><li>hasError: 是否发送过 sendError</li><li>error: 保存之前发送的 NSError</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">[<span class="keyword">self</span>.valuesReceived addObject:value ?: RACTupleNil.tupleNil];</span><br><span class="line">[<span class="keyword">super</span> sendNext:value];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.capacity != RACReplaySubjectUnlimitedCapacity &amp;&amp; <span class="keyword">self</span>.valuesReceived.count &gt; <span class="keyword">self</span>.capacity) &#123;</span><br><span class="line">[<span class="keyword">self</span>.valuesReceived removeObjectsInRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="keyword">self</span>.valuesReceived.count - <span class="keyword">self</span>.capacity)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送信号值，先用 @synchronized 进行加锁，然后把信号值 value 保存在 valuesReceived 数组中，如果 value == nil，则用 RACTupleNil.tupleNil 替代并加入到数组中。</p><p>当 capacity 不等于 RACReplaySubjectUnlimitedCapacity，数组长度大于 capacity 的时候，会弹出数组中前几个元素，类似栈结构的 pop 动作</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line">RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> value <span class="keyword">in</span> <span class="keyword">self</span>.valuesReceived) &#123;</span><br><span class="line"><span class="keyword">if</span> (compoundDisposable.disposed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">[subscriber sendNext:(value == RACTupleNil.tupleNil ? <span class="literal">nil</span> : value)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (compoundDisposable.disposed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.hasCompleted) &#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.hasError) &#123;</span><br><span class="line">[subscriber sendError:<span class="keyword">self</span>.error];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">RACDisposable *subscriptionDisposable = [<span class="keyword">super</span> subscribe:subscriber];</span><br><span class="line">[compoundDisposable addDisposable:subscriptionDisposable];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[compoundDisposable addDisposable:schedulingDisposable];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> compoundDisposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>订阅的逻辑大体上和 RACBehaviorSubject 相似，每次订阅的时候，同样通过 @synchronized 加锁，然后将数组的所有元素逐一发送给订阅者，如果之前发送过 sendCompleted/sendError，则给订阅者发送对应的sendCompleted/sendError</p><p>需要注意的是，不指定 RACReplaySubject 的 capacity，订阅者订阅之后都会获取到完整的信号序列（类似订阅冷信号）</p><p><img src="/2019/03/12/ReactiveCocoa-cold-hot/RACReplaySubject.png" alt="RACReplaySubject"></p><h2 id="RACGroupedSignal"><a href="#RACGroupedSignal" class="headerlink" title="RACGroupedSignal"></a>RACGroupedSignal</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACGroupedSignal</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt; key;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RACGroupedSignal</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark API</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)signalWithKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)key &#123;</span><br><span class="line">RACGroupedSignal *subject = [<span class="keyword">self</span> subject];</span><br><span class="line">subject.key = key;</span><br><span class="line"><span class="keyword">return</span> subject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACGroupedSignal 相对于 RACSubject 对存储了一个 key 值</p><p>在 RACSignal 的 <code>groupBy:transform:</code> 方法中使用了 RACGroupedSignal，具体细节参考<a href="https://chipengliu.github.io/2019/02/23/RACSignal-Operations-3/">文章</a></p><h2 id="冷信号转换成热信号"><a href="#冷信号转换成热信号" class="headerlink" title="冷信号转换成热信号"></a>冷信号转换成热信号</h2><p>冷信号和热信号本质区别在于是否保持状态，冷信号本身不保持多次订阅发送信号过程的状态，所以每次订阅冷信号就会收到完整的信号序列；相反热信号维持多次订阅的状态，订阅者订阅热信号只会收到订阅动作之后发送的信号值。</p><p>基于上面的区别，很容易会想到一种方法将 ReactiveCocoa 中的冷信号（RACSignal）转化成热信号：订阅冷信号，将收到的信号值通过 RACSubject 转发，订阅者通过订阅 RACSubject 来获取热信号</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *coldSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">1.5</span> schedule:^&#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSubject *subject = [RACSubject subject];</span><br><span class="line">[coldSignal subscribe:subject];</span><br><span class="line"></span><br><span class="line">[subject subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = 1</span><br><span class="line">value = 2</span><br></pre></td></tr></table></figure><p>这个方法存在一个问题：如果 <code>subject</code> 的订阅者提前终止了订阅，而 <code>subject</code> 并不能终止对 <code>coldSignal</code> 的订阅。</p><p>ReactiveCocoa 框架中提供了一下几个方法将冷信号转化成热信号:</p><ol><li><code>- (RACMulticastConnection&lt;ValueType&gt; *)multicast:(RACSubject&lt;ValueType&gt; *)subject</code></li><li><code>- (RACMulticastConnection *)publish</code></li><li><code>- (RACSignal&lt;ValueType&gt; *)replay</code></li><li><code>- (RACSignal&lt;ValueType&gt; *)replayLast</code></li><li><code>- (RACSignal&lt;ValueType&gt; *)replayLazily</code></li></ol><p>其中 <code>- (RACMulticastConnection&lt;ValueType&gt; *)multicast:(RACSubject&lt;ValueType&gt; *)subject</code> 是另外几个方法的实现基础，所以先分析次方法的实现</p><h3 id="multicast"><a href="#multicast" class="headerlink" title="multicast:"></a>multicast:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (RACMulticastConnection *)multicast:(RACSubject *)subject &#123;</span><br><span class="line">[subject setNameWithFormat:<span class="string">@"[%@] -multicast: %@"</span>, <span class="keyword">self</span>.name, subject.name];</span><br><span class="line">RACMulticastConnection *connection = [[RACMulticastConnection alloc] initWithSourceSignal:<span class="keyword">self</span> subject:subject];</span><br><span class="line"><span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-multicast:</code> 是通过初始化一个 RACMulticastConnection 对象实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// RACMulticastConnection.m</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSourceSignal:(RACSignal *)source subject:(RACSubject *)subject &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(source != <span class="literal">nil</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(subject != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_sourceSignal = source;</span><br><span class="line">_serialDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">_signal = subject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#pragma mark Connecting</span></span><br><span class="line"></span><br><span class="line">- (RACDisposable *)connect &#123;</span><br><span class="line"><span class="built_in">BOOL</span> shouldConnect = OSAtomicCompareAndSwap32Barrier(<span class="number">0</span>, <span class="number">1</span>, &amp;_hasConnected);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shouldConnect) &#123;</span><br><span class="line"><span class="keyword">self</span>.serialDisposable.disposable = [<span class="keyword">self</span>.sourceSignal subscribe:_signal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.serialDisposable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACSignal *)autoconnect &#123;</span><br><span class="line">__block <span class="keyword">volatile</span> int32_t subscriberCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[RACSignal</span><br><span class="line">createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">OSAtomicIncrement32Barrier(&amp;subscriberCount);</span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [<span class="keyword">self</span>.signal subscribe:subscriber];</span><br><span class="line">RACDisposable *connectionDisposable = [<span class="keyword">self</span> connect];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (OSAtomicDecrement32Barrier(&amp;subscriberCount) == <span class="number">0</span>) &#123;</span><br><span class="line">[connectionDisposable dispose];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line">&#125;]</span><br><span class="line">setNameWithFormat:<span class="string">@"[%@] -autoconnect"</span>, <span class="keyword">self</span>.signal.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>RACMulticastConnection 初始化的时候将原信号（冷信号）保存在为属性 sourceSignal，signal 属性保存着传入的 RACSubject。serialDisposable 用于需要订阅的清理操作</li><li>RACMulticastConnection 提供2个方法进行信号转换，首先是 <code>-connect</code>，改方法中先通过实例变量 hasConnected 判断是否已经执行过 <code>-connect</code>，值得注意的是这里是通过原子性运算 <code>OSAtomicCompareAndSwap32Barrier</code> 来进行判断，如果 hasConnected == 0，则返回 YES，然后将 hasConnected 赋值为 1。如果之前没有执行过，就以 _signal（RACSubject） 作为订阅者对原信号进行订阅</li><li>connect 之后 RACMulticastConnection 对象的 _signal 也就是一个热信号，对外部来说 <code>signal</code> 是一个只读属性</li><li>如果要确保热信号 signal 的第一次订阅能收到 <code>sourceSignal</code> 的完整信号序列，可以调用另一个转换方法 <code>-autoConnect</code>。改函数中通过创建返回一个新的 RACSignal，当其被订阅首先会先订阅 <code>signal</code> 属性，然后再执行 <code>-connect</code>，因此第一次对 <code>signal</code> 进行订阅的时候，会收到  <code>sourceSignal</code> 的所有信号值</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testConnection &#123;</span><br><span class="line">    RACSignal *coldSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">3</span> schedule:^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">5</span> schedule:^&#123;</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSubject *subject = [RACSubject subject];    </span><br><span class="line">    RACMulticastConnection *multicastConnection = [coldSignal multicast:subject];</span><br><span class="line">    RACSignal *hotSignal = multicastConnection.signal;</span><br><span class="line">    </span><br><span class="line">    [hotSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Subscribe 1 recieve value:%@."</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [multicastConnection connect];</span><br><span class="line">    </span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">2</span> schedule:^&#123;</span><br><span class="line">        [hotSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Subscribe 2 recieve value:%@."</span>, x);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Subscribe 1 recieve value:1.</span><br><span class="line">Subscribe 1 recieve value:2.</span><br><span class="line">Subscribe 2 recieve value:2.</span><br></pre></td></tr></table></figure><p>通过输出结果可以看得出来，multicastConnection.signal 是一个热信号，订阅者只收到订阅动作之后发送的信号值。</p><p>同样可以通过 <code>-autoConnect</code> 实现一样的效果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testAutoConnection &#123;</span><br><span class="line">    RACSignal *coldSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">3</span> schedule:^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        &#125;];</span><br><span class="line">        </span><br><span class="line">        [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">5</span> schedule:^&#123;</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSubject *subject = [RACSubject subject];</span><br><span class="line">    RACMulticastConnection *multicastConnection = [coldSignal multicast:subject];</span><br><span class="line">    RACSignal *hotSignal = multicastConnection.autoconnect;</span><br><span class="line">    </span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">2</span> schedule:^&#123;</span><br><span class="line">        [hotSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Subscribe 1 recieve value:%@."</span>, x);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[RACScheduler mainThreadScheduler] afterDelay:<span class="number">2</span> schedule:^&#123;</span><br><span class="line">        [hotSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"Subscribe 2 recieve value:%@."</span>, x);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (RACMulticastConnection *)publish &#123;</span><br><span class="line">RACSubject *subject = [[RACSubject subject] setNameWithFormat:<span class="string">@"[%@] -publish"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">RACMulticastConnection *connection = [<span class="keyword">self</span> multicast:subject];</span><br><span class="line"><span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-publish</code> 本质上就是调用了 <code>-multicast</code> 并返回了对应的 RACMulticastConnection 对象</p><h3 id="replay"><a href="#replay" class="headerlink" title="replay"></a>replay</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)replay &#123;</span><br><span class="line">RACReplaySubject *subject = [[RACReplaySubject subject] setNameWithFormat:<span class="string">@"[%@] -replay"</span>, <span class="keyword">self</span>.name];</span><br><span class="line"></span><br><span class="line">RACMulticastConnection *connection = [<span class="keyword">self</span> multicast:subject];</span><br><span class="line">[connection connect];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> connection.signal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-replay</code> 是用 RACReplaySubject 替代 RACSubject，并且还执行了 <code>-connect</code> 方法，订阅者订阅热信号之后会收到最后发送的信号值序列</p><h3 id="replayLast"><a href="#replayLast" class="headerlink" title="replayLast"></a>replayLast</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)replayLast &#123;</span><br><span class="line">RACReplaySubject *subject = [[RACReplaySubject replaySubjectWithCapacity:<span class="number">1</span>] setNameWithFormat:<span class="string">@"[%@] -replayLast"</span>, <span class="keyword">self</span>.name];</span><br><span class="line"></span><br><span class="line">RACMulticastConnection *connection = [<span class="keyword">self</span> multicast:subject];</span><br><span class="line">[connection connect];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> connection.signal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-replayLast</code> 在 <code>-replay</code> 基础上用把 RACReplaySubject 的 capacity 赋值为1，订阅者订阅热信号之后之前发送过最新的一个信号值</p><h3 id="replayLazily"><a href="#replayLazily" class="headerlink" title="replayLazily"></a>replayLazily</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)replayLazily &#123;</span><br><span class="line">RACMulticastConnection *connection = [<span class="keyword">self</span> multicast:[RACReplaySubject subject]];</span><br><span class="line"><span class="keyword">return</span> [[RACSignal</span><br><span class="line">defer:^&#123;</span><br><span class="line">[connection connect];</span><br><span class="line"><span class="keyword">return</span> connection.signal;</span><br><span class="line">&#125;]</span><br><span class="line">setNameWithFormat:<span class="string">@"[%@] -replayLazily"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-replayLazily</code> 返回的信号只有被订阅的时候才会进行 connect 操作，也就是这时候才去订阅 sourceSignal，效果跟直接订阅冷信号相似</p><h2 id="为什么需要热信号"><a href="#为什么需要热信号" class="headerlink" title="为什么需要热信号"></a>为什么需要热信号</h2><p>先来看一个例子</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testSideEffect &#123;</span><br><span class="line">    AFHTTPSessionManager *mgr = [AFHTTPSessionManager manager];</span><br><span class="line">    mgr.requestSerializer = [AFJSONRequestSerializer serializer];</span><br><span class="line">    mgr.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSString</span> *url = <span class="string">@"https://apis.map.qq.com/ws/place/v1/search"</span>;</span><br><span class="line">    <span class="built_in">NSDictionary</span> *params = @&#123;</span><br><span class="line">                             <span class="string">@"boundary"</span>:<span class="string">@"nearby(22.54046907,113.93455082,1000)"</span>,</span><br><span class="line">                             <span class="string">@"key"</span>:<span class="string">@"XXXXX-XXXXX-XXXXX-XXXXX-XXXXX-XXXXX"</span>,</span><br><span class="line">                             <span class="string">@"keyword"</span>:<span class="string">@"深大"</span>,</span><br><span class="line">                             <span class="string">@"page_index"</span>:@<span class="number">1</span>,</span><br><span class="line">                             <span class="string">@"page_size"</span>:@<span class="number">10</span>,</span><br><span class="line">                             &#125;;</span><br><span class="line">    </span><br><span class="line">    RACSignal *fetchWebservice = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"fetch begin"</span>);</span><br><span class="line">        <span class="built_in">NSURLSessionDataTask</span> *task = [mgr GET:url parameters:params progress:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"fetch success"</span>);</span><br><span class="line">            [subscriber sendNext:responseObject];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"fetch error"</span>);</span><br><span class="line">            [subscriber sendError:error];</span><br><span class="line">        &#125;];</span><br><span class="line">        <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            <span class="keyword">if</span> (task.state != <span class="built_in">NSURLSessionTaskStateCompleted</span>) &#123;</span><br><span class="line">                [task cancel];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *requestId = [fetchWebservice flattenMap:^__kindof RACSignal * _Nullable(<span class="built_in">NSDictionary</span> *responseObject) &#123;</span><br><span class="line">        <span class="keyword">id</span> requestId = responseObject[<span class="string">@"request_id"</span>];</span><br><span class="line">        <span class="keyword">if</span> ([requestId isKindOfClass:<span class="built_in">NSString</span>.class]) &#123;</span><br><span class="line">            <span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:requestId];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [RACSignal error:[<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"error"</span> code:<span class="number">400</span> userInfo:@&#123;<span class="string">@"responseObject"</span>: responseObject&#125;]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *count = [fetchWebservice flattenMap:^__kindof RACSignal * _Nullable(<span class="built_in">NSDictionary</span> *responseObject) &#123;</span><br><span class="line">        <span class="keyword">id</span> count = responseObject[<span class="string">@"count"</span>];</span><br><span class="line">        <span class="keyword">if</span> ([count isKindOfClass:<span class="built_in">NSNumber</span>.class]) &#123;</span><br><span class="line">            <span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:count];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> [RACSignal error:[<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"error"</span> code:<span class="number">400</span> userInfo:@&#123;<span class="string">@"responseObject"</span>: responseObject&#125;]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *requestIdCatchSig = [[requestId catchTo:[RACSignal <span class="keyword">return</span>:<span class="string">@"Error"</span>]]  startWith:<span class="string">@"Loading..."</span>];</span><br><span class="line">    [requestIdCatchSig setName:<span class="string">@"requestIdCatchSig"</span>];</span><br><span class="line">    RAC(<span class="keyword">self</span>, requestId) = requestIdCatchSig;</span><br><span class="line">    </span><br><span class="line">    RACSignal *countSig = [[count catchTo:[RACSignal <span class="keyword">return</span>:<span class="string">@"Error"</span>]] startWith:<span class="string">@"Loading..."</span>];</span><br><span class="line">    [countSig setName:<span class="string">@"countCatchSig"</span>];</span><br><span class="line">    RAC(<span class="keyword">self</span>, countStr) = countSig;</span><br><span class="line">    </span><br><span class="line">    [[RACSignal merge:@[requestId, count]] subscribeError:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">UIAlertView</span> *alertView = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"Error"</span> message:error.domain delegate:<span class="literal">nil</span> cancelButtonTitle:<span class="string">@"OK"</span> otherButtonTitles:<span class="literal">nil</span>];</span><br><span class="line">        [alertView show];</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们经常会遇到请求数据，然后再把数据处理解析返回需要的具体返回，但是以上代码会触发4次的网络请求，在打印的日志可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch begin</span><br><span class="line">fetch begin</span><br><span class="line">fetch begin</span><br><span class="line">fetch begin</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>之前分析 RACSignal 常用方法的时候，发现 ReactiveCocoa 中信号常用的方法是先订阅原信号，然后返回新的 RACSignal，而 RACSignal 被订阅的时候会马上执行一次初始化保存的 didSubscribe 闭包。</p><p>首先这里用宏把信号和属性进行绑定 <code>RAC(self, requestId) = requestIdCatchSig</code>，宏 <code>RAC</code> 内部会初始化 RACSubscriptingAssignmentTrampoline </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#define RAC(TARGET, ...) \</span></span><br><span class="line">    metamacro_if_eq(<span class="number">1</span>, metamacro_argcount(__VA_ARGS__)) \</span><br><span class="line">        (RAC_(TARGET, __VA_ARGS__, <span class="literal">nil</span>)) \</span><br><span class="line">        (RAC_(TARGET, __VA_ARGS__))</span><br><span class="line"></span><br><span class="line"><span class="meta">#define RAC_(TARGET, KEYPATH, NILVALUE) \</span></span><br><span class="line">    [[RACSubscriptingAssignmentTrampoline alloc] initWithTarget:(TARGET) nilValue:(NILVALUE)][@keypath(TARGET, KEYPATH)]</span><br></pre></td></tr></table></figure><p>内部会对 requestIdCatchSig 进行订阅，requestIdCatchSig 被订阅的时候 requestId 也会被订阅一次，requestId 是 fetchWebservice 通过 <code>-flatten:</code> 方法转换，最后 fetchWebservice 也因此被订阅，触发了一次网络请求</p><p>同理 <code>RAC(self, countStr) = countSig;</code> 也会触发一次网络请求，到此会引起2次网络请求。</p><p>很容易看出剩余的2次是因为 <code>+merge:</code> 方法导致，在改方法中内部会将传入的 requestId，count 都会进行一次 flattenMap 操作，导致 fetchWebservice 被订阅2次。</p><p>可以看出，在 ReactiveCocoa 中信号转换即是对原有的信号进行订阅从而产生新的信号，而冷信号 RACSignal 每次被订阅都会执行一次订阅时间，产生了<a href="https://en.wikipedia.org/wiki/Side_effect_%28computer_science%29" target="_blank" rel="noopener">副作用</a></p><p>改进：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RACMulticastConnection *connection = [fetchWebservice publish];</span><br><span class="line">RACSignal *hotFetchWebservice = connection.signal;</span><br><span class="line">[connection connect];</span><br></pre></td></tr></table></figure><p>这时候我们利用热信号的特性，将 fetchWebservice 转化成功对应的热信号 hotFetchWebservice，后面的处理都以 hotFetchWebservice 原信号进行转换就能避免冷信号转化过程中产生的副作用。</p><p>参考文章：</p><ol><li><a href="http://reactivex.io/documentation/observable.html" target="_blank" rel="noopener">ReactiveX文档</a></li><li><a href="https://draveness.me/racsubject" target="_blank" rel="noopener">『可变』的热信号 RACSubject</a></li><li><a href="https://tech.meituan.com/2015/11/03/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-3.html" target="_blank" rel="noopener">细说ReactiveCocoa的冷信号与热信号（三）：怎么处理冷信号与热信号</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactiveCocoa </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RACSignal常用方法深入分析(终)</title>
      <link href="/2019/03/04/RACSignal-Operations-4/"/>
      <url>/2019/03/04/RACSignal-Operations-4/</url>
      
        <content type="html"><![CDATA[<p>本篇文章接着<a href="https://chipengliu.github.io/2019/01/20/RACSignal-Operations-3/">上篇</a>继续分析常用的 RACSignal 方法的第四部分进行分析。</p><a id="more"></a><h3 id="switchToLatest"><a href="#switchToLatest" class="headerlink" title="switchToLatest"></a>switchToLatest</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testSwitchToLast &#123;</span><br><span class="line">    RACSignal *signal0 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">            [subscriber sendNext:@<span class="number">5</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">6</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:signal0];</span><br><span class="line">        [subscriber sendNext:signal1];</span><br><span class="line">        [subscriber sendNext:signal2];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[sourceSignal switchToLatest] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value = 0</span><br><span class="line">value = 1</span><br><span class="line">value = 3</span><br><span class="line">value = 6</span><br></pre></td></tr></table></figure><p>底层实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)switchToLatest &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACMulticastConnection *connection = [<span class="keyword">self</span> publish];</span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [[connection.signal</span><br><span class="line">flattenMap:^(RACSignal *x) &#123;</span><br><span class="line"><span class="built_in">NSCAssert</span>(x == <span class="literal">nil</span> || [x isKindOfClass:RACSignal.class], <span class="string">@"-switchToLatest requires that the source signal (%@) send signals. Instead we got: %@"</span>, <span class="keyword">self</span>, x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -concat:[RACSignal never] prevents completion of the receiver from</span></span><br><span class="line"><span class="comment">// prematurely terminating the inner signal.</span></span><br><span class="line"><span class="keyword">return</span> [x takeUntil:[connection.signal concat:[RACSignal never]]];</span><br><span class="line">&#125;]</span><br><span class="line">subscribe:subscriber];</span><br><span class="line"></span><br><span class="line">RACDisposable *connectionDisposable = [connection connect];</span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line">[connectionDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -switchToLatest"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>-switchToLatest</code> 内部原信号调用 <code>-publish</code> 转化为热信号，返回的 connection 会持有热信号，也就是其 signal 属性</li><li>对热信号执行 <code>-flattenMap:</code> 方法，通过断言判断热信号发送的信号值是否也是 RACSignal，也就是说 <code>-switchToLatest</code>  方法是处理高阶信号的</li><li>flattenMap 内部会对热信号执行 concat: 方法，这里的传入参数为 [RACSignal never]，RACSignal x 执行 <code>takeUntil:</code>， 作用是为了防止热信号发送的 RACSignal 过早结束导致整个订阅都被结束</li></ol><p><img src="/2019/03/04/RACSignal-Operations-4/switchToLastst.png" alt="image-20190301161002720"></p><h3 id="switch-cases-default"><a href="#switch-cases-default" class="headerlink" title="switch: cases: default:"></a>switch: cases: default:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testswitchCasesDefault &#123;</span><br><span class="line">    RACSignal *signal0 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"00"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"11"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"22"</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *defaultSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1024</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"0"</span>];</span><br><span class="line">        [subscriber sendNext:<span class="string">@"1"</span>];</span><br><span class="line">        [subscriber sendNext:<span class="string">@"2"</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSDictionary</span> *dict = @&#123;<span class="string">@"0"</span> : signal0,</span><br><span class="line">                           <span class="string">@"1"</span> : signal1,</span><br><span class="line">                           <span class="string">@"2"</span> : signal2</span><br><span class="line">                           &#125;;</span><br><span class="line">    </span><br><span class="line">    [[RACSignal <span class="keyword">switch</span>:sourceSignal cases:dict <span class="keyword">default</span>:defaultSignal] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = 00</span><br><span class="line">value = 11</span><br><span class="line">value = 22</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)<span class="keyword">switch</span>:(RACSignal *)signal cases:(<span class="built_in">NSDictionary</span> *)cases <span class="keyword">default</span>:(RACSignal *)defaultSignal &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(signal != <span class="literal">nil</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(cases != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> key <span class="keyword">in</span> cases) &#123;</span><br><span class="line"><span class="keyword">id</span> value __attribute__((unused)) = cases[key];</span><br><span class="line"><span class="built_in">NSCAssert</span>([value isKindOfClass:RACSignal.class], <span class="string">@"Expected all cases to be RACSignals, %@ isn't"</span>, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSDictionary</span> *<span class="keyword">copy</span> = [cases <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[[signal</span><br><span class="line">map:^(<span class="keyword">id</span> key) &#123;</span><br><span class="line"><span class="keyword">if</span> (key == <span class="literal">nil</span>) key = RACTupleNil.tupleNil;</span><br><span class="line"></span><br><span class="line">RACSignal *signal = <span class="keyword">copy</span>[key] ?: defaultSignal;</span><br><span class="line"><span class="keyword">if</span> (signal == <span class="literal">nil</span>) &#123;</span><br><span class="line"><span class="built_in">NSString</span> *description = [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedString</span>(<span class="string">@"No matching signal found for value %@"</span>, <span class="string">@""</span>), key];</span><br><span class="line"><span class="keyword">return</span> [RACSignal error:[<span class="built_in">NSError</span> errorWithDomain:RACSignalErrorDomain code:RACSignalErrorNoMatchingCase userInfo:@&#123; <span class="built_in">NSLocalizedDescriptionKey</span>: description &#125;]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> signal;</span><br><span class="line">&#125;]</span><br><span class="line">switchToLatest]</span><br><span class="line">setNameWithFormat:<span class="string">@"+switch: %@ cases: %@ default: %@"</span>, signal, cases, defaultSignal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><code>-switch:case:default:</code> 首先对参数 signal、case 做非空判断，然后遍历字典 case 并判断每一个 value 是否为 RACSignal 对象</li><li>订阅原信号进行 map 操作，根据 key 来从 case 里面取出对应的 RACSignal 并返回，如果取出来的是 nil，则取 defaultSignal，若 defaultSignal 为nil，则返回 error signal，这样原信号就被转化高阶信号，然后再进行 switchToLatest 操作，把最终的信号值发给订阅者</li></ol><h3 id="if-then-else"><a href="#if-then-else" class="headerlink" title="if: then: else:"></a>if: then: else:</h3><p>测试代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testIfThenElse &#123;</span><br><span class="line">    RACSignal *signalTrue = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"true"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signalFalse = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"false"</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@(<span class="literal">NO</span>)];</span><br><span class="line">        [subscriber sendNext:@(<span class="literal">YES</span>)];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[RACSignal <span class="keyword">if</span>:sourceSignal then:signalTrue <span class="keyword">else</span>:signalFalse] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = false</span><br><span class="line">value = true</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)<span class="keyword">if</span>:(RACSignal *)boolSignal then:(RACSignal *)trueSignal <span class="keyword">else</span>:(RACSignal *)falseSignal &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(boolSignal != <span class="literal">nil</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(trueSignal != <span class="literal">nil</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(falseSignal != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[[boolSignal</span><br><span class="line">map:^(<span class="built_in">NSNumber</span> *value) &#123;</span><br><span class="line"><span class="built_in">NSCAssert</span>([value isKindOfClass:<span class="built_in">NSNumber</span>.class], <span class="string">@"Expected %@ to send BOOLs, not %@"</span>, boolSignal, value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (value.boolValue ? trueSignal : falseSignal);</span><br><span class="line">&#125;]</span><br><span class="line">switchToLatest]</span><br><span class="line">setNameWithFormat:<span class="string">@"+if: %@ then: %@ else: %@"</span>, boolSignal, trueSignal, falseSignal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>+if: then: else:</code> 与 <code>+switch: cases: default:</code> 原理类似，把原信号发送的布尔值通过 map 操作转化对应的 RACSignal 返回。YES-&gt;trueSignal, NO-&gt;falseSignal，原信号被转化成高阶信号，再执行 switchToLatest ，后面逻辑与  <code>+switch: cases: default:</code>  一样</p><h3 id="catch"><a href="#catch" class="headerlink" title="catch:"></a>catch:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testCatch &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@""</span> code:<span class="number">-1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">        [subscriber sendError:error];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *catchSignal = [sourceSignal catch:^RACSignal * _Nonnull(<span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"excute catch block, error = %@"</span>, error);</span><br><span class="line">        <span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:<span class="string">@"error text"</span>];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [catchSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">excute catch block, error = Error Domain= Code=-1 "(null)"</span><br><span class="line">value = error text</span><br></pre></td></tr></table></figure><p>底层实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)catch:(RACSignal * (^)(<span class="built_in">NSError</span> *error))catchBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(catchBlock != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACSerialDisposable *catchDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">RACSignal *signal = catchBlock(error);</span><br><span class="line"><span class="built_in">NSCAssert</span>(signal != <span class="literal">nil</span>, <span class="string">@"Expected non-nil signal from catch block on %@"</span>, <span class="keyword">self</span>);</span><br><span class="line">catchDisposable.disposable = [signal subscribe:subscriber];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[catchDisposable dispose];</span><br><span class="line">[subscriptionDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -catch:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当原信号发送 sendError 的时候把 error 传入 catchBlock  闭包并返回 RACSignal，通过断言判断返回的 signal 是否为空，然后再订阅 signal，把 signal 的信号发给最终的订阅者</p><h3 id="try"><a href="#try" class="headerlink" title="try:"></a>try:</h3><p>测试代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testTry &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"source signal dispose"</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *trySignal = [sourceSignal try:^<span class="built_in">BOOL</span>(<span class="keyword">id</span>  _Nullable value, <span class="built_in">NSError</span> * _Nullable __autoreleasing * _Nullable errorPtr) &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> i = [value integerValue];</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            *errorPtr = [<span class="built_in">NSError</span> errorWithDomain:<span class="string">@""</span> code:<span class="number">-1</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [trySignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [trySignal subscribeError:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error = %@"</span>, error);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value = 0</span><br><span class="line">value = 1</span><br><span class="line">value = 2</span><br><span class="line">source signal dispose</span><br><span class="line">error = Error Domain= Code=-1 "(null)"</span><br><span class="line">source signal dispose</span><br></pre></td></tr></table></figure><p>底层实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)try:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> value, <span class="built_in">NSError</span> **errorPtr))tryBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(tryBlock != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^(<span class="keyword">id</span> value) &#123;</span><br><span class="line"><span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line"><span class="built_in">BOOL</span> passed = tryBlock(value, &amp;error);</span><br><span class="line"><span class="keyword">return</span> (passed ? [RACSignal <span class="keyword">return</span>:value] : [RACSignal error:error]);</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -try:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>tryBlock 根据原信号发送的信号值返回 passed 和 error（error 是以指针地址的形式传入，tryBlock 内部对其进行赋值）</li><li>如果 passed 为 YES，则将原信号发送的 value 包装成 RACSignal；若 passed 为 NO，则返回 RACErrorSignal ，通过这2包装，原信号会被包装成一个高阶信号</li></ol><h3 id="firstOrDefault-success-error"><a href="#firstOrDefault-success-error" class="headerlink" title="firstOrDefault: success: error:"></a>firstOrDefault: success: error:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testFirstOrDefaultSuccessError &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">            [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">BOOL</span> success;</span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="keyword">id</span> value = [sourceSignal firstOrDefault:@<span class="number">10</span> success:&amp;success error:&amp;error];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"value = %@|thread=%@"</span>, value, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = 0|thread=&lt;NSThread: 0x608000075600&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><p>底层实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)firstOrDefault:(<span class="keyword">id</span>)defaultValue success:(<span class="built_in">BOOL</span> *)success error:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line"><span class="built_in">NSCondition</span> *condition = [[<span class="built_in">NSCondition</span> alloc] init];</span><br><span class="line">condition.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"[%@] -firstOrDefault: %@ success:error:"</span>, <span class="keyword">self</span>.name, defaultValue];</span><br><span class="line"></span><br><span class="line">__block <span class="keyword">id</span> value = defaultValue;</span><br><span class="line">__block <span class="built_in">BOOL</span> done = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Ensures that we don't pass values across thread boundaries by reference.</span></span><br><span class="line">__block <span class="built_in">NSError</span> *localError;</span><br><span class="line">__block <span class="built_in">BOOL</span> localSuccess;</span><br><span class="line"></span><br><span class="line">[[<span class="keyword">self</span> take:<span class="number">1</span>] subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">[condition lock];</span><br><span class="line"></span><br><span class="line">value = x;</span><br><span class="line">localSuccess = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">done = <span class="literal">YES</span>;</span><br><span class="line">[condition broadcast];</span><br><span class="line">[condition unlock];</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *e) &#123;</span><br><span class="line">[condition lock];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!done) &#123;</span><br><span class="line">localSuccess = <span class="literal">NO</span>;</span><br><span class="line">localError = e;</span><br><span class="line"></span><br><span class="line">done = <span class="literal">YES</span>;</span><br><span class="line">[condition broadcast];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[condition unlock];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[condition lock];</span><br><span class="line"></span><br><span class="line">localSuccess = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">done = <span class="literal">YES</span>;</span><br><span class="line">[condition broadcast];</span><br><span class="line">[condition unlock];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[condition lock];</span><br><span class="line"><span class="keyword">while</span> (!done) &#123;</span><br><span class="line">[condition wait];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (success != <span class="literal">NULL</span>) *success = localSuccess;</span><br><span class="line"><span class="keyword">if</span> (error != <span class="literal">NULL</span>) *error = localError;</span><br><span class="line"></span><br><span class="line">[condition unlock];</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>定义好状态相关的变量<ul><li>value： 记录原信号发送的值</li><li>done：判断原信号是否发送了 sendCompleted / sendError / sendNext</li><li>localError：记录原信号发送的 NSError</li><li>localSuccess：记录原信号是否发送过 sendCompleted / sendNext</li><li>condition ：同步用的锁</li></ul></li><li>订阅原信号并通过 take: 方法只获取第一个信号值<ul><li>sendNext：condition 先加锁，记录 value，如果为nil，则保持为 defaultValue，condition 调用 broadcast 通知所有等待的线程</li><li>sendCompleted：和 sendNext 类似</li><li>sendError：如果之前没有发送过 sendNext，则会保存 error，然后 condition 调用 broadcast 通知所有等待的线程</li></ul></li><li>订阅完原信号之后，会马上对 condition 进行加锁，一直等待原信号发送信号值并会阻塞当前线程</li></ol><p><code>-firstOrDefault: success: error:</code> 用法有点类似 python 中 <code>await</code>，有点像协程的概念</p><p>要注意的是如果执行该方法的线程和原信号发送 sendCompleted / sendError / sendNext 是统一线程，很容易会造成死锁，因为函数内部会先对 condition 加锁一次（步骤3），然后收到原信号发送的信号值的时候幽会对 condition 加锁一次，这时候如果在统一线程会造成死锁</p><h3 id="waitUntilCompleted"><a href="#waitUntilCompleted" class="headerlink" title="waitUntilCompleted:"></a>waitUntilCompleted:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testWaitUntilCompleted &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">            [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSError</span> *error;</span><br><span class="line">    <span class="built_in">BOOL</span> success = [sourceSignal waitUntilCompleted:&amp;error];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"success = %@"</span>, @(success));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">success = 1</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)waitUntilCompleted:(<span class="built_in">NSError</span> **)error &#123;</span><br><span class="line"><span class="built_in">BOOL</span> success = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">[[[<span class="keyword">self</span></span><br><span class="line">ignoreValues]</span><br><span class="line">setNameWithFormat:<span class="string">@"[%@] -waitUntilCompleted:"</span>, <span class="keyword">self</span>.name]</span><br><span class="line">firstOrDefault:<span class="literal">nil</span> success:&amp;success error:error];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先对原信号执行 ignoreValues 方法，过滤掉所有 sendNext 事件</li><li>执行 firstOrDefault: success: error: ，若原信号发送 sendCompleted，则返回 YES，若发送 sendError 则返回 NO</li></ol><h3 id="defer"><a href="#defer" class="headerlink" title="defer:"></a>defer:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testDefer &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[RACSignal defer:^RACSignal * _Nonnull&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"execute defer block"</span>);</span><br><span class="line">        <span class="keyword">return</span> sourceSignal;</span><br><span class="line">    &#125;] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute defer block</span><br><span class="line">value = 0</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)defer:(RACSignal&lt;<span class="keyword">id</span>&gt; * (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"><span class="keyword">return</span> [block() subscribe:subscriber];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"+defer:"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>+defer:</code> 首先创建返回新的信号，然后执行 block，并订阅 block 返回的信号；<code>+defer:</code> 主要作用是延迟订阅，也就是在订阅前进行相关自定义的操作</p><h3 id="initially"><a href="#initially" class="headerlink" title="initially:"></a>initially:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testInitially &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *initialSignal = [sourceSignal initially:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"execute initial block"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [initialSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execute initial block</span><br><span class="line">value = 0</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)initially:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[RACSignal defer:^&#123;</span><br><span class="line">block();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -initially:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-initially:</code> 是通过封装 defer 实现的，在 defer 的 block 中先执行block，在返回自己，也就是订阅原信号之前先进行 block 中的相关操作</p><h3 id="deliverOn"><a href="#deliverOn" class="headerlink" title="deliverOn:"></a>deliverOn:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testDeliverOn &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[sourceSignal deliverOn:[RACScheduler mainThreadScheduler]] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = x|thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [sourceSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = x|thread = %@"</span>, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = 0|thread = &lt;NSThread: 0x600000a77240&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">value = 0|thread = &lt;NSThread: 0x60c0000718c0&gt;&#123;number = 1, name = main&#125;</span><br></pre></td></tr></table></figure><p>底层实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)deliverOn:(RACScheduler *)scheduler &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">[scheduler schedule:^&#123;</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125;];</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[scheduler schedule:^&#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125;];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[scheduler schedule:^&#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -deliverOn: %@"</span>, <span class="keyword">self</span>.name, scheduler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-deliverOn:</code>  当原信号发送 sendNext/sendError/sendCompleted  的时候，会根据传入的调度器 scheduler ，在对应的线程中把信号发给订阅者；换句话来说，就是通过传入 scheduler 指定对应线程接受信号</p><h3 id="subscribeOn"><a href="#subscribeOn" class="headerlink" title="subscribeOn:"></a>subscribeOn:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)subscribeOn:(RACScheduler *)scheduler &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">RACDisposable *schedulingDisposable = [scheduler schedule:^&#123;</span><br><span class="line">RACDisposable *subscriptionDisposable = [<span class="keyword">self</span> subscribe:subscriber];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:subscriptionDisposable];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:schedulingDisposable];</span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -subscribeOn: %@"</span>, <span class="keyword">self</span>.name, scheduler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-subscribeOn:</code> 和 <code>-deliverOn:</code> 类似，主要区别在于 <code>-subscribeOn:</code> 是指定订阅动作所在的线程，也就是执行 didSubscribe 闭包的线程被指定，但是 sendNext/sendError/sendCompleted 所在线程是不确定的</p><h3 id="deliverOnMainThread"><a href="#deliverOnMainThread" class="headerlink" title="deliverOnMainThread"></a>deliverOnMainThread</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)deliverOnMainThread &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">__block <span class="keyword">volatile</span> int32_t queueLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^performOnMainThread)(dispatch_block_t) = ^(dispatch_block_t block) &#123;</span><br><span class="line">int32_t queued = OSAtomicIncrement32(&amp;queueLength);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">NSThread</span>.isMainThread &amp;&amp; queued == <span class="number">1</span>) &#123;</span><br><span class="line">block();</span><br><span class="line">OSAtomicDecrement32(&amp;queueLength);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">block();</span><br><span class="line">OSAtomicDecrement32(&amp;queueLength);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">performOnMainThread(^&#123;</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125;);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">performOnMainThread(^&#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125;);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">performOnMainThread(^&#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -deliverOnMainThread"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-deliverOnMainThread</code> 和 <code>-deliverOn</code> 作用类似，前者是将 sendNext/sendError/sendCompleted 都放在主线程上执行</p><p>OSAtomicIncrement32 方法是对某个值进行自增计算并且是线程安全，如果当前线程是主线程并且 OSAtomicIncrement32 函数返回值是 1，说明当前主线程没有待执行的 sendNext/sendError/sendCompleted 事件，这时候会直接运行block，反之则把任务放在主线程异步执行</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactiveCocoa </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RACSignal常用方法深入分析(3)</title>
      <link href="/2019/02/23/RACSignal-Operations-3/"/>
      <url>/2019/02/23/RACSignal-Operations-3/</url>
      
        <content type="html"><![CDATA[<p>本篇文章接着<a href="https://chipengliu.github.io/2019/01/20/RACSignal-Operations-2/">上篇</a>继续分析常用的 RACSignal 方法的第三部分进行分析。</p><a id="more"></a><h3 id="ignoreValues"><a href="#ignoreValues" class="headerlink" title="ignoreValues"></a>ignoreValues</h3><p><code>-ignoreValues</code> 底层比较简单，直接通过封装 <code>filter</code> 方法，将所有输入信号都忽略掉，所以最终的订阅者无法收到任何信号。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)ignoreValues &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> filter:^(<span class="keyword">id</span> _) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -ignoreValues"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ignore"><a href="#ignore" class="headerlink" title="ignore:"></a>ignore:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testIgnore &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *filterSignal = [sourceSignal ignore:@<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    [filterSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = 0</span><br><span class="line">value = 2</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)ignore:(<span class="keyword">id</span>)value &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> filter:^ <span class="built_in">BOOL</span> (<span class="keyword">id</span> innerValue) &#123;</span><br><span class="line"><span class="keyword">return</span> innerValue != value &amp;&amp; ![innerValue isEqual:value];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -ignore: %@"</span>, <span class="keyword">self</span>.name, RACDescription(value)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-ignore:</code> 内部是通过封装 <code>filter</code> 方法实现，主要通过 filter 筛选闭包判断原信号发出的信号值和参数 value 相同，相同则被过滤掉。</p><h3 id="take"><a href="#take" class="headerlink" title="take:"></a>take:</h3><p><code>-take:</code> 实现思想和 <code>-distinctUntilChanged</code> 相似，同样的是通过封装 <code>-bind:</code> 实现，在 <code>-bind:</code> 闭包中，用变量 taken 来记录原信号发送信号的次数，当 taken 取到 count 个数的时候，就停止给订阅者发送信号。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)take:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">        __block <span class="built_in">NSUInteger</span> taken = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ^ <span class="keyword">id</span> (<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (taken &lt; count) &#123;</span><br><span class="line">                ++taken;</span><br><span class="line">                <span class="keyword">if</span> (taken == count) *stop = <span class="literal">YES</span>;</span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -take: %lu"</span>, <span class="keyword">self</span>.name, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="takeLast"><a href="#takeLast" class="headerlink" title="takeLast:"></a>takeLast:</h3><p>测试代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testTakeLast &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *takeSignal = [sourceSignal takeLast:<span class="number">2</span>];</span><br><span class="line">    </span><br><span class="line">    [takeSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = 2</span><br><span class="line">value = 3</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)takeLast:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *valuesTaken = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:count];</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">[valuesTaken addObject:x ? : RACTupleNil.tupleNil];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (valuesTaken.count &gt; count) &#123;</span><br><span class="line">[valuesTaken removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> value <span class="keyword">in</span> valuesTaken) &#123;</span><br><span class="line">[subscriber sendNext:value == RACTupleNil.tupleNil ? <span class="literal">nil</span> : value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -takeLast: %lu"</span>, <span class="keyword">self</span>.name, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>takeLast:</code> 先订阅原信号，根据参数 count， 保存最后 count 个信号值到数组 valuesTaken。当原信号发送 sendCompleted的时候遍历 valuesTaken 将其元素逐个发给订阅者。</p><h3 id="takeUntilBlock"><a href="#takeUntilBlock" class="headerlink" title="takeUntilBlock:"></a>takeUntilBlock:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)takeUntilBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(predicate != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line"><span class="keyword">return</span> ^ <span class="keyword">id</span> (<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">if</span> (predicate(value)) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -takeUntilBlock:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-takeUntilBlock:</code> 和 <code>-taskLast:</code> 实现思路基本一致，后置是通过信号值个数和参数 count 比较判断是否继续给订阅者发送型号，而 <code>-takeUntilBlock:</code>  是根据参数 predicate 闭包执行结果来判断是否给订阅者发送信号</p><h3 id="takeUntil"><a href="#takeUntil" class="headerlink" title="takeUntil:"></a>takeUntil:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testUntil &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *untilSignal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">10</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *takeSignal = [sourceSignal takeUntil:untilSignal];</span><br><span class="line">    </span><br><span class="line">    [takeSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="number">0</span></span><br><span class="line">value = <span class="number">1</span></span><br><span class="line">value = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>底层实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)takeUntil:(RACSignal *)signalTrigger &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"><span class="keyword">void</span> (^triggerCompletion)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">[disposable dispose];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RACDisposable *triggerDisposable = [signalTrigger subscribeNext:^(<span class="keyword">id</span> _) &#123;</span><br><span class="line">triggerCompletion();</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">triggerCompletion();</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:triggerDisposable];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!disposable.disposed) &#123;</span><br><span class="line">RACDisposable *selfDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[disposable dispose];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:selfDisposable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -takeUntil: %@"</span>, <span class="keyword">self</span>.name, signalTrigger];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-takeUntil:</code> 会返回新的信号，新信号被订阅的时候触发入参闭包:</p><ol><li>订阅 signalTrigger 信号，如果发送 sendNext/sendCompleted 则结束整个新信号的订阅</li><li>如果 signalTrigger 尚未发送过  sendNext/sendCompleted ，则将原信号的信号事件透传给订阅者</li></ol><p><img src="/2019/02/23/RACSignal-Operations-3/image-takeuntil.png" alt="image-takeuntil"></p><h3 id="takeUntilReplacement"><a href="#takeUntilReplacement" class="headerlink" title="takeUntilReplacement:"></a>takeUntilReplacement:</h3><p>测试代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testTakeUntilReplacement &#123;</span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">            [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal2 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">5</span>];</span><br><span class="line">            [subscriber sendNext:@<span class="number">6</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *newSignal = [signal1 takeUntilReplacement:signal2];</span><br><span class="line">    [newSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value = 0</span><br><span class="line">value = 1</span><br><span class="line">value = 2</span><br><span class="line">value = 5</span><br><span class="line">value = 6</span><br></pre></td></tr></table></figure><p>底层实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)takeUntilReplacement:(RACSignal *)replacement &#123;</span><br><span class="line"><span class="keyword">return</span> [RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line"></span><br><span class="line">RACDisposable *replacementDisposable = [replacement subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">[selfDisposable dispose];</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[selfDisposable dispose];</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[selfDisposable dispose];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!selfDisposable.disposed) &#123;</span><br><span class="line">selfDisposable.disposable = [[<span class="keyword">self</span></span><br><span class="line">concat:[RACSignal never]]</span><br><span class="line">subscribe:subscriber];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[selfDisposable dispose];</span><br><span class="line">[replacementDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>takeUntilReplacement:</code>  内部主要经历以下的步骤：</p><ol><li><p>首先原信号执行 <code>-concat:</code> 方法并传入 [RACSignal never]，[RACSignal never] 返回的信号不会给订阅者发送任何东西，这样能保证收到 replacement 信号前，源信号不会被 dispose</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)never &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> createSignal:^ RACDisposable * (<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"+never"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>订阅 replacement 信号，当收到其发送的 sendNext/sendError/sendCompleted 时，先讲原信号 dispose，然后将对应的信号发给最终的订阅者</p></li></ol><p>主要流程如图所示:</p><p><img src="/2019/02/23/RACSignal-Operations-3/takeUntilReplacement.png" alt="image-20190223154342910"></p><h3 id="skip"><a href="#skip" class="headerlink" title="skip:"></a>skip:</h3><p>测试代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testSkip &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[sourceSignal skip:<span class="number">1</span>] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value = 1</span><br><span class="line">value = 2</span><br><span class="line">value = 3</span><br><span class="line">value = 4</span><br></pre></td></tr></table></figure><p>底层实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)skip:(<span class="built_in">NSUInteger</span>)skipCount &#123;</span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">__block <span class="built_in">NSUInteger</span> skipped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">if</span> (skipped &gt;= skipCount) <span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line"></span><br><span class="line">skipped++;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -skip: %lu"</span>, <span class="keyword">self</span>.name, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)skipCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-skip:</code> 方法内补也是通过 <code>-bind:</code> 方法进行封装，通过变量 skipped 来记录原始信号已经发过几个信号，当skipped &gt;= skipCount 的时候，会将信号事件直接发给最终订阅者。</p><p><img src="/2019/02/23/RACSignal-Operations-3/skip.png" alt="image-20190223161533779"></p><h3 id="skipUntilBlock"><a href="#skipUntilBlock" class="headerlink" title="skipUntilBlock:"></a>skipUntilBlock:</h3><p>测试代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testSkipUntilBlock &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[sourceSignal skipUntilBlock:^<span class="built_in">BOOL</span>(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="keyword">return</span> [x integerValue] &gt; <span class="number">3</span>;</span><br><span class="line">    &#125;] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = 4</span><br><span class="line">value = 0</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)skipUntilBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(predicate != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">__block <span class="built_in">BOOL</span> skipping = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ^ <span class="keyword">id</span> (<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">if</span> (skipping) &#123;</span><br><span class="line"><span class="keyword">if</span> (predicate(value)) &#123;</span><br><span class="line">skipping = <span class="literal">NO</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -skipUntilBlock:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-skipUntilBlock:</code> 和 <code>-skip:</code> 原理类似，忽略信号的条件从信号个数变化成从 predicate 闭包来判断，值得注意的是，当 predicate 闭包返回 YES 之后的所有信号就不再会被 skip。</p><h3 id="skipWhileBlock"><a href="#skipWhileBlock" class="headerlink" title="skipWhileBlock:"></a>skipWhileBlock:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)skipWhileBlock:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> x))predicate &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(predicate != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> skipUntilBlock:^ <span class="built_in">BOOL</span> (<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="keyword">return</span> !predicate(x);</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -skipWhileBlock:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>-skipUntilBlock:</code> 类似，也是通过 predicate 闭包返回结果来判断是否来 skip 信号，区别是 </p><p><code>-skipWhileBlock:</code> 只有 predicate 返回 YES 才skip 信号，一旦返回 NO，以后的信号就不再会被 skip</p><p>### </p><h3 id="distinctUntilChanged"><a href="#distinctUntilChanged" class="headerlink" title="distinctUntilChanged"></a>distinctUntilChanged</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testDistinctUntilChanged &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *filterSignal = [sourceSignal distinctUntilChanged];</span><br><span class="line">    </span><br><span class="line">    [filterSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value = 0</span><br><span class="line">value = 1</span><br><span class="line">value = 2</span><br><span class="line">value = 3</span><br></pre></td></tr></table></figure><p>底层实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)distinctUntilChanged &#123;</span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">__block <span class="keyword">id</span> lastValue = <span class="literal">nil</span>;</span><br><span class="line">__block <span class="built_in">BOOL</span> initial = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ^(<span class="keyword">id</span> x, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">if</span> (!initial &amp;&amp; (lastValue == x || [x isEqual:lastValue])) <span class="keyword">return</span> [<span class="keyword">class</span> empty];</span><br><span class="line"></span><br><span class="line">initial = <span class="literal">NO</span>;</span><br><span class="line">lastValue = x;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:x];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -distinctUntilChanged"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-distinctUntilChanged</code> 是底层是通过 <code>-bind:</code> 方法来实现</p><ol><li>定义 lastValue 记录原信号上一次发送的信号值，initial 判断之前2个信号值是否相同</li><li>如果当前发送的信号值和上一次的相同，直接返回 empty 信号并发送给订阅者</li><li>如果当前原信号发送的信号值和上一次不相同，调用 return 方法将信号值包装成新的信号发送给订阅者</li></ol><h3 id="groupBy-transform"><a href="#groupBy-transform" class="headerlink" title="groupBy:transform:"></a>groupBy:transform:</h3><p>测试代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testGroupByTransform &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *groupSignal = [sourceSignal groupBy:^<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt; _Nullable(<span class="keyword">id</span>  _Nullable object) &#123;</span><br><span class="line">        <span class="keyword">return</span> [object integerValue] &gt; <span class="number">2</span> ? <span class="string">@"send"</span> : <span class="string">@"skip"</span>;</span><br><span class="line">    &#125; transform:^<span class="keyword">id</span> _Nullable(<span class="keyword">id</span>  _Nullable object) &#123;</span><br><span class="line">        <span class="keyword">return</span> @([object integerValue] * <span class="number">10</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *filterSignal = [[groupSignal filter:^<span class="built_in">BOOL</span>(RACGroupedSignal *value) &#123;</span><br><span class="line">        <span class="keyword">return</span> [(<span class="built_in">NSString</span> *)value.key isEqualToString:<span class="string">@"send"</span>];</span><br><span class="line">    &#125;] flatten];</span><br><span class="line">    </span><br><span class="line">    [filterSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = 30</span><br><span class="line">value = 40</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)groupBy:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt; (^)(<span class="keyword">id</span> object))keyBlock transform:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> object))transformBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(keyBlock != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *groups = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *orderedGroups = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt; key = keyBlock(x);</span><br><span class="line">RACGroupedSignal *groupSubject = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">@synchronized</span>(groups) &#123;</span><br><span class="line">groupSubject = groups[key];</span><br><span class="line"><span class="keyword">if</span> (groupSubject == <span class="literal">nil</span>) &#123;</span><br><span class="line">groupSubject = [RACGroupedSignal signalWithKey:key];</span><br><span class="line">groups[key] = groupSubject;</span><br><span class="line">[orderedGroups addObject:groupSubject];</span><br><span class="line">[subscriber sendNext:groupSubject];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[groupSubject sendNext:transformBlock != <span class="literal">NULL</span> ? transformBlock(x) : x];</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line"></span><br><span class="line">[orderedGroups makeObjectsPerformSelector:<span class="keyword">@selector</span>(sendError:) withObject:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line"></span><br><span class="line">[orderedGroups makeObjectsPerformSelector:<span class="keyword">@selector</span>(sendCompleted)];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -groupBy:transform:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-groupBy:transform:</code> 主要是信号事件转化成类似 map 结构数据发给订阅者，主要逻辑可以概括为：</p><ol><li><p>创建可变字典 groups 和 可变数组 orderedGroups</p></li><li><p>订阅原信号，当原信号发送 sendNext 的时候，通过闭包 keyBlock 取到对应的 key 值，然后根据 key 从 groups 中取出对应的 groupSubject (RACGroupedSignal 类型)，如果为空则新建一个，并且加入到 orderedGroups 数组中，再把 groupSubject 发给最终订阅者</p></li><li><p>groupSubject 给订阅者发送 transformBlock 闭包的返回结果，如果 transformBlock 是空，则直接把信号发给订阅者</p></li><li><p>原信号发送 sendCompleted / sendError ，遍历数组 orderedGroups 并对其中的 RACGroupedSignal 元素执行对应的 sendCompleted / sendError</p><p>经过上面的分析看得出 <code>-groupBy:transform:</code> 方法返回的方法也是一个高阶信号，我们可以结合之前 <code>-flatten</code> 、<code>-flattenMap:</code> 等方法结合使用，对齐进行降阶</p></li></ol><h3 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy:"></a>groupBy:</h3><p><code>-groupBy:</code> 是通过封装 <code>-groupBy:transform:</code> 来实现的，把后者入参 transformBlock 赋值为 nil，也就是  <code>-groupBy:transform:</code>  主要逻辑步骤3中，groupSubject 会给其订阅者返回原信号发送的信号值</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)groupBy:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt; (^)(<span class="keyword">id</span> object))keyBlock &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> groupBy:keyBlock transform:<span class="literal">nil</span>] setNameWithFormat:<span class="string">@"[%@] -groupBy:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactiveCocoa </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RACSignal常用方法深入分析(2)</title>
      <link href="/2019/01/31/RACSignal-Operations-2/"/>
      <url>/2019/01/31/RACSignal-Operations-2/</url>
      
        <content type="html"><![CDATA[<p>本篇文章接着<a href="https://chipengliu.github.io/2019/01/20/RACSignal-Operations/">上篇</a>继续分析常用的 RACSignal 的方法</p><a id="more"></a><h3 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testFlatten &#123;</span><br><span class="line">    RACSignal *sourceSignal1 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    sourceSignal1.name = <span class="string">@"sourceSignal1"</span>;</span><br><span class="line">    </span><br><span class="line">    RACSignal *sourceSignal2 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    sourceSignal2.name = <span class="string">@"sourceSignal2"</span>;</span><br><span class="line">    </span><br><span class="line">    RACSignal *sourceSignal3 = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:sourceSignal1];</span><br><span class="line">        [subscriber sendNext:sourceSignal2];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    sourceSignal3.name = <span class="string">@"sourceSignal3"</span>;</span><br><span class="line">    </span><br><span class="line">    [[sourceSignal3 flatten] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value = 0</span><br><span class="line">value = 1</span><br><span class="line">value = 2</span><br><span class="line">value = 3</span><br></pre></td></tr></table></figure><p>flatten 从字面看是压扁、扁平的意思，而对于 RACSignal 来说，可以理解为 解包、降阶 的意思。</p><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)flatten &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^(<span class="keyword">id</span> value) &#123;</span><br><span class="line"><span class="keyword">return</span> value;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -flatten"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flatten 方法内部是通过封装 flattenMap 实现，flattenMap 的实现在之前的<a href="https://chipengliu.github.io/2019/01/20/RACSignal-Operations/">文章</a>中做过分析，可以看得出，执行 flatten 方法的原信号发送的信号必须是 RACStream 类型，否则会崩溃。原型号每次发送 sendNext，发送的信号(这里是RACSignal)会被订阅，然后又会触发发送的信号的sendNext，将信号值发送给最终订阅者，最终对原信号发送的信号进行解包、降阶。</p><p><img src="/2019/01/31/RACSignal-Operations-2/image-20190201093344155.png" alt="image-20190201093344155"></p><h3 id="flatten-1"><a href="#flatten-1" class="headerlink" title="flatten:"></a>flatten:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testFlatten &#123;</span><br><span class="line">    RACSignal *signal0 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal3 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:signal0];</span><br><span class="line">        [subscriber sendNext:signal1];</span><br><span class="line">        [subscriber sendNext:signal2];</span><br><span class="line">        [subscriber sendNext:signal3];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[sourceSignal flatten:<span class="number">2</span>] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value = 0</span><br><span class="line">value = 1</span><br><span class="line">value = 3</span><br><span class="line">value = 2</span><br></pre></td></tr></table></figure><p><code>-flatten:</code> 和 <code>-flatten</code> 类似，都是对高阶信号进行降阶、解包操作，但是前者多一个入参 <code>maxConcurrent</code> 来控制同一时间对高阶信号发出的子信号的订阅动作。</p><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)flatten:(<span class="built_in">NSUInteger</span>)maxConcurrent &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACCompoundDisposable *compoundDisposable = [[RACCompoundDisposable alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains disposables for the currently active subscriptions.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This should only be used while synchronized on `subscriber`.</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *activeDisposables = [[<span class="built_in">NSMutableArray</span> alloc] initWithCapacity:maxConcurrent];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether the signal-of-signals has completed yet.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This should only be used while synchronized on `subscriber`.</span></span><br><span class="line">__block <span class="built_in">BOOL</span> selfCompleted = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscribes to the given signal.</span></span><br><span class="line">__block <span class="keyword">void</span> (^subscribeToSignal)(RACSignal *);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Weak reference to the above, to avoid a leak.</span></span><br><span class="line">__<span class="keyword">weak</span> __block <span class="keyword">void</span> (^recur)(RACSignal *);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sends completed to the subscriber if all signals are finished.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This should only be used while synchronized on `subscriber`.</span></span><br><span class="line"><span class="keyword">void</span> (^completeIfAllowed)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line"><span class="keyword">if</span> (selfCompleted &amp;&amp; activeDisposables.count == <span class="number">0</span>) &#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The signals waiting to be started.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This array should only be used while synchronized on `subscriber`.</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *queuedSignals = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">recur = subscribeToSignal = ^(RACSignal *signal) &#123;</span><br><span class="line">            <span class="comment">/// STEP 3</span></span><br><span class="line">RACSerialDisposable *serialDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">@synchronized</span> (subscriber) &#123;</span><br><span class="line">[compoundDisposable addDisposable:serialDisposable];</span><br><span class="line">[activeDisposables addObject:serialDisposable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serialDisposable.disposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">__<span class="keyword">strong</span> <span class="keyword">void</span> (^subscribeToSignal)(RACSignal *) = recur;</span><br><span class="line">RACSignal *nextSignal;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@synchronized</span> (subscriber) &#123;</span><br><span class="line">[compoundDisposable removeDisposable:serialDisposable];</span><br><span class="line">[activeDisposables removeObjectIdenticalTo:serialDisposable];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (queuedSignals.count == <span class="number">0</span>) &#123;</span><br><span class="line">completeIfAllowed();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nextSignal = queuedSignals[<span class="number">0</span>];</span><br><span class="line">[queuedSignals removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subscribeToSignal(nextSignal);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[compoundDisposable addDisposable:[<span class="keyword">self</span> subscribeNext:^(RACSignal *signal) &#123;</span><br><span class="line">            <span class="comment">/// STEP 1</span></span><br><span class="line"><span class="keyword">if</span> (signal == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSCAssert</span>([signal isKindOfClass:RACSignal.class], <span class="string">@"Expected a RACSignal, got %@"</span>, signal);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@synchronized</span> (subscriber) &#123;</span><br><span class="line"><span class="keyword">if</span> (maxConcurrent &gt; <span class="number">0</span> &amp;&amp; activeDisposables.count &gt;= maxConcurrent) &#123;</span><br><span class="line">[queuedSignals addObject:signal];</span><br><span class="line"></span><br><span class="line"><span class="comment">// If we need to wait, skip subscribing to this</span></span><br><span class="line"><span class="comment">// signal.</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subscribeToSignal(signal);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">            <span class="comment">/// STEP 2</span></span><br><span class="line"><span class="keyword">@synchronized</span> (subscriber) &#123;</span><br><span class="line">selfCompleted = <span class="literal">YES</span>;</span><br><span class="line">completeIfAllowed();</span><br><span class="line">&#125;</span><br><span class="line">&#125;]];</span><br><span class="line"></span><br><span class="line">[compoundDisposable addDisposable:[RACDisposable disposableWithBlock:^&#123;</span><br><span class="line"><span class="comment">// A strong reference is held to `subscribeToSignal` until we're</span></span><br><span class="line"><span class="comment">// done, preventing it from deallocating early.</span></span><br><span class="line">subscribeToSignal = <span class="literal">nil</span>;</span><br><span class="line">&#125;]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> compoundDisposable;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -flatten: %lu"</span>, <span class="keyword">self</span>.name, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)maxConcurrent];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在订阅原信号的之前，先定义了几个相关变量：</p><ul><li>activeDisposables：可变数组，保存 原信号发送的 RACSignal 信号 被订阅时候返回的 <code>RACDisposable</code> 对象</li><li>selfCompleted: 判断原信号是否已经发送过 sendCompleted</li><li>subscribeToSignal闭包：订阅 RACSignal 信号，并对RACSignal进行相关处理。</li><li>resur闭包：对 subscribeToSignal 闭包的一个弱引用，避免之前定义 subscribeToSignal 的内部引起循环引用</li><li>completeIfAllowed闭包：当所有高阶信号都发送了 sendCompleted 或原信号发送了 sendCompleted 会执行，目的是给订阅者发送 sendCompleted</li><li>queuedSignals：可变数组，缓存原信号发出的且未被订阅的 RACSignal 信号</li></ul><p>了解完 flatten: 内部变量的含义之后，接下来具体分析一下此方法的流程:</p><ol><li>订阅原信号，然后收到原信号的 sendNext 事件，如果信号值为nil，直接return；如果不为nil，则需要判断是否属于 RACSignal。如果当前最大可订阅的信号数量 maxConcurrent &gt; 0，而且正在被订阅且订阅未完成的子信号数量 activeDisposables.count &gt;= maxConcurren，则把子信号加入缓存数组 queuedSignals 中。如果数量条件不满足，传入子信号 signal 执行 subscribeToSignal 闭包。</li><li>若原信号发送了 sendCompleted，selfCompleted = YES，执行 completeIfAllowed 闭包，如果当前没有正在出于订阅过程的子信号，则给订阅者发送 sendCompleted</li><li>当执行 subscribeToSignal 闭包的时候订阅闭包传入的参数 signal，然后进行一系列处理：<ul><li>把订阅 signal 的 Disposable 加入 activeDisposables 数组中</li><li>当 signal 发送 sendCompleted 时，先定义内部闭包变量 subscribeToSignal，需要注意的是此闭包变量和订阅原信号之前定义的 subscribeToSignal 闭包是同一个，但是前者时通过指向 recur(__weak修饰) 来避循环引用，基本原理和我们平时经常使用的 weak-strong-dance 基本一致。然后通过对 subscriber 加锁进行原子性操作，先从 activeDisposables 移除 signal 对应的 Disposable。然后判断缓存队列中是否还有未被订阅的子信号，若没有，执行completeIfAllowed；若有，取出队列中第一个元素，重复步骤3，也就是重新触发 subscribeToSignal。</li></ul></li><li>当整个原信号的订阅流程结束，也就是给订阅者发送 sendCompleted 之后，原信号对应的 RACDisposable 中会将 subscribeToSignal 闭包赋值为nil，避免循环引用</li></ol><p>总结来说，原信号每次发送一个子信号，先判断 activeDisposables 保存的元素个数是否超过 maxConcurrent，若超过则把子信号保存在 queuedSignals 数组中进行缓存；反之调用 subscribeToSignal 闭包，并传入当前的子信号。</p><p>每当子信号发送 sendCompleted，就会从 queuedSignals 数组中取出缓存的子信号然后进行订阅；如果 queuedSignals 元素数目为0，则结束原信号的订阅。</p><p>flatten: 函数主要是围绕的参数 maxConcurrent 做处理，在订阅原信号的可以看到其中的判断 <code>maxConcurrent &gt; 0 &amp;&amp; activeDisposables.count &gt;= maxConcurrent</code> ，不同 maxConcurrent 值决定了 flatten: 的不同表现：</p><ol><li><p>maxConcurrent &lt;= 0，表现和上面分析的 <code>flatten</code> 相同。</p></li><li><p>maxConcurrent == 1，具体表现和之前<a href="https://chipengliu.github.io/2019/01/13/RACSignal-concat-zipWith/">文章</a>分析的 <code>concat</code> 一致。</p><p><img src="/2019/01/31/RACSignal-Operations-2/image-flatten-1.png" alt="image-20190204172830751"></p></li><li><p>maxConcurrent &gt; 1，当 activeDisposables.count &lt; maxConcurrent，activeDisposables.count &gt; 1表现和 <code>-flatten</code> 类似，activeDisposables.count == 1 则跟 <code>-concat</code> 类似；当 activeDisposables.count &gt;= maxConcurrent，子信号被保存在 queuedSignals 数组中；若</p></li></ol><h3 id="merge"><a href="#merge" class="headerlink" title="+merge:"></a>+merge:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testMerge &#123;</span><br><span class="line">    RACSignal *signal0 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal3 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *mergeSignal = [RACSignal merge:@[signal0, signal1, signal2, signal3]];</span><br><span class="line">    </span><br><span class="line">    [mergeSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value = 0</span><br><span class="line">value = 3</span><br><span class="line">value = 1</span><br><span class="line">value = 2</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)merge:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)signals &#123;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *copiedSignals = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"><span class="keyword">for</span> (RACSignal *signal <span class="keyword">in</span> signals) &#123;</span><br><span class="line">[copiedSignals addObject:signal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[[RACSignal</span><br><span class="line">createSignal:^ RACDisposable * (<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"><span class="keyword">for</span> (RACSignal *signal <span class="keyword">in</span> copiedSignals) &#123;</span><br><span class="line">[subscriber sendNext:signal];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;]</span><br><span class="line">flatten]</span><br><span class="line">setNameWithFormat:<span class="string">@"+merge: %@"</span>, copiedSignals];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>+merge: 方法的入参时一个实现 NSFastEnumeration 协议的容器对象，NSFastEnumeration 协议主要作用是使对象快速枚举的能力。</p><ol><li>函数内部会将容器内部所有的 RACSignal 对象加入到 copiedSignals 数组中，然后返回新的被flatten解包过的信号</li><li>当新信号被订阅的时候，就给会将保存在 copiedSignals 数组中 RACSignal 逐一发送给订阅者，之后的流程就进入 <code>-flatten</code> 函数的流程，这里不再重复</li></ol><h3 id="zip"><a href="#zip" class="headerlink" title="zip:"></a>zip:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testZip &#123;</span><br><span class="line">    RACSignal *signal0 = [RACSignal <span class="keyword">return</span>:@<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal2 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *zigSignal = [RACStream zip:@[signal0, signal1, signal2]];</span><br><span class="line">    </span><br><span class="line">    [zigSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@\n----------\n"</span>,x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [zigSignal subscribeCompleted:^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"zigSignal sendCompleted"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">value = &lt;RACTuple: 0x600000a0c810&gt; (</span><br><span class="line">    0,</span><br><span class="line">    1,</span><br><span class="line">    3</span><br><span class="line">)</span><br><span class="line">----------</span><br><span class="line"></span><br><span class="line">zigSignal sendCompleted</span><br></pre></td></tr></table></figure><p>底层实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (__kindof RACStream *)zip:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)streams &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> join:streams block:^(RACStream *left, RACStream *right) &#123;</span><br><span class="line"><span class="keyword">return</span> [left zipWith:right];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"+zip: %@"</span>, streams];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zip: 方法是通过封装 <code>+join:block:</code> 来实现</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">+ (__kindof RACStream *)join:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)streams block:(RACStream * (^)(<span class="keyword">id</span>, <span class="keyword">id</span>))block &#123;</span><br><span class="line">RACStream *current = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creates streams of successively larger tuples by combining the input</span></span><br><span class="line"><span class="comment">// streams one-by-one.</span></span><br><span class="line"><span class="keyword">for</span> (RACStream *stream <span class="keyword">in</span> streams) &#123;</span><br><span class="line"><span class="comment">// For the first stream, just wrap its values in a RACTuple. That way,</span></span><br><span class="line"><span class="comment">// if only one stream is given, the result is still a stream of tuples.</span></span><br><span class="line"><span class="keyword">if</span> (current == <span class="literal">nil</span>) &#123;</span><br><span class="line">current = [stream map:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="keyword">return</span> RACTuplePack(x);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">current = block(current, stream);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (current == <span class="literal">nil</span>) <span class="keyword">return</span> [<span class="keyword">self</span> empty];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [current map:^(RACTuple *xs) &#123;</span><br><span class="line"><span class="comment">// Right now, each value is contained in its own tuple, sorta like:</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// (((1), 2), 3)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// We need to unwrap all the layers and create a tuple out of the result.</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *values = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (xs != <span class="literal">nil</span>) &#123;</span><br><span class="line">[values insertObject:xs.last ?: RACTupleNil.tupleNil atIndex:<span class="number">0</span>];</span><br><span class="line">xs = (xs.count &gt; <span class="number">1</span> ? xs.first : <span class="literal">nil</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACTuple tupleWithObjectsFromArray:values];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>+join:block:</code> 第一个参数是一个可以进行枚举 RACStream 容器，也就是测试代码中传入的数组 @[signal0, signal1, signal2]，然后一次进行下面的处理：</p><ol><li><p>首先对传入数组进行遍历并执行对应信号的 <code>-map</code> 方法返回新的信号赋值给 current 变量，旨在把信号值转化 RACTuple 类型。第一个信号流打包成一个元组，这个元组里面就一个信号，然后把第一个元组和第二个信号通过参数 block 进行处理，block 内部是通过 <code>-zipWith:</code> 打包成新的<strong>元祖’</strong>，里面装着是第一个元组和第二个信号，然后循环此操作直至退出遍历</p></li><li><p>如果 current == nil 则直接返回空信号</p></li><li><p>对 current 进行执行 <code>-map:</code> 方法，主要作用是将步骤1中嵌套的<strong>元祖’</strong>（类似于(((1), 2), 3)) 取消嵌套层次，如(1, 2, 3)。需要注意的是 current 当前的结果是 RACTuple(RACTuple, value)，也就是说在  <code>-map:</code> 参数闭包触发的时候，闭包入参 xs 是一个 RACTwoTuple 类型对象，第一个元素是 RACTuple，第二个元素是一个值。在 while 循环中，先获取 last 元素，也就是值类型的元素，如果为nil，则以 RACTupleNil.tupleNil 替代插入数组的第0位，然后 xs 指向自己的 first 元素(RACTuple类型)，然后进入下一次循环，从而消除嵌套，并不改变 value 值得顺序保持到 values 数组中。</p></li><li><p>最后执行 <code>[RACTuple tupleWithObjectsFromArray:values]</code> 将数组转换成 RACTuple 类型</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)tupleWithObjectsFromArray:(<span class="built_in">NSArray</span> *)array &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> tupleWithObjectsFromArray:array convertNullsToNils:<span class="literal">NO</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)tupleWithObjectsFromArray:(<span class="built_in">NSArray</span> *)array convertNullsToNils:(<span class="built_in">BOOL</span>)convert &#123;</span><br><span class="line"><span class="keyword">if</span> (!convert) &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithBackingArray:array];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSMutableArray</span> *newArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:array.count];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">id</span> object <span class="keyword">in</span> array) &#123;</span><br><span class="line">[newArray addObject:(object == <span class="built_in">NSNull</span>.null ? RACTupleNil.tupleNil : object)];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithBackingArray:newArray];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>总结：zip: 函数主要是将多个信号发送的值”同步”地压缩打包成 RACTuple 发送给订阅者。这里”同步”是指压缩的时候需要等最迟发送的信号发送 sendNext 之后再发送给最终的订阅者，这里主要是依靠 <code>-zipWith:</code> 函数实现，在之前的<a href="https://chipengliu.github.io/2019/01/13/RACSignal-concat-zipWith/">文章</a>已经进行过分析，这里就不再重复。</p><h3 id="combineLatestWith"><a href="#combineLatestWith" class="headerlink" title="combineLatestWith:"></a>combineLatestWith:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testConbindLastWith &#123;</span><br><span class="line">    RACSignal *signal0 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *combineSig = [signal0 combineLatestWith:signal1];</span><br><span class="line">    [combineSig subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">value = &lt;RACTwoTuple: 0x600001aad2e0&gt; (</span><br><span class="line">    2,</span><br><span class="line">    3</span><br><span class="line">)</span><br><span class="line">value = &lt;RACTwoTuple: 0x600001ab6590&gt; (</span><br><span class="line">    2,</span><br><span class="line">    4</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>底层实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)combineLatestWith:(RACSignal *)signal &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(signal != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">__block <span class="keyword">id</span> lastSelfValue = <span class="literal">nil</span>;</span><br><span class="line">__block <span class="built_in">BOOL</span> selfCompleted = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">__block <span class="keyword">id</span> lastOtherValue = <span class="literal">nil</span>;</span><br><span class="line">__block <span class="built_in">BOOL</span> otherCompleted = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^sendNext)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (disposable) &#123;</span><br><span class="line"><span class="keyword">if</span> (lastSelfValue == <span class="literal">nil</span> || lastOtherValue == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line">[subscriber sendNext:RACTuplePack(lastSelfValue, lastOtherValue)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RACDisposable *selfDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (disposable) &#123;</span><br><span class="line">lastSelfValue = x ?: RACTupleNil.tupleNil;</span><br><span class="line">sendNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (disposable) &#123;</span><br><span class="line">selfCompleted = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">if</span> (otherCompleted) [subscriber sendCompleted];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">RACDisposable *otherDisposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (disposable) &#123;</span><br><span class="line">lastOtherValue = x ?: RACTupleNil.tupleNil;</span><br><span class="line">sendNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (disposable) &#123;</span><br><span class="line">otherCompleted = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">if</span> (selfCompleted) [subscriber sendCompleted];</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:otherDisposable];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -combineLatestWith: %@"</span>, <span class="keyword">self</span>.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要流程：</p><ol><li>定义 lastSelfValue 和 selfCompleted，前者判断原信号是否发送过 sendNext 事件，后者判断 原信号是否发送过 sendCompleted；同理 lastOtherValue 和 otherCompleted 是分别用来判断参数信号 signal 的是否发送过 sendNext 和 sendCompleted；</li><li>定义 sendNext 闭包，当原信号或者参数信号 signal 发送 sendNext 事件的时候，会执行这个闭包</li><li>订阅原信号，当原信号发送 sendNext，将信号值赋值给 lastSelfValue，若信号值为空则将 RACTupleNil.tupleNil 赋值给 lastSelfValue。执行 sendNext()，判断原信号和参数信号 signal 是否都执行过 sendNext，如果是则将 lastSelfValue 和 lastOtherValue 包装的 RACTuple 发给订阅者；否则就直接return。</li><li>若原信号发送 sendCompleted，则判断另一个信号（这里相对于原信号是参数信号 signal）是否已经发送过 sendCompleted，若是则给订阅者发送 sendCompleted 并结束整个订阅；如果原信号发送 sendError 则直接给订阅者发送 error 并结束整个订阅。</li><li>订阅参数型号 signal，针对 signal 重复步骤2-4。</li></ol><p>总结：combineLatestWith: 作用是收到原信号和参数信号的最新信号（必须是2个信号都收到）值打包成元组数据并发送给订阅者，需要注意的是当分别收到过这俩个信号发送的信号值之后，不管原信号还是参数信号，以后每次发送 sendNext，都会将最新的2个信号值打包成元组数据发送给订阅者。</p><p><img src="/2019/01/31/RACSignal-Operations-2/combineLatestWith.png" alt="image-20190207223805751"></p><h3 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest:"></a>combineLatest:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testCombineLatest &#123;</span><br><span class="line">    RACSignal *signal0 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *combineSignal = [RACSignal combineLatest:@[signal0, signal1]];</span><br><span class="line">    [combineSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">value = &lt;RACTuple: 0x600001aae1a0&gt; (</span><br><span class="line">    2,</span><br><span class="line">    3</span><br><span class="line">)</span><br><span class="line">value = &lt;RACTuple: 0x600001ab9760&gt; (</span><br><span class="line">    2,</span><br><span class="line">    4</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)combineLatest:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)signals &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> join:signals block:^(RACSignal *left, RACSignal *right) &#123;</span><br><span class="line"><span class="keyword">return</span> [left combineLatestWith:right];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"+combineLatest: %@"</span>, signals];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>combineLatest 是由 <code>-join:block:</code> 和 <code>-combineLatestWith:</code> 组合而成。主要分为以下几个步骤：</p><ol><li>传入 RACStream 信号的容器，遍历元素，调用 <code>-combineLatestWith:</code> ，将最终产生新的信号发送的值 value 包装成嵌套的 RACTuple(RACTuple, value) 类似结构。</li><li>把步骤1的嵌套 RACTuple 进行解嵌套成类似 RACTuple(value0,value1,value2) 的结构发给订阅者</li></ol><p>combineLatest: 可以基本步骤和 zip: 方法类似，主要区别可以简单的概括为：</p><ul><li>combineLatest: 如果传入的所有元素信号都发送过信号，其中一个元素信号发送了新的信号值的时候，就会把每一个元素信号发送过的最新信号值一起打包成 RACTuple 发给订阅者</li><li>zip: 如果传入的所有元素信号都发送过信号，当所有元素信号发送了新的信号值的时候把最新信号值一起打包成 RACTuple 发给订阅者</li></ul><h3 id="combineLatest-reduce"><a href="#combineLatest-reduce" class="headerlink" title="combineLatest:reduce:"></a>combineLatest:reduce:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testCombineLatestReduce &#123;</span><br><span class="line">    RACSignal *signal0 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *combineSignal = [RACSignal combineLatest:@[signal0, signal1] reduce:^<span class="keyword">id</span> _Nonnull (<span class="built_in">NSNumber</span> *num1, <span class="built_in">NSNumber</span> *num2) &#123;</span><br><span class="line">        <span class="keyword">return</span> @(num1.integerValue * <span class="number">10</span> + num2.integerValue);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [combineSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = 12</span><br><span class="line">value = 13</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)combineLatest:(<span class="keyword">id</span>&lt;<span class="built_in">NSFastEnumeration</span>&gt;)signals reduce:(RACGenericReduceBlock)reduceBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(reduceBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">RACSignal *result = [<span class="keyword">self</span> combineLatest:signals];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Although we assert this condition above, older versions of this method</span></span><br><span class="line"><span class="comment">// supported this argument being nil. Avoid crashing Release builds of</span></span><br><span class="line"><span class="comment">// apps that depended on that.</span></span><br><span class="line"><span class="keyword">if</span> (reduceBlock != <span class="literal">nil</span>) result = [result reduceEach:reduceBlock];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [result setNameWithFormat:<span class="string">@"+combineLatest: %@ reduce:"</span>, signals];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>+combineLatest:reduce:</code> 的实现和 <code>+zip:reduce:</code> 相似，先将调用 <code>+combineLastest:</code> 并传入参数 signals 返回新的 RACSignal 对象 result，result 执行 <code>-reduceEach:</code> 方法，将发送的 RACTuple 信号值根据 reduceBlock 闭包进行转换后再转发给最终的订阅者。</p><h3 id="scanWithStart-reduceWithIndex"><a href="#scanWithStart-reduceWithIndex" class="headerlink" title="scanWithStart:reduceWithIndex:"></a>scanWithStart:reduceWithIndex:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testScanWithStartReduceWithIndex &#123;</span><br><span class="line">    RACSignal *signal0 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *scanSignal = [signal0 scanWithStart:@<span class="number">10</span> reduceWithIndex:^<span class="keyword">id</span> _Nullable(<span class="built_in">NSNumber</span> *  _Nullable running, <span class="built_in">NSNumber</span> *  _Nullable next, <span class="built_in">NSUInteger</span> index) &#123;</span><br><span class="line">        <span class="keyword">return</span> @(running.integerValue + next.integerValue + index*<span class="number">10</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [scanSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = 11 // 10 + 1 + 0 * 10</span><br><span class="line">value = 23 // 11 + 2 + 1 * 10 </span><br><span class="line">value = 46 // 23 + 3 + 2 * 10</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)scanWithStart:(<span class="keyword">id</span>)startingValue reduceWithIndex:(<span class="keyword">id</span> (^)(<span class="keyword">id</span>, <span class="keyword">id</span>, <span class="built_in">NSUInteger</span>))reduceBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(reduceBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line">__block <span class="keyword">id</span> running = startingValue;</span><br><span class="line">__block <span class="built_in">NSUInteger</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">running = reduceBlock(running, value, index++);</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:running];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -scanWithStart: %@ reduceWithIndex:"</span>, <span class="keyword">self</span>.name, RACDescription(startingValue)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-scanWithStart:reduceWithIndex:</code> 内部是通过 <code>-bind:</code> 方法实现的，主要流程：</p><ol><li>断言判断传入 reduceBlock 是否为空，定义 <code>-bind</code> 入参闭包内部变量 running 和 index，running 的初始化值为函数入参 startingValue，index 的初始化值为0。</li><li>原信号发送信号值 value，执行函数入参 reduceBlock 闭包，并传入 running, value, index，执行完，running 会被重新赋值成 reduceBlock 的返回值且 index 加一。</li><li>调用原信号所属类的 <code>+return</code> 方法，返回新的信号，剩下的流程和之前文章介绍的 <code>-bind:</code> 方法一致，不再重复。</li></ol><p><img src="/2019/01/31/RACSignal-Operations-2/scanWithStart-reduceWithIndex-.png" alt="image-20190209201928966"></p><h3 id="scanWithStart-reduce"><a href="#scanWithStart-reduce" class="headerlink" title="scanWithStart:reduce:"></a>scanWithStart:reduce:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testScanWithStartReduce &#123;</span><br><span class="line">    RACSignal *signal0 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">10</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">100</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *scanSignal = [signal0 scanWithStart:@<span class="number">100</span> reduce:^<span class="keyword">id</span> _Nullable(<span class="built_in">NSNumber</span> *  _Nullable previous, <span class="built_in">NSNumber</span> *  _Nullable current) &#123;</span><br><span class="line">        <span class="keyword">return</span> @(previous.integerValue + current.integerValue);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [scanSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = 101</span><br><span class="line">value = 111</span><br><span class="line">value = 211</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)scanWithStart:(<span class="keyword">id</span>)startingValue reduce:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> running, <span class="keyword">id</span> next))reduceBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(reduceBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span></span><br><span class="line">scanWithStart:startingValue</span><br><span class="line">reduceWithIndex:^(<span class="keyword">id</span> running, <span class="keyword">id</span> next, <span class="built_in">NSUInteger</span> index) &#123;</span><br><span class="line"><span class="keyword">return</span> reduceBlock(running, next);</span><br><span class="line">&#125;]</span><br><span class="line">setNameWithFormat:<span class="string">@"[%@] -scanWithStart: %@ reduce:"</span>, <span class="keyword">self</span>.name, RACDescription(startingValue)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部是通过封装 <code>-scanWithStart:reduceWithIndex:</code> 来实现，主要区别在于 <code>scanWithStart:reduce</code> 的入参 reduceBlock 不传入 index，其他流程一致。</p><h3 id="combinePreviousWithStart-reduce"><a href="#combinePreviousWithStart-reduce" class="headerlink" title="combinePreviousWithStart:reduce:"></a>combinePreviousWithStart:reduce:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testCombinePreviousWithStartReduceBlock &#123;</span><br><span class="line">    RACSignal *signal0 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *combineSignal = [signal0 combinePreviousWithStart:@<span class="number">100</span> reduce:^<span class="keyword">id</span> _Nullable(<span class="built_in">NSNumber</span> *  _Nullable previous, <span class="built_in">NSNumber</span> *  _Nullable current) &#123;</span><br><span class="line">        <span class="keyword">return</span> @(previous.integerValue + current.integerValue);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [combineSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = 101</span><br><span class="line">value = 3</span><br><span class="line">value = 5</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)combinePreviousWithStart:(<span class="keyword">id</span>)start reduce:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> previous, <span class="keyword">id</span> next))reduceBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(reduceBlock != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> [[[<span class="keyword">self</span></span><br><span class="line">scanWithStart:RACTuplePack(start)</span><br><span class="line">reduce:^(RACTuple *previousTuple, <span class="keyword">id</span> next) &#123;</span><br><span class="line"><span class="keyword">id</span> value = reduceBlock(previousTuple[<span class="number">0</span>], next);</span><br><span class="line"><span class="keyword">return</span> RACTuplePack(next, value);</span><br><span class="line">&#125;]</span><br><span class="line">map:^(RACTuple *tuple) &#123;</span><br><span class="line"><span class="keyword">return</span> tuple[<span class="number">1</span>];</span><br><span class="line">&#125;]</span><br><span class="line">setNameWithFormat:<span class="string">@"[%@] -combinePreviousWithStart: %@ reduce:"</span>, <span class="keyword">self</span>.name, RACDescription(start)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法是通过封装 <code>-scanWithStart:reduce:</code> 和 <code>-map</code> 实现，基于这个基础，<code>-combinePreviousWithStart:reduce:</code> 大致要经过这样的流程：</p><ol><li>将入参 start 包装成 RACTuple 传入给 <code>-scanWithStart:reduce:</code> 并在其闭包中第一次拿到的 previousTuple 就是 RACTuple(start)，此时的 next 就是原信号的第一个信号值（测试代码中的@1）。然后执行 <code>-combinePreviousWithStart:reduce:</code> 入参 reduceBlock，传入 next 和 previousTuple[0]，返回值赋值给 value，最后将 next 和 value 包装成 RACTuple 返回（需要注意这里next是保存在RACTuple的第0位元素）。后续原信号每发一次新信号值都会重复这个步骤。</li><li><p>步骤1返回的新信号进行 map 操作，取出步骤1的 reduceBlock 处理返回的value 发给订阅者</p><p><code>-combinePreviousWithStart:reduce:</code> 是对俩俩原信号的原始信号值进行处理； <code>-scanWithStart:reduce:</code> 俩俩原始信号值处理结果会和下一个新的原始信号值进行下一轮的处理。</p></li></ol><h3 id="sample"><a href="#sample" class="headerlink" title="sample:"></a>sample:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testSample &#123;</span><br><span class="line">    RACSignal *signal0 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"signal0 disposed"</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:^RACDisposable * _Nullable(<span class="keyword">id</span>&lt;RACSubscriber&gt;  _Nonnull subscriber) &#123;</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:<span class="string">@"A"</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@"B"</span>];</span><br><span class="line">            [subscriber sendNext:<span class="string">@"C"</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"signal1 disposed"</span>);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *sampleSignal = [signal0 sample:signal1];</span><br><span class="line">    </span><br><span class="line">    [sampleSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value = 3</span><br><span class="line">value = 3</span><br><span class="line">value = 3</span><br><span class="line">signal1 disposed</span><br><span class="line">signal0 disposed</span><br></pre></td></tr></table></figure><p>底层实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)sample:(RACSignal *)sampler &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(sampler != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"><span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">__block <span class="keyword">id</span> lastValue;</span><br><span class="line">__block <span class="built_in">BOOL</span> hasValue = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">RACSerialDisposable *samplerDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">RACDisposable *sourceDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">[lock lock];</span><br><span class="line">hasValue = <span class="literal">YES</span>;</span><br><span class="line">lastValue = x;</span><br><span class="line">[lock unlock];</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[samplerDisposable dispose];</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[samplerDisposable dispose];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">samplerDisposable.disposable = [sampler subscribeNext:^(<span class="keyword">id</span> _) &#123;</span><br><span class="line"><span class="built_in">BOOL</span> shouldSend = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">id</span> value;</span><br><span class="line">[lock lock];</span><br><span class="line">shouldSend = hasValue;</span><br><span class="line">value = lastValue;</span><br><span class="line">[lock unlock];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (shouldSend) &#123;</span><br><span class="line">[subscriber sendNext:value];</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[sourceDisposable dispose];</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[sourceDisposable dispose];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[samplerDisposable dispose];</span><br><span class="line">[sourceDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -sample: %@"</span>, <span class="keyword">self</span>.name, sampler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现逻辑和之前的 <code>-combineLatestWith:</code> 有点异曲同工，主要为以下几个步骤：</p><ol><li>定义变量 lastValue 用来记录原信号最后此发送的信号值，hasValue 判断原信号是否已经发送过信号值，lock 用于保证 lastValue/hasValue 的线程安全</li><li>订阅原信号，当其发送 sendNext 的时候，lastValue 赋值为发送的信号值，shouldSend = YES</li><li>当原信号发送 sendCompleted/sendError，先结束 sampler 的订阅再给订阅者发送sendCompleted/sendError</li><li>订阅 sampler 信号，当其发送 sendNext 的时候，如果 shouldSend == YES，则将 lastValue 发送给最终的订阅者</li><li>当 sampler 信号发送 sendCompleted/sendError，先结束原信号的订阅再给订阅者发送sendCompleted/sendError</li></ol><p><img src="/2019/01/31/RACSignal-Operations-2/sample.png" alt="image-20190209230053730"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactiveCocoa </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RACSignal常用方法深入分析(1)</title>
      <link href="/2019/01/20/RACSignal-Operations/"/>
      <url>/2019/01/20/RACSignal-Operations/</url>
      
        <content type="html"><![CDATA[<p>ReactiveCocoa 框架 RACSignal+Operations.h 定义了 RACSignal 常规操作方法，接下来对一些常用的方法进行分析并解析其作用。</p><a id="more"></a><h3 id="doNext"><a href="#doNext" class="headerlink" title="doNext"></a>doNext</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testDoNext &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:<span class="string">@"source signal"</span>];</span><br><span class="line">        </span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[sourceSignal doNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"sourceSignal doNext will execute before sendNext"</span>);</span><br><span class="line">    &#125;] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sourceSignal doNext will execute before sendNext</span><br><span class="line">value = source signal</span><br></pre></td></tr></table></figure><p>底层实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)doNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">block(x);</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -doNext:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>doNext 传入block 闭包，该闭包的参数就是原信号发送的值，当给订阅者发送 sendNext 之前会执行 block 闭包</p><p>类似的 doError，doCompleted 也是在给订阅者发送事件之前就执行相关 block</p><h3 id="throttle-valuesPassingTest"><a href="#throttle-valuesPassingTest" class="headerlink" title="throttle:valuesPassingTest:"></a>throttle:valuesPassingTest:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testThrottleValuesPassingTest &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            </span><br><span class="line">            [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">            [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *throttleSignal = [sourceSignal throttle:<span class="number">1</span> valuesPassingTest:^<span class="built_in">BOOL</span>(<span class="keyword">id</span>  _Nullable next) &#123;</span><br><span class="line">        <span class="keyword">return</span> [next integerValue] &lt;= <span class="number">2</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [throttleSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = 1</span><br><span class="line">value = 3</span><br></pre></td></tr></table></figure><p>throttle:valuesPassingTest: 方法有2个参数：</p><ul><li>时间间隔 <code>interval</code></li><li>判断条件闭包 <code>predicate</code></li></ul><p>该方法大概作用是：从原信号发出第一个信号(@0)发出开始计时，在 <code>interval</code> 秒内如果第二个信号(@1) 符合 predicate 的判断条件，则该前一个信号会被忽略；如果2个信号间隔时间超过  <code>interval</code> 秒或者不满足 predicate 判断，则前一个信号会发给订阅者。</p><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)throttle:(<span class="built_in">NSTimeInterval</span>)interval valuesPassingTest:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> next))predicate &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(interval &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(predicate != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line"><span class="comment">// We may never use this scheduler, but we need to set it up ahead of</span></span><br><span class="line"><span class="comment">// time so that our scheduled blocks are run serially if we do.</span></span><br><span class="line">RACScheduler *scheduler = [RACScheduler scheduler];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Information about any currently-buffered `next` event.</span></span><br><span class="line">__block <span class="keyword">id</span> nextValue = <span class="literal">nil</span>;</span><br><span class="line">__block <span class="built_in">BOOL</span> hasNextValue = <span class="literal">NO</span>;</span><br><span class="line">RACSerialDisposable *nextDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^flushNext)(<span class="built_in">BOOL</span> send) = ^(<span class="built_in">BOOL</span> send) &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (compoundDisposable) &#123;</span><br><span class="line">[nextDisposable.disposable dispose];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!hasNextValue) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (send) [subscriber sendNext:nextValue];</span><br><span class="line"></span><br><span class="line">nextValue = <span class="literal">nil</span>;</span><br><span class="line">hasNextValue = <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">RACScheduler *delayScheduler = RACScheduler.currentScheduler ?: scheduler;</span><br><span class="line"><span class="built_in">BOOL</span> shouldThrottle = predicate(x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@synchronized</span> (compoundDisposable) &#123;</span><br><span class="line">flushNext(<span class="literal">NO</span>);</span><br><span class="line"><span class="keyword">if</span> (!shouldThrottle) &#123;</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nextValue = x;</span><br><span class="line">hasNextValue = <span class="literal">YES</span>;</span><br><span class="line">nextDisposable.disposable = [delayScheduler afterDelay:interval schedule:^&#123;</span><br><span class="line">flushNext(<span class="literal">YES</span>);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[compoundDisposable dispose];</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">flushNext(<span class="literal">YES</span>);</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[compoundDisposable addDisposable:subscriptionDisposable];</span><br><span class="line"><span class="keyword">return</span> compoundDisposable;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -throttle: %f valuesPassingTest:"</span>, <span class="keyword">self</span>.name, (<span class="keyword">double</span>)interval];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>throttle:valuesPassingTest: 内部主要通过判断 <code>nextValue</code> 和 <code>hasNextValue</code> 2个变量的状态来判断是否给订阅者发送信号。内部先订阅原信号，然后触发订阅者的 didSubscribe，结合测试代码，具体流程:</p><ol><li>收到原信号发出的信号 <code>@0</code>，传入到条件闭包 predicate，返回 YES</li><li>RACCompoundDisposable 作为线程间互斥信号量，用 @synchronized 加锁保证  <code>nextValue</code>  和  <code>hasNextValue</code> 操作是原子性</li><li>执行 flushNext(NO) ，把 nextDisposable 进行 dispose，delayScheduler 之前存放的延迟任务如果未被执行会被取消；hasNextValue == NO，直接 return，没有给订阅者发送0</li><li>判断 !shouldThrottle，跳过 if 内部代码，给 nextValue 和 hasNextValue 赋值，nextValue=@0，hasNextValue = YES</li><li>把 flushNext(YES) 加入到延迟队列中，1秒后执行</li><li>原信号发送 @1，此时时间间隔不到 1秒，从步骤3开始重复上述步骤；flushNext(NO) 中 延迟任务被取消， <code>nextValue</code> 和 <code>hasNextValue</code> 会赋值为对应 零值。shouldThrottle 符合，<code>nextValue</code> 和 <code>hasNextValue</code>  又被赋值到 @1 和 YES，保存新的 flushNext(YES) 到延迟任务队列中</li><li>1秒后还没有收到原信号发送的信号，执行步骤6保存的 flushNext(YES)，把 @1 发给订阅者；2秒后收到原信号的信号 @2，从步骤3开始重复上述步骤，@2会被保存到  <code>hasNextValue</code>  中，等待下一次延迟任务可以触发的时候发给订阅者，反之被忽略</li><li>步骤7完之后马上收到新的信号@3，从步骤3开始重复上述步骤，步骤7保存的 flushNext(YES) 被取消，因为此时不符合 predicate 判断条件，@3发给订阅者</li></ol><h3 id="delay"><a href="#delay" class="headerlink" title="delay:"></a>delay:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testDelay &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[sourceSignal delay:<span class="number">1</span>] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, [<span class="built_in">NSDate</span> date]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-31</span> <span class="number">09</span>:<span class="number">34</span>:<span class="number">33.286371</span>+<span class="number">0800</span> AppTest[<span class="number">38331</span>:<span class="number">4774309</span>] Thu Jan <span class="number">31</span> <span class="number">09</span>:<span class="number">34</span>:<span class="number">33</span> <span class="number">2019</span></span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-31</span> <span class="number">09</span>:<span class="number">34</span>:<span class="number">34.380736</span>+<span class="number">0800</span> AppTest[<span class="number">38331</span>:<span class="number">4774309</span>] value = <span class="number">0</span></span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-31</span> <span class="number">09</span>:<span class="number">34</span>:<span class="number">34.380881</span>+<span class="number">0800</span> AppTest[<span class="number">38331</span>:<span class="number">4774309</span>] value = <span class="number">1</span></span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-31</span> <span class="number">09</span>:<span class="number">34</span>:<span class="number">34.380986</span>+<span class="number">0800</span> AppTest[<span class="number">38331</span>:<span class="number">4774309</span>] value = <span class="number">2</span></span><br><span class="line"><span class="number">2019</span><span class="number">-01</span><span class="number">-31</span> <span class="number">09</span>:<span class="number">34</span>:<span class="number">34.381076</span>+<span class="number">0800</span> AppTest[<span class="number">38331</span>:<span class="number">4774309</span>] value = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>delay: 方法是将原信号的信号事件延迟发送给订阅者</p><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)delay:(<span class="built_in">NSTimeInterval</span>)interval &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line"><span class="comment">// We may never use this scheduler, but we need to set it up ahead of</span></span><br><span class="line"><span class="comment">// time so that our scheduled blocks are run serially if we do.</span></span><br><span class="line">RACScheduler *scheduler = [RACScheduler scheduler];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^schedule)(dispatch_block_t) = ^(dispatch_block_t block) &#123;</span><br><span class="line">RACScheduler *delayScheduler = RACScheduler.currentScheduler ?: scheduler;</span><br><span class="line">RACDisposable *schedulerDisposable = [delayScheduler afterDelay:interval schedule:block];</span><br><span class="line">[disposable addDisposable:schedulerDisposable];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">schedule(^&#123;</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125;);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">schedule(^&#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:subscriptionDisposable];</span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -delay: %f"</span>, <span class="keyword">self</span>.name, (<span class="keyword">double</span>)interval];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delay: 内部首先先定义 schedule ，其参数是 dispatch_block_t，执行 schedule 的时候，会把参数 block 放到 RACScheduler 延迟 interval 秒触发。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)afterDelay:(<span class="built_in">NSTimeInterval</span>)delay schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> after:[<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:delay] schedule:block];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (RACDisposable *)after:(<span class="built_in">NSDate</span> *)date schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(date != <span class="literal">nil</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">RACDisposable *disposable = [[RACDisposable alloc] init];</span><br><span class="line"></span><br><span class="line">dispatch_after([<span class="keyword">self</span>.class wallTimeWithDate:date], <span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line"><span class="keyword">if</span> (disposable.disposed) <span class="keyword">return</span>;</span><br><span class="line">[<span class="keyword">self</span> performAsCurrentScheduler:block];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据测试代码，最终会调用 RACQueueScheduler 中的 <code>-after:schedule:</code>，在该方法里面，通过 dispatch_after 来触发入参 block，触发先前会先判断该任务是否被 disposed ，如果是则直接 return。</p><p>归纳来说，delay: 方法就是将原信号的 sendNext 和 sendCompleted 事件延迟 <code>interval</code> 秒发送给订阅者。</p><h3 id="bufferWithTime-onScheduler"><a href="#bufferWithTime-onScheduler" class="headerlink" title="bufferWithTime:onScheduler:"></a>bufferWithTime:onScheduler:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBufferWithTime &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *bufferSignal = [sourceSignal bufferWithTime:<span class="number">1</span> onScheduler:[RACScheduler currentScheduler]];</span><br><span class="line">    [bufferSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value = &lt;RACTuple: 0x600000003200&gt; (</span><br><span class="line">    0,</span><br><span class="line">    1,</span><br><span class="line">    2,</span><br><span class="line">    3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)bufferWithTime:(<span class="built_in">NSTimeInterval</span>)interval onScheduler:(RACScheduler *)scheduler &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(scheduler != <span class="literal">nil</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(scheduler != RACScheduler.immediateScheduler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACSerialDisposable *timerDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *values = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^flushValues)() = ^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (values) &#123;</span><br><span class="line">[timerDisposable.disposable dispose];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (values.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">RACTuple *tuple = [RACTuple tupleWithObjectsFromArray:values];</span><br><span class="line">[values removeAllObjects];</span><br><span class="line">[subscriber sendNext:tuple];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RACDisposable *selfDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (values) &#123;</span><br><span class="line"><span class="keyword">if</span> (values.count == <span class="number">0</span>) &#123;</span><br><span class="line">timerDisposable.disposable = [scheduler afterDelay:interval schedule:flushValues];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[values addObject:x ?: RACTupleNil.tupleNil];</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">flushValues();</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">[selfDisposable dispose];</span><br><span class="line">[timerDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -bufferWithTime: %f onScheduler: %@"</span>, <span class="keyword">self</span>.name, (<span class="keyword">double</span>)interval, scheduler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样 bufferWithTime:onScheduler: 内部还会创建新的信号，当新的信号被订阅的时候会创建可变数组 values 。然后定义闭包 flushValues，当收到原信号的 sendNext 和 sendCompleted 的时候会触发该闭包。</p><p>之后对原信号进行订阅，首先收到原信号的 sendNext 事件的时候，先判断 values 的元素个数，如果个数为 0，则把 flushValues 延迟 <code>interval</code> 秒触发。然后把信号值加入 values 数组中，如果信号值为空，则把 RACTupleNil.tupleNil 加入数组中。</p><p>因为测试代码中，@0、@1、@2、@3 四个信号是连续串行发出，所以之前被加入延迟队列中执行的 flushValues 还没有触发的时候，当原信号发送 sendCompleted 的时候，flushValues 会被触发，这时候 values 四个元素被一次性包装成 RACTuple 发送给订阅者。</p><p>如果把测试代码修改成：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testBufferWithTime2 &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">            [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">            dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">2</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [subscriber sendCompleted];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *bufferSignal = [sourceSignal bufferWithTime:<span class="number">1</span> onScheduler:[RACScheduler currentScheduler]];</span><br><span class="line">    [bufferSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">value = &lt;RACTuple: <span class="number">0x604000204300</span>&gt; (</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">)</span><br><span class="line">value = &lt;RACTuple: <span class="number">0x600000019300</span>&gt; (</span><br><span class="line">    <span class="number">2</span>,</span><br><span class="line">    <span class="number">3</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>订阅者此时会受到2个信号，都是 RACTuple 类型，回到之前的实现代码，</p><ol><li>收到 @0，flushValues() 加入延迟队列1秒之后执行，@0 再加入到数组 values 中</li><li>步骤1之后马上收到 @1（1秒内），重复步骤1，这时候延迟队列中有2个任务</li><li>1秒后，第一个加入延迟队列的 flushValues() 执行，首先执行了 <code>[timerDisposable.disposable dispose];</code> ，这样会将延迟队列中下一个  flushValues() 任务被取消（步骤2加入的）。然后 values 元素包装成 RACTuple 发送给订阅者。</li><li>基于步骤3，再过一秒，也就是从一开始算，2秒过后。收到@2，然后重复步骤，逻辑相似</li><li>最后再过2秒，原信号发送 sendCompleted，执行 flushValues() ，values 元素个数为0，直接返回。</li></ol><p>总结：bufferWithTime:onScheduler: 作用是将规定时间内将原信号所发送的全部信号包装成 RACTupe 发送给订阅者</p><h3 id="timeout-onScheduler"><a href="#timeout-onScheduler" class="headerlink" title="timeout:onScheduler:"></a>timeout:onScheduler:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testTimeout &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">0</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(<span class="number">1</span> * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">            [subscriber sendCompleted];</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *timeoutSig = [sourceSignal timeout:<span class="number">1</span> onScheduler:[RACScheduler currentScheduler]];</span><br><span class="line">    [timeoutSig subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [timeoutSig subscribeError:^(<span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"error = %@"</span>, error);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value = 0</span><br><span class="line">value = 1</span><br><span class="line">value = 2</span><br><span class="line">error = Error Domain=RACSignalErrorDomain Code=1 "(null)"</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)timeout:(<span class="built_in">NSTimeInterval</span>)interval onScheduler:(RACScheduler *)scheduler &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(scheduler != <span class="literal">nil</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(scheduler != RACScheduler.immediateScheduler);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">RACDisposable *timeoutDisposable = [scheduler afterDelay:interval schedule:^&#123;</span><br><span class="line">[disposable dispose];</span><br><span class="line">[subscriber sendError:[<span class="built_in">NSError</span> errorWithDomain:RACSignalErrorDomain code:RACSignalErrorTimedOut userInfo:<span class="literal">nil</span>]];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:timeoutDisposable];</span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[disposable dispose];</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[disposable dispose];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:subscriptionDisposable];</span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -timeout: %f onScheduler: %@"</span>, <span class="keyword">self</span>.name, (<span class="keyword">double</span>)interval, scheduler];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>timeout:onScheduler: 判断从被订阅开始计时， <code>interval</code> 时间内如果原信号没有把所有信号发送完毕会给订阅者发送 error。</p><p>首先创建新的信号，新信号被订阅的时候在延迟队列里面加入任务， <code>interval</code>  后该任务会将 NSError 发送给订阅者。如果在  <code>interval</code>  内原型号发送了 sendCompleted/sendError，会执行 <code>[disposable dispose];</code>，延迟队列中的任务会被取消。同样如果延迟任务被触发，原信号的订阅也被终止。</p><h3 id="map"><a href="#map" class="headerlink" title="map:"></a>map:</h3><p>测试代码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码1 */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)testMap &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[sourceSignal map:^<span class="keyword">id</span> _Nullable(<span class="keyword">id</span>  _Nullable value) &#123;</span><br><span class="line">        <span class="comment">// BLOCK 1</span></span><br><span class="line">        <span class="keyword">return</span> @([value integerValue] + <span class="number">1</span>);</span><br><span class="line">    &#125;] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = 2</span><br><span class="line">value = 3</span><br><span class="line">value = 4</span><br></pre></td></tr></table></figure><p>底层实现:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码2 */</span></span><br><span class="line"></span><br><span class="line">- (__kindof RACStream *)map:(<span class="keyword">id</span> (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^(<span class="keyword">id</span> value) &#123;</span><br><span class="line">        <span class="comment">// BLOCK 2</span></span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:block(value)];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -map:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>map 的参数一个参数类型为id，返回值类型也为id的block，内部实现首先通过断言判断 block 是否为空，然后调用 flattenMap 方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码3 */</span></span><br><span class="line"></span><br><span class="line">- (__kindof RACStream *)flattenMap:(__kindof RACStream * (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> bind:^&#123;</span><br><span class="line"><span class="keyword">return</span> ^(<span class="keyword">id</span> value, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="comment">// BLOCK 3</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">id</span> stream = block(value) ?: [<span class="keyword">class</span> empty];</span><br><span class="line"><span class="built_in">NSCAssert</span>([stream isKindOfClass:RACStream.class], <span class="string">@"Value returned from -flattenMap: is not a stream: %@"</span>, stream);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> stream;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -flattenMap:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flattenMap 是通过封装 bind 方法实现，bind的入参是 RACStreamBindBlock 类型闭包，flattenMap 的入参是一个入参类型为 id，返回值为 RACStream 的闭包</p><p>在 flattenMap 中，先判断 block(value) 返回的信号是否为nil，若是则返对应class 的empty 信号，也就是 RACEmptySignal 对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+ (RACSignal *)empty &#123;</span><br><span class="line"><span class="meta">#ifdef DEBUG</span></span><br><span class="line"><span class="comment">// Create multiple instances of this class in DEBUG so users can set custom</span></span><br><span class="line"><span class="comment">// names on each.</span></span><br><span class="line"><span class="keyword">return</span> [[[<span class="keyword">self</span> alloc] init] setNameWithFormat:<span class="string">@"+empty"</span>];</span><br><span class="line"><span class="meta">#else</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> singleton;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> pred;</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;pred, ^&#123;</span><br><span class="line">singleton = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> singleton;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从实现代码上来看，RACEmptySignal 是以单例对象的形式返回</p><p>RACEmptySignal.m 文件里还重写了 <code>-subscribe</code>:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(subscriber != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACEmptySignal 信号被订阅之后会马上给订阅者发送 sendCompleted 事件</p><p>回到 flattenMap 的实现逻辑中，如果 block(value)  返回不是nil，它是如何返回 RACStream 对象的呢？</p><p>执行 block(value) 实际上就是触发 代码2 中的 <code>BLOCK 2</code></p><p>在 <code>BLOCK 2</code>  中，又会触发另个 block(value)，这时候会触发代码1中的 <code>BLOCK 1</code>，这里 block(value) 会返回相关对象（测试代码中返回NSNumber），<code>BLOCK 2</code> 中将 NSNumber 包装成 RACReturnSignal 返回，此时在 <code>BLOCK 3</code>  stream 对象就是 RACReturnSignal。</p><p>最后通过 bind 函数的变换，订阅会收到变换过后的值。</p><p><img src="/2019/01/20/RACSignal-Operations/image-20190126201245265.png" alt="image-20190126201245265"></p><h3 id="mapReplace"><a href="#mapReplace" class="headerlink" title="mapReplace"></a>mapReplace</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testMapReplace &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[sourceSignal mapReplace:@(<span class="number">10</span>)] subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">         <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = 10</span><br><span class="line">value = 10</span><br><span class="line">value = 10</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)mapReplace:(<span class="keyword">id</span>)object &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> map:^(<span class="keyword">id</span> _) &#123;</span><br><span class="line"><span class="keyword">return</span> object;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -mapReplace: %@"</span>, <span class="keyword">self</span>.name, RACDescription(object)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapReplace 是通过封装 map 方法实现，把原信号每一个事件都变换成参数 object 传递给订阅者</p><h3 id="reduceEach"><a href="#reduceEach" class="headerlink" title="reduceEach"></a>reduceEach</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testReduceEach &#123;</span><br><span class="line">    RACSignal *signal1 = [RACSignal createSignal:</span><br><span class="line">                          ^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">                          &#123;</span><br><span class="line">                              [subscriber sendNext:RACTuplePack(@<span class="number">1</span>,@<span class="number">2</span>)];</span><br><span class="line">                              [subscriber sendNext:RACTuplePack(@<span class="number">3</span>,@<span class="number">4</span>)];</span><br><span class="line">                              [subscriber sendNext:RACTuplePack(@<span class="number">5</span>,@<span class="number">6</span>)];</span><br><span class="line">                              [subscriber sendCompleted];</span><br><span class="line">                              <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                                  <span class="built_in">NSLog</span>(<span class="string">@"signal1 dispose"</span>);</span><br><span class="line">                              &#125;];</span><br><span class="line">                          &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *signal2 = [signal1 reduceEach:^<span class="keyword">id</span> (<span class="built_in">NSNumber</span> *num1 , <span class="built_in">NSNumber</span> *num2)&#123;</span><br><span class="line">        <span class="keyword">return</span> @([num1 intValue] + [num2 intValue]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [signal2 subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value = 3</span><br><span class="line">value = 7</span><br><span class="line">value = 11</span><br><span class="line">signal1 dispose</span><br></pre></td></tr></table></figure><p>从输出结果看出来，reduceEach 将原信号 signal1 发送的 RACTuple 数据进行解包聚合发送给订阅者</p><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码4 */</span></span><br><span class="line"></span><br><span class="line">- (__kindof RACStream *)reduceEach:(RACReduceBlock)reduceBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(reduceBlock != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">__<span class="keyword">weak</span> RACStream *stream __attribute__((unused)) = <span class="keyword">self</span>;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> map:^(RACTuple *t) &#123;</span><br><span class="line">        <span class="comment">// BLOCK 1</span></span><br><span class="line"><span class="built_in">NSCAssert</span>([t isKindOfClass:RACTuple.class], <span class="string">@"Value from stream %@ is not a tuple: %@"</span>, stream, t);</span><br><span class="line"><span class="keyword">return</span> [RACBlockTrampoline invokeBlock:reduceBlock withArguments:t];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -reduceEach:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>reduceEach 也是通过封装 map 方法实现。reduceEach 方法的入参是 RACReduceBlock 类型的闭包</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">id</span> _Nonnull (^RACReduceBlock)();</span><br></pre></td></tr></table></figure><p>首先通过断言判断 reduceBlock 闭包是否为nil，然后调用 map 方法，map 方法的入参也就是 <code>BLOCK 1</code>，在  <code>BLOCK 1</code> 里会先判断原信号 signal 发送的数据 t 是否为 RACTuple 类型，然后返回 RACBlockTrampoline 类型对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACBlockTrampoline</span> ()</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="keyword">id</span> block;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>RACBlockTrampoline 内部会保存一个 block 对象，然后根据传进来的参数，动态的构造一个 NSInvocation，通过执行 NSInvocation 返回需要的数据。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)invokeWithArguments:(RACTuple *)arguments &#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">SEL selector = [<span class="keyword">self</span> selectorForArgumentCount:arguments.count];</span><br><span class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:[<span class="keyword">self</span> methodSignatureForSelector:selector]];</span><br><span class="line">invocation.selector = selector;</span><br><span class="line">invocation.target = <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; arguments.count; i++) &#123;</span><br><span class="line"><span class="keyword">id</span> arg = arguments[i];</span><br><span class="line"><span class="built_in">NSInteger</span> argIndex = (<span class="built_in">NSInteger</span>)(i + <span class="number">2</span>);</span><br><span class="line">[invocation setArgument:&amp;arg atIndex:argIndex];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[invocation invoke];</span><br><span class="line"></span><br><span class="line">__<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> returnVal;</span><br><span class="line">[invocation getReturnValue:&amp;returnVal];</span><br><span class="line"><span class="keyword">return</span> returnVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (SEL)selectorForArgumentCount:(<span class="built_in">NSUInteger</span>)count &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(count &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (count) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">return</span> <span class="keyword">@selector</span>(performWith:);</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">return</span> <span class="keyword">@selector</span>(performWith::);</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">return</span> <span class="keyword">@selector</span>(performWith:::);</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="keyword">return</span> <span class="keyword">@selector</span>(performWith::::);</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">return</span> <span class="keyword">@selector</span>(performWith:::::);</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: <span class="keyword">return</span> <span class="keyword">@selector</span>(performWith::::::);</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: <span class="keyword">return</span> <span class="keyword">@selector</span>(performWith:::::::);</span><br><span class="line"><span class="keyword">case</span> <span class="number">8</span>: <span class="keyword">return</span> <span class="keyword">@selector</span>(performWith::::::::);</span><br><span class="line"><span class="keyword">case</span> <span class="number">9</span>: <span class="keyword">return</span> <span class="keyword">@selector</span>(performWith:::::::::);</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>: <span class="keyword">return</span> <span class="keyword">@selector</span>(performWith::::::::::);</span><br><span class="line"><span class="keyword">case</span> <span class="number">11</span>: <span class="keyword">return</span> <span class="keyword">@selector</span>(performWith:::::::::::);</span><br><span class="line"><span class="keyword">case</span> <span class="number">12</span>: <span class="keyword">return</span> <span class="keyword">@selector</span>(performWith::::::::::::);</span><br><span class="line"><span class="keyword">case</span> <span class="number">13</span>: <span class="keyword">return</span> <span class="keyword">@selector</span>(performWith:::::::::::::);</span><br><span class="line"><span class="keyword">case</span> <span class="number">14</span>: <span class="keyword">return</span> <span class="keyword">@selector</span>(performWith::::::::::::::);</span><br><span class="line"><span class="keyword">case</span> <span class="number">15</span>: <span class="keyword">return</span> <span class="keyword">@selector</span>(performWith:::::::::::::::);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSCAssert</span>(<span class="literal">NO</span>, <span class="string">@"The argument count is too damn high! Only blocks of up to 15 arguments are currently supported."</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)performWith:(<span class="keyword">id</span>)obj1 :(<span class="keyword">id</span>)obj2 &#123;</span><br><span class="line"><span class="keyword">id</span> (^block)(<span class="keyword">id</span>, <span class="keyword">id</span>) = <span class="keyword">self</span>.block;</span><br><span class="line"><span class="keyword">return</span> block(obj1, obj2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>-invokeWithArguments</code> 中首先通过判断 RACTuple 元素数量选择对应的 selector，最大能支持 15 个元素。</p><p>确定好 NSInvocation 的 target 和 seletor，还需要设置参数</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; arguments.count; i++) &#123;</span><br><span class="line">    <span class="keyword">id</span> arg = arguments[i];</span><br><span class="line">    <span class="built_in">NSInteger</span> argIndex = (<span class="built_in">NSInteger</span>)(i + <span class="number">2</span>);</span><br><span class="line">    [invocation setArgument:&amp;arg atIndex:argIndex];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到设置 <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html" target="_blank" rel="noopener">Type Encodings</a> 的时候是从偏移量为 2开始，这是因为偏移量0和 偏移量1的参数分别对应着<strong>隐藏参数</strong>self 和 _cmd。</p><p>构造好 invocation 之后，执行 <code>[invocation invoke]</code> 调用动态方法，实际上就是执行代码4中的入参 reduceBlock 闭包，最后通过 <code>[invocation getReturnValue:&amp;returnVal]</code> 拿到闭包的返回值，也就是 RACBlockTrampoline 的最终返回值，最终成为 map 闭包里面的返回值。剩下的就是 map 函数流程。</p><h3 id="or"><a href="#or" class="headerlink" title="or"></a>or</h3><p>测试代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:RACTuplePack(@NO,@YES,@NO)];</span><br><span class="line">    [subscriber sendNext:RACTuplePack(@YES,@NO)];</span><br><span class="line"></span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *orSignal = [sourceSignal or];</span><br><span class="line">[orSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = 1</span><br><span class="line">value = 1</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)or &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> map:^(RACTuple *tuple) &#123;</span><br><span class="line"><span class="built_in">NSCAssert</span>([tuple isKindOfClass:RACTuple.class], <span class="string">@"-or must only be used on a signal of RACTuples of NSNumbers. Instead, received: %@"</span>, tuple);</span><br><span class="line"><span class="built_in">NSCAssert</span>(tuple.count &gt; <span class="number">0</span>, <span class="string">@"-or must only be used on a signal of RACTuples of NSNumbers, with at least 1 value in the tuple"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> @([tuple.rac_sequence any:^(<span class="built_in">NSNumber</span> *number) &#123;</span><br><span class="line">            <span class="comment">/// anyBlock</span></span><br><span class="line"><span class="built_in">NSCAssert</span>([number isKindOfClass:<span class="built_in">NSNumber</span>.class], <span class="string">@"-or must only be used on a signal of RACTuples of NSNumbers. Instead, tuple contains a non-NSNumber value: %@"</span>, tuple);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> number.boolValue;</span><br><span class="line">&#125;]);</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -or"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里主要是将 RACTuple 转换成 RACTupleSequence，因为 RACTupleSequence 是继承 RACSequence，这里就会调用 RACSequence 的 <code>- (BOOL)any:(BOOL (^)(id))block</code> 方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  RACSequence.m</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)any:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span>))block &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// block = BOOL ^(NSNumber *number) &#123;return number.boolValue;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> objectPassingTest:block] != <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  RACSequence.m</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)objectPassingTest:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span>))block &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// block = BOOL ^(NSNumber *number) &#123;return number.boolValue;&#125;</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> filter:block].head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>- (BOOL)any:(BOOL (^)(id))block</code> 实现里面最终会执行 RACStream 中的 <code>filter</code> 方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (__kindof RACStream *)filter:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> value))block &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">    Class <span class="keyword">class</span> = <span class="keyword">self</span>.class;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> flattenMap:^ <span class="keyword">id</span> (<span class="keyword">id</span> value) &#123;</span><br><span class="line">        <span class="comment">// flattenMapBlock</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/// block = BOOL ^(NSNumber *number) &#123;return number.boolValue;&#125;</span></span><br><span class="line">        <span class="keyword">if</span> (block(value)) &#123; </span><br><span class="line">            <span class="keyword">return</span> [<span class="keyword">class</span> <span class="keyword">return</span>:value];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">class</span>.empty;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -filter:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 flattenMapBlock 中会以 RACTupleSequence 发出的信号值传入到 block中，这些值信号值也就是一开始测试代码中 sourceSignal 发送给订阅者的 RACTuple 中的元素，如果value对应的BOOL值是YES，就转换成一个 RACTupleSequence 信号。如果对应的是NO，则转换成一个empty信号。</p><p>上面的 <code>flattenMap</code> 方法实际上最终调用到 RACSequence 的 <code>-bind</code> 方法<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    block = ^&#123;</span></span><br><span class="line"><span class="comment">        return ^(id value, BOOL *stop) &#123;</span></span><br><span class="line"><span class="comment">            id stream = block(value) ?: [class empty];</span></span><br><span class="line"><span class="comment">            NSCAssert([stream isKindOfClass:RACStream.class], @"Value returned from -flattenMap: is not a stream: %@", stream);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            return stream;</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    bindBlock = ^(id value, BOOL *stop) &#123;</span></span><br><span class="line"><span class="comment">            id stream = block(value) ?: [class empty];</span></span><br><span class="line"><span class="comment">            NSCAssert([stream isKindOfClass:RACStream.class], @"Value returned from -flattenMap: is not a stream: %@", stream);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            return stream;</span></span><br><span class="line"><span class="comment">        &#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">- (RACSequence *)bind:(RACSequenceBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    RACSequenceBindBlock bindBlock = block();</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> bind:bindBlock passingThroughValuesFromSequence:<span class="literal">nil</span>] setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后继续调用 <code>- (RACSequence *)bind:(RACSequenceBindBlock)bindBlock passingThroughValuesFromSequence:(RACSequence *)passthroughSequence</code> 这里参数 passthroughSequence 为 nil<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (RACSequence *)bind:(RACSequenceBindBlock)bindBlock passingThroughValuesFromSequence:(RACSequence *)passthroughSequence &#123;</span><br><span class="line"></span><br><span class="line">    __block RACSequence *valuesSeq = <span class="keyword">self</span>;</span><br><span class="line">    __block RACSequence *current = passthroughSequence;</span><br><span class="line">    __block <span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    RACSequence *sequence = [RACDynamicSequence sequenceWithLazyDependency:^ <span class="keyword">id</span> &#123;</span><br><span class="line">        <span class="comment">/// dependencyBlock</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (current.head == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (stop) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We've exhausted the current sequence, create a sequence from the</span></span><br><span class="line">            <span class="comment">// next value.</span></span><br><span class="line">            <span class="keyword">id</span> value = valuesSeq.head;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">nil</span>) &#123;</span><br><span class="line">                <span class="comment">// We've exhausted all the sequences.</span></span><br><span class="line">                stop = <span class="literal">YES</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            current = (<span class="keyword">id</span>)bindBlock(value, &amp;stop);</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="literal">nil</span>) &#123;</span><br><span class="line">                stop = <span class="literal">YES</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            valuesSeq = valuesSeq.tail;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSCAssert</span>([current isKindOfClass:RACSequence.class], <span class="string">@"-bind: block returned an object that is not a sequence: %@"</span>, current);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125; headBlock:^(<span class="keyword">id</span> _) &#123;</span><br><span class="line">        <span class="keyword">return</span> current.head;</span><br><span class="line">    &#125; tailBlock:^ <span class="keyword">id</span> (<span class="keyword">id</span> _) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stop) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [valuesSeq bind:bindBlock passingThroughValuesFromSequence:current.tail];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    sequence.name = <span class="keyword">self</span>.name;</span><br><span class="line">    <span class="keyword">return</span> sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面代码的关键逻辑是调用 RACDynamicSequence 类的 <code>sequenceWithLazyDependency</code> 方法，dependencyBlock 会在之前提及到的函数 <code>-objectPassingTest</code> 中，执行 RACSequence 的 <code>-head</code> 方法中触发</p><p>在 方法，dependencyBlock 中，执行<code>current = (id)bindBlock(value, &amp;stop);</code> 根据value的布尔值来产生新的信号，如果为 NO 则返回 RACEmptySequence 类型，此时 current.head 为 nil，进行下一次循环；如过 value 为YES，则返回 RACUnarySequence 类型，current.head 不为 nil，结束循环。</p><h3 id="any"><a href="#any" class="headerlink" title="any:"></a>any:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testAny &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [[sourceSignal any:^<span class="built_in">BOOL</span>(<span class="keyword">id</span>  _Nullable object) &#123;</span><br><span class="line">        <span class="keyword">return</span> [object integerValue] &lt; <span class="number">2</span>;</span><br><span class="line">    &#125;] subscribeNext:^(<span class="built_in">NSNumber</span> * _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = 1</span><br><span class="line">value = 0</span><br><span class="line">value = 0</span><br></pre></td></tr></table></figure><p>底层实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)any:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> object))predicateBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(predicateBlock != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[[<span class="keyword">self</span> materialize] bind:^&#123;</span><br><span class="line"><span class="keyword">return</span> ^(RACEvent *event, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">if</span> (event.finished) &#123;</span><br><span class="line">*stop = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:@NO];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (predicateBlock(event.value)) &#123;</span><br><span class="line">*stop = <span class="literal">YES</span>;</span><br><span class="line"><span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:@YES];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACSignal empty];</span><br><span class="line">&#125;;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -any:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先原信号会 通过 <code>-materialize</code> 方法转换成 RACEvent 对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)materialize &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">[subscriber sendNext:[RACEvent eventWithValue:x]];</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendNext:[RACEvent eventWithError:error]];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">[subscriber sendNext:RACEvent.completedEvent];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -materialize"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isFinished &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>.eventType == RACEventTypeCompleted || <span class="keyword">self</span>.eventType == RACEventTypeError;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码发现，RACEvent 如果收到原信号的 sendCompleted / sendError，finished 属性会置为 YES</p><p>在 <code>-any</code> 方法中，先判断 RACEvent 的 finished 属性，如果为 YES，stop接下来的信号 则返回 [RACSignal return:@NO]；反之，则会根据入参 predicateBlock 闭包，将 RACEvent 的 value 传入 predicateBlock，如果返回值为YES，stop接下来的信号，则返回 [RACSignal return:@YES]；如果 predicateBlock 返回值为 NO，则返回 [RACSignal empty]。</p><p>简单地总结来说，any 方法根据 predicateBlock 来对原信号的每一个信号进行判断，若遇到返回 YES 的条件，就给订阅者发送 YES 信号，然后发送 sendCompleted；若 predicateBlock 没有返回 YES 的条件，则最后给 订阅者 发送 NO 信号。</p><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)all:(<span class="built_in">BOOL</span> (^)(<span class="keyword">id</span> object))predicateBlock &#123;</span><br><span class="line">    <span class="built_in">NSCParameterAssert</span>(predicateBlock != <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> [[[<span class="keyword">self</span> materialize] bind:^&#123;</span><br><span class="line">        <span class="keyword">return</span> ^(RACEvent *event, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.eventType == RACEventTypeCompleted) &#123;</span><br><span class="line">                *stop = <span class="literal">YES</span>;</span><br><span class="line">                <span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:@YES];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (event.eventType == RACEventTypeError || !predicateBlock(event.value)) &#123;</span><br><span class="line">                *stop = <span class="literal">YES</span>;</span><br><span class="line">                <span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:@NO];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> [RACSignal empty];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -all:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>all 方法可以理解为 any 方法的对立面，原信号如果发送 sendError 或者 predicateBlock 返回为 NO，就会结束信号的传递，并会给订阅者发值为 NO 的信号。如果整个订阅过程中都没有出现错误以及都满足 predicateBlock 为真的条件，最后会在 RACEventTypeCompleted 的时候发送 YES。</p><h3 id="repeat"><a href="#repeat" class="headerlink" title="repeat"></a>repeat</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">    [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *orSignal = [sourceSignal repeat];</span><br><span class="line">[orSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value = 1</span><br><span class="line">value = 1</span><br><span class="line">value = 1</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>执行之后会不断地打印 <code>value = 1</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)repeat &#123;</span><br><span class="line">    <span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="keyword">return</span> subscribeForever(<span class="keyword">self</span>,</span><br><span class="line">                                ^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">                                    [subscriber sendNext:x];</span><br><span class="line">                                &#125;,</span><br><span class="line">                                ^(<span class="built_in">NSError</span> *error, RACDisposable *disposable) &#123;</span><br><span class="line">                                    [disposable dispose];</span><br><span class="line">                                    [subscriber sendError:error];</span><br><span class="line">                                &#125;,</span><br><span class="line">                                ^(RACDisposable *disposable) &#123;</span><br><span class="line">                                    <span class="comment">// Resubscribe.</span></span><br><span class="line">                                &#125;);</span><br><span class="line">    &#125;] setNameWithFormat:<span class="string">@"[%@] -repeat"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行 <code>-repeat</code> 方法之后，内部会创建新的 RASignal，当新的信号被订阅的时候会执行 <code>subscribeForever</code> 方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> RACDisposable *subscribeForever (RACSignal *signal, <span class="keyword">void</span> (^next)(<span class="keyword">id</span>), <span class="keyword">void</span> (^error)(<span class="built_in">NSError</span> *, RACDisposable *), <span class="keyword">void</span> (^completed)(RACDisposable *)) &#123;</span><br><span class="line">next = [next <span class="keyword">copy</span>];</span><br><span class="line">error = [error <span class="keyword">copy</span>];</span><br><span class="line">completed = [completed <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line">RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">RACSchedulerRecursiveBlock recursiveBlock = ^(<span class="keyword">void</span> (^recurse)(<span class="keyword">void</span>)) &#123;</span><br><span class="line">RACCompoundDisposable *selfDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">[compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">__<span class="keyword">weak</span> RACDisposable *weakSelfDisposable = selfDisposable;</span><br><span class="line"></span><br><span class="line">RACDisposable *subscriptionDisposable = [signal subscribeNext:next error:^(<span class="built_in">NSError</span> *e) &#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">error(e, compoundDisposable);</span><br><span class="line">[compoundDisposable removeDisposable:weakSelfDisposable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">recurse();</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">completed(compoundDisposable);</span><br><span class="line">[compoundDisposable removeDisposable:weakSelfDisposable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">recurse();</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[selfDisposable addDisposable:subscriptionDisposable];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Subscribe once immediately, and then use recursive scheduling for any</span></span><br><span class="line"><span class="comment">// further resubscriptions.</span></span><br><span class="line">recursiveBlock(^&#123;</span><br><span class="line">RACScheduler *recursiveScheduler = RACScheduler.currentScheduler ?: [RACScheduler scheduler];</span><br><span class="line"></span><br><span class="line">RACDisposable *schedulingDisposable = [recursiveScheduler scheduleRecursiveBlock:recursiveBlock];</span><br><span class="line">[compoundDisposable addDisposable:schedulingDisposable];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> compoundDisposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>subscribeForever</code> 方法有4个参数，分别是源信号 signal，next 闭包，error 闭包和 complete 闭包。函数内部先定义好递归的闭包:recursiveBlock，recursiveBlock 中 首先对 signal 进行订阅，如果源信号 signal 发送 sendError 或者 sendCompleted，就会执行对应的 error/complete 闭包，然后就执行 recursiveBlock 的参数闭包 recurse。</p><p> <code>subscribeForever</code>  最后是执行 recursiveBlock 并传入具体的 recurse。</p><p>recurse 中首先获取当前的递归调度器 recursiveScheduler，然后执行 <code>-scheduleRecursiveBlock</code> 方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock &#123;</span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span> scheduleRecursiveBlock:[recursiveBlock <span class="keyword">copy</span>] addingToDisposable:disposable];</span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)scheduleRecursiveBlock:(RACSchedulerRecursiveBlock)recursiveBlock addingToDisposable:(RACCompoundDisposable *)disposable &#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">RACCompoundDisposable *selfDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">[disposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">__<span class="keyword">weak</span> RACDisposable *weakSelfDisposable = selfDisposable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最终调用 schedule 方法</span></span><br><span class="line">RACDisposable *schedulingDisposable = [<span class="keyword">self</span> schedule:^&#123;</span><br><span class="line">            <span class="comment">/// scheduleBlock</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="comment">// At this point, we've been invoked, so our disposable is now useless.</span></span><br><span class="line">[disposable removeDisposable:weakSelfDisposable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (disposable.disposed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^reallyReschedule)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line"><span class="keyword">if</span> (disposable.disposed) <span class="keyword">return</span>;</span><br><span class="line">[<span class="keyword">self</span> scheduleRecursiveBlock:recursiveBlock addingToDisposable:disposable];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Protects the variables below.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This doesn't actually need to be __block qualified, but Clang</span></span><br><span class="line"><span class="comment">// complains otherwise. :C</span></span><br><span class="line">__block <span class="built_in">NSLock</span> *lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">lock.name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ %s"</span>, <span class="keyword">self</span>, sel_getName(_cmd)];</span><br><span class="line"></span><br><span class="line">__block <span class="built_in">NSUInteger</span> rescheduleCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set to YES once synchronous execution has finished. Further</span></span><br><span class="line"><span class="comment">// rescheduling should occur immediately (rather than being</span></span><br><span class="line"><span class="comment">// flattened).</span></span><br><span class="line">__block <span class="built_in">BOOL</span> rescheduleImmediately = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">recursiveBlock(^&#123;</span><br><span class="line">[lock lock];</span><br><span class="line"><span class="built_in">BOOL</span> immediate = rescheduleImmediately;</span><br><span class="line"><span class="keyword">if</span> (!immediate) ++rescheduleCount;</span><br><span class="line">[lock unlock];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (immediate) reallyReschedule();</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[lock lock];</span><br><span class="line"><span class="built_in">NSUInteger</span> synchronousCount = rescheduleCount;</span><br><span class="line">rescheduleImmediately = <span class="literal">YES</span>;</span><br><span class="line">[lock unlock];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; synchronousCount; i++) &#123;</span><br><span class="line">reallyReschedule();</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[selfDisposable addDisposable:schedulingDisposable];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// RACTargetQueueScheduler.m</span></span><br><span class="line">- (RACDisposable *)schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">RACDisposable *disposable = [[RACDisposable alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.queue, ^&#123;</span><br><span class="line"><span class="keyword">if</span> (disposable.disposed) <span class="keyword">return</span>;</span><br><span class="line">[<span class="keyword">self</span> performAsCurrentScheduler:block];</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到会调用到自己的 <code>-schedule</code> 方法，这里测试代码中是在主线程，获取到对应的是 RACTargetQueueScheduler 。这里的 <code>-schedule</code> 方法先判断原信号有没有disposed，若果没有，则把参数 block 放在对应的队列中触发。</p><p>可以看得到上面函数中 scheduleBlock 里不断递归执行 <code>[self scheduleRecursiveBlock:recursiveBlock addingToDisposable:disposable]</code>，recursiveBlock 不断被触发，对应的 <code>subscribeForever</code> 中的 recurse() 循环执行：</p><p>scheduleRecursiveBlock-&gt;recursiveBlock-&gt;recurse()-&gt;reallyReschedule()-&gt;scheduleRecursiveBlock</p><p>也就是说源信号会循环被订阅触发其给订阅者发送 sendNext 事件，直到源信号发送 error 才结束。</p><h3 id="retry"><a href="#retry" class="headerlink" title="retry:"></a>retry:</h3><p>测试代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testRetry &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">        </span><br><span class="line">        [subscriber sendError:[<span class="built_in">NSError</span> errorWithDomain:<span class="string">@"domain"</span> code:<span class="number">-1</span> userInfo:<span class="literal">nil</span>]];</span><br><span class="line">        </span><br><span class="line">        [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">        </span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *retrySignal = [sourceSignal retry:<span class="number">2</span>];</span><br><span class="line">    [retrySignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">value = 1</span><br><span class="line">value = 2</span><br><span class="line">value = 1</span><br><span class="line">value = 2</span><br><span class="line">value = 1</span><br><span class="line">value = 2</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (RACSignal *)retry:(<span class="built_in">NSInteger</span>)retryCount &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">__block <span class="built_in">NSInteger</span> currentRetryCount = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> subscribeForever(<span class="keyword">self</span>,</span><br><span class="line">^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125;,</span><br><span class="line">^(<span class="built_in">NSError</span> *error, RACDisposable *disposable) &#123;</span><br><span class="line">                <span class="comment">// 当原始信号发送 sendError 时</span></span><br><span class="line"><span class="keyword">if</span> (retryCount == <span class="number">0</span> || currentRetryCount &lt; retryCount) &#123;</span><br><span class="line"><span class="comment">// Resubscribe.</span></span><br><span class="line">currentRetryCount++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[disposable dispose];</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125;,</span><br><span class="line">^(RACDisposable *disposable) &#123;</span><br><span class="line">                <span class="comment">// 当原信号发送 sendCompleted</span></span><br><span class="line">[disposable dispose];</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -retry: %lu"</span>, <span class="keyword">self</span>.name, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)retryCount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-retry:</code> 实现与 <code>-repeat</code> 实现类似，基于 <code>subscribeForever</code>。<code>-retry:</code>  是内部维护一个 currentRetryCount 变量，当原始信号发送 sendError 时判断重试次数 currentRetryCount 是否小于 retryCount，若是则重试，如果重试依旧收到 sendError，超过 retryCount 之后就会停止重试。</p><p>如果原信号没有发生错误，那么原信号在发送结束，当原信号发送 sendCompleted，<code>subscribeForever</code> 也就接受了，所以 <code>-retry:</code> 操作对于没有任何error的信号 和 直接订阅原信号表现一样。</p><p>将测试代码改为:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)testRetryNoError &#123;</span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">        [subscriber sendNext:@<span class="number">2</span>];        </span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *retrySignal = [sourceSignal retry:<span class="number">2</span>];</span><br><span class="line">    [retrySignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"value = %@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = 1</span><br><span class="line">value = 2</span><br></pre></td></tr></table></figure><p>原信号发送 sendCompleted ，整个订阅流程就结束了。</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactiveCocoa </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RACSignal-concat与zipWith过程解析</title>
      <link href="/2019/01/13/RACSignal-concat-zipWith/"/>
      <url>/2019/01/13/RACSignal-concat-zipWith/</url>
      
        <content type="html"><![CDATA[<p>bind、concat、zipWith 都属于 RACSignal 基本操作方法，<a href="https://chipengliu.github.io/2019/01/12/RACSignal-Bind/">前一篇文章</a>已经介绍过 bind，接下来再来分析 concat 和 zipWith </p><a id="more"></a><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p>首先来看 concat 方法，同样先测试 concat 执行效果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 1 */</span></span><br><span class="line"></span><br><span class="line">RACSignal *signal1 = [RACSignal createSignal:</span><br><span class="line">                     ^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">                     &#123;</span><br><span class="line">                         <span class="comment">// BLOCK 1</span></span><br><span class="line">                         [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">                         [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">                         [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">                         [subscriber sendCompleted];</span><br><span class="line">                         <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                             <span class="built_in">NSLog</span>(<span class="string">@"signal1 dispose"</span>);</span><br><span class="line">                         &#125;];</span><br><span class="line">                     &#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RACSignal *signal2 = [RACSignal createSignal:</span><br><span class="line">                      ^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">                      &#123;</span><br><span class="line">                          <span class="comment">// BLOCK 2</span></span><br><span class="line">                          [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">                          [subscriber sendNext:@<span class="number">5</span>];</span><br><span class="line">                          [subscriber sendNext:@<span class="number">6</span>];</span><br><span class="line">                          [subscriber sendCompleted];</span><br><span class="line">                          <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                              <span class="built_in">NSLog</span>(<span class="string">@"signal2 dispose"</span>);</span><br><span class="line">                          &#125;];</span><br><span class="line">                      &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *concatSignal = [signal1 concat:signal2];</span><br><span class="line"></span><br><span class="line">[concatSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"subscribe value = %@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>执行代码，可以从看到控制输出大概如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subscribe value = 1</span><br><span class="line">subscribe value = 2</span><br><span class="line">subscribe value = 3</span><br><span class="line">subscribe value = 4</span><br><span class="line">subscribe value = 5</span><br><span class="line">subscribe value = 6</span><br><span class="line">signal2 dispose</span><br><span class="line">signal1 dispose</span><br></pre></td></tr></table></figure><p>从输出接口，可以大致猜测 concat 是将2个信号进行合并，然后依次发送给最终的的订阅者</p><p>concat 的实现代码如下:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 2 */</span></span><br><span class="line"></span><br><span class="line">- (RACSignal *)concat:(RACSignal *)signal &#123;</span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">RACCompoundDisposable *compoundDisposable = [[RACCompoundDisposable alloc] init];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// STEP 1</span></span><br><span class="line">RACDisposable *sourceDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">            <span class="comment">// STEP 2</span></span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">            <span class="comment">// STEP 3</span></span><br><span class="line">RACDisposable *concattedDisposable = [signal subscribe:subscriber];</span><br><span class="line">[compoundDisposable addDisposable:concattedDisposable];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[compoundDisposable addDisposable:sourceDisposable];</span><br><span class="line"><span class="keyword">return</span> compoundDisposable;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -concat: %@"</span>, <span class="keyword">self</span>.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析源码，concat 方法主要分为以下几个步骤:</p><ol><li>先订阅自己，也就是 <code>代码 1</code> 中的 signal1，</li><li>signal1 被订阅之后就执行 signal1 的 didSubscribe，给最终的订阅者 subscriber 发送 sendNext、sendError</li><li>signal1 发送完sendCompleted 信号之后，开始订阅 signal2，signal2 发送信号的逻辑与步骤1-2一样</li></ol><p>从上面的分析，注意到:</p><ul><li>signal2 需要在 signal1 发送 sendCompleted 之后才开始被订阅，所以如果在 <code>代码 1</code> 中 signal1 如果不发送 sendCompleted，控制台就不会输出 <code>4,5,6</code></li><li>compoundDisposable 是先把第二个信号订阅返回的 concattedDisposable 加入数组中，然后再把 signal1 订阅返回的 sourceDisposable 加入数组，所以在 <code>代码 1</code> 中 signal2先结束，然后 signal1 再结束。当2个信号都结束之后，concat之后的新信号也就结束</li></ul><p>concat 流程可以用下图概括:</p><p><img src="/2019/01/13/RACSignal-concat-zipWith/image-20190113190846381.png" alt="image-20190113190846381"></p><h2 id="zipWith"><a href="#zipWith" class="headerlink" title="zipWith"></a>zipWith</h2><p>同样先测试 <code>zipWith</code> 方法的效果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 3 */</span></span><br><span class="line"></span><br><span class="line">RACSignal *signal1 = [RACSignal createSignal:</span><br><span class="line">                      ^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">                      &#123;</span><br><span class="line">                          [subscriber sendNext:@<span class="number">1</span>];</span><br><span class="line">                          [subscriber sendNext:@<span class="number">2</span>];</span><br><span class="line">                          [subscriber sendNext:@<span class="number">3</span>];</span><br><span class="line">                          [subscriber sendCompleted];</span><br><span class="line">                          <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                              <span class="built_in">NSLog</span>(<span class="string">@"signal1 dispose"</span>);</span><br><span class="line">                          &#125;];</span><br><span class="line">                      &#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RACSignal *signal2 = [RACSignal createSignal:</span><br><span class="line">                      ^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber)</span><br><span class="line">                      &#123;</span><br><span class="line">                          [subscriber sendNext:@<span class="number">4</span>];</span><br><span class="line">                          [subscriber sendNext:@<span class="number">5</span>];</span><br><span class="line">                          [subscriber sendNext:@<span class="number">6</span>];</span><br><span class="line">                          [subscriber sendNext:@<span class="number">7</span>];</span><br><span class="line">                          [subscriber sendCompleted];</span><br><span class="line">                          <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">                              <span class="built_in">NSLog</span>(<span class="string">@"signal2 dispose"</span>);</span><br><span class="line">                          &#125;];</span><br><span class="line">                      &#125;];</span><br><span class="line"></span><br><span class="line">RACSignal *zipSignal = [signal1 zipWith:signal2];</span><br><span class="line"></span><br><span class="line">[zipSignal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"subscribe value = %@"</span>, x);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p>执行并输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">subscribe value = &lt;RACTwoTuple: 0x60800001b5f0&gt; (</span><br><span class="line">    1,</span><br><span class="line">    4</span><br><span class="line">)</span><br><span class="line">subscribe value = &lt;RACTwoTuple: 0x60800001b680&gt; (</span><br><span class="line">    2,</span><br><span class="line">    5</span><br><span class="line">)</span><br><span class="line">subscribe value = &lt;RACTwoTuple: 0x60800001b660&gt; (</span><br><span class="line">    3,</span><br><span class="line">    6</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>看起来 <code>zipWith</code> 是把2个信号发送值合并成 tuple 类型并发送给订阅者</p><p>具体源码:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 4 */</span></span><br><span class="line"></span><br><span class="line">- (RACSignal *)zipWith:(RACSignal *)signal &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(signal != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// BLOCK 1</span></span><br><span class="line">__block <span class="built_in">BOOL</span> selfCompleted = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *selfValues = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">__block <span class="built_in">BOOL</span> otherCompleted = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *otherValues = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^sendCompletedIfNecessary)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            <span class="comment">// BLOCK 2</span></span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">                <span class="comment">// 判断是否有其中一个信号已经完成并且数组元素数量为空，则整个信号就算完成</span></span><br><span class="line"><span class="built_in">BOOL</span> selfEmpty = (selfCompleted &amp;&amp; selfValues.count == <span class="number">0</span>);</span><br><span class="line"><span class="built_in">BOOL</span> otherEmpty = (otherCompleted &amp;&amp; otherValues.count == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (selfEmpty || otherEmpty) [subscriber sendCompleted];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^sendNext)(<span class="keyword">void</span>) = ^&#123;</span><br><span class="line">            <span class="comment">// BLOCK 3</span></span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">                <span class="comment">// 其中任意一个信号发送sendNext就会进入执行这里的代码</span></span><br><span class="line">                <span class="comment">// 先判断2个数组是否不为空</span></span><br><span class="line">                <span class="comment">// 取出2个数组的头元素，包装成 RACTuple 发送给订阅者</span></span><br><span class="line"><span class="keyword">if</span> (selfValues.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (otherValues.count == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">RACTuple *tuple = RACTuplePack(selfValues[<span class="number">0</span>], otherValues[<span class="number">0</span>]);</span><br><span class="line">[selfValues removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line">[otherValues removeObjectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">[subscriber sendNext:tuple];</span><br><span class="line">sendCompletedIfNecessary();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RACDisposable *selfDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">            <span class="comment">// BLOCK 4</span></span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">                <span class="comment">// 把信号事件加到对应的数组里</span></span><br><span class="line">[selfValues addObject:x ?: RACTupleNil.tupleNil];</span><br><span class="line">sendNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">                <span class="comment">// 结束的时候判断整个信号是否结束</span></span><br><span class="line">selfCompleted = <span class="literal">YES</span>;</span><br><span class="line">sendCompletedIfNecessary();</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACDisposable *otherDisposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">            <span class="comment">// BLOCK 5</span></span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">                <span class="comment">// 把信号事件加到对应的数组里</span></span><br><span class="line">[otherValues addObject:x ?: RACTupleNil.tupleNil];</span><br><span class="line">sendNext();</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (selfValues) &#123;</span><br><span class="line">                <span class="comment">// 结束的时候判断整个信号是否结束</span></span><br><span class="line">otherCompleted = <span class="literal">YES</span>;</span><br><span class="line">sendCompletedIfNecessary();</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">            <span class="comment">// 销毁2个信号</span></span><br><span class="line">[selfDisposable dispose];</span><br><span class="line">[otherDisposable dispose];</span><br><span class="line">&#125;];</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -zipWith: %@"</span>, <span class="keyword">self</span>.name, signal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>zipWith 操作主要经历以下几步：</p><ol><li>初始化2个可变数组，分别保存 signal1 和 signal2 发送的信号事件</li><li>订阅 signal1，然后会执行 <code>BLOCK 4</code> 把值保存到数组中，再去执行之前初始化好的 <code>sendNext</code> 闭包，然后判断2个数组是否都有值，如都有则把2个数组的头元素组出来，包装成 RACTuple 类型发给订阅者，当然 <code>BLOCK 4</code>  中 signal1 被订阅的时候都没有发出去，因为 otherValues 为空</li><li>订阅 signal2，具体逻辑跟步骤2相似，signal2被订阅之后会执行 <code>BLOCK 5</code> ，然后发送的值存在对应数组，然后执行 <code>sendNext</code> 闭包，这时候2个数组不为空，给订阅者发送 RACTuple，然后判断 signal1和 signal2 其中是否有一个已经完成并且数组为空，则给订阅者发送 sendCompleted</li></ol><p>第一个信号依次发送的1，2，3的值和第二个信号依次发送的4，5，6，7的值，一一合并，当signal2 发送 7 的时候 signal1 已经结束了，所以 7 也就是被丢弃了。</p><p><img src="/2019/01/13/RACSignal-concat-zipWith/image-20190113194035889.png" alt="image-20190113194035889"></p><h2 id="RACDisposable"><a href="#RACDisposable" class="headerlink" title="RACDisposable"></a>RACDisposable</h2><p>每次对一个 RACSignal 进行订阅执行 <code>subscribeNext</code> 方法的时候，都会返回 一个 RACDisposable 对象，之前也提到过 RACDisposable 主要对一次订阅结束过后做相关的清理操作，而且它可以随时取消任何一个订阅，这方面类似 <code>NSURLSessionDataTask</code> 。</p><p>RACDisposable 有一个核心方法 <code>-dispose</code> ，功能类似于我们经常接触到的 <code>-dealloc</code> 方法，接下来分析 RACDisposable 实现代码，看其是如何工作的</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 5 */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_disposeBlock = (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>;</span><br><span class="line">OSMemoryBarrier();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line"></span><br><span class="line">_disposeBlock = (<span class="keyword">void</span> *)<span class="built_in">CFBridgingRetain</span>([block <span class="keyword">copy</span>]); </span><br><span class="line">OSMemoryBarrier();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)disposableWithBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithBlock:block];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里看到有2个初始化方法 <code>init</code> 和 <code>initWithBlock</code>，后置是把参数 block 拷贝并以 <code>void *</code> 的形式保存到 <code>_disposeBlock</code> 中；而 <code>init</code> 中 <code>_disposeBlock</code> 指向的是 self，这里指向 self 的作用是什么呢？</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)isDisposed &#123;</span><br><span class="line"><span class="keyword">return</span> _disposeBlock == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到 <code>isDisposed</code> 的返回结果是通过判断  <code>_disposeBlock</code>  是否为空，这里 <code>init</code> 中 <code>_disposeBlock</code> 指向的是 self主要为了在不引入其他实例变量、增加对象的基础上避免 <code>isDisposed</code> 方法的误判</p><p>基于上面的结论，很可能会产生另外一个疑惑，为什么不把 <code>init</code> 方法禁用，只能通 <code>initWithBlock</code> 方法进行初始化？这是因为对于某些 RACDisposable 的子类如 RACSerialDisposable，执行多余的  <code>_disposeBlock</code>  比较浪费性能</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispose &#123;</span><br><span class="line"><span class="keyword">void</span> (^disposeBlock)(<span class="keyword">void</span>) = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line"><span class="keyword">void</span> *blockPtr = _disposeBlock;</span><br><span class="line"><span class="keyword">if</span> (OSAtomicCompareAndSwapPtrBarrier(blockPtr, <span class="literal">NULL</span>, &amp;_disposeBlock)) &#123;</span><br><span class="line"><span class="keyword">if</span> (blockPtr != (__bridge <span class="keyword">void</span> *)<span class="keyword">self</span>) &#123;</span><br><span class="line">disposeBlock = <span class="built_in">CFBridgingRelease</span>(blockPtr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (disposeBlock != <span class="literal">nil</span>) disposeBlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>-dispose</code> 主要是将 _disposeBlock 进行一次 release，然后执行这个block</p><h2 id="RACSerialDisposable"><a href="#RACSerialDisposable" class="headerlink" title="RACSerialDisposable"></a>RACSerialDisposable</h2><p>RACSerialDisposable 是一个容量为1的 RACDisposable 容器，RACDisposable 对象保存在 <code>_disposable</code> 属性中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setDisposable:(RACDisposable *)disposable &#123;</span><br><span class="line">[<span class="keyword">self</span> swapInDisposable:disposable];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (RACDisposable *)swapInDisposable:(RACDisposable *)newDisposable &#123;</span><br><span class="line">RACDisposable *existingDisposable;</span><br><span class="line"><span class="built_in">BOOL</span> alreadyDisposed;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">alreadyDisposed = _disposed;</span><br><span class="line"><span class="keyword">if</span> (!alreadyDisposed) &#123;</span><br><span class="line">existingDisposable = _disposable;</span><br><span class="line">_disposable = newDisposable;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (alreadyDisposed) &#123;</span><br><span class="line">[newDisposable dispose];</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> existingDisposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置 <code>_disposable</code> 的时候采用 <code>pthred_mutex_t</code> 互斥锁来保证操作的原子性，先判断是否已经被 dispose，若没有则将 newDisposable 赋值给 _disposable，反之直接对新的 newDisposable 执行 dispose</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispose &#123;</span><br><span class="line">RACDisposable *existingDisposable;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line"><span class="keyword">if</span> (!_disposed) &#123;</span><br><span class="line">existingDisposable = _disposable;</span><br><span class="line">_disposed = <span class="literal">YES</span>;</span><br><span class="line">_disposable = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line">[existingDisposable dispose];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACSerialDisposable 的 dispose 方法内部是在线程安全的基础上将 _disposable 换出，然后再进行 dispose</p><h2 id="RACCompoundDisposable"><a href="#RACCompoundDisposable" class="headerlink" title="RACCompoundDisposable"></a>RACCompoundDisposable</h2><p>RACCompoundDisposable 也是保存 RACDisposable 的容器，和 RACSerialDisposable 不同的是，RACCompoundDisposable可以保存多个 RACDisposable 对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACCompoundDisposable</span> () </span>&#123;</span><br><span class="line"><span class="comment">// Used for synchronization.</span></span><br><span class="line">pthread_mutex_t _mutex;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line"><span class="comment">// A fast array to the first N of the receiver's disposables.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Once this is full, `_disposables` will be created and used for additional</span></span><br><span class="line"><span class="comment">// disposables.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This array should only be manipulated while _mutex is held.</span></span><br><span class="line">RACDisposable *_inlineDisposables[RACCompoundDisposableInlineCount];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Contains the receiver's disposables.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This array should only be manipulated while _mutex is held. If</span></span><br><span class="line"><span class="comment">// `_disposed` is YES, this may be NULL.</span></span><br><span class="line"><span class="built_in">CFMutableArrayRef</span> _disposables;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Whether the receiver has already been disposed.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This ivar should only be accessed while _mutex is held.</span></span><br><span class="line"><span class="built_in">BOOL</span> _disposed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACCompoundDisposable 内部用2个数组来保存 RACDisposable，分别是 <code>_inlineDisposables</code> 和 <code>_disposables</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithDisposables:(<span class="built_in">NSArray</span> *)otherDisposables &#123;</span><br><span class="line"><span class="keyword">self</span> = [<span class="keyword">self</span> init];</span><br><span class="line"></span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line">[otherDisposables enumerateObjectsUsingBlock:^(RACDisposable *disposable, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"><span class="keyword">self</span>-&gt;_inlineDisposables[index] = disposable;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop after this iteration if we've reached the end of the inlined</span></span><br><span class="line"><span class="comment">// array.</span></span><br><span class="line"><span class="keyword">if</span> (index == RACCompoundDisposableInlineCount - <span class="number">1</span>) *stop = <span class="literal">YES</span>;</span><br><span class="line">&#125;];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (otherDisposables.count &gt; RACCompoundDisposableInlineCount) &#123;</span><br><span class="line">_disposables = RACCreateDisposablesArray();</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFRange</span> range = <span class="built_in">CFRangeMake</span>(RACCompoundDisposableInlineCount, (<span class="built_in">CFIndex</span>)otherDisposables.count - RACCompoundDisposableInlineCount);</span><br><span class="line"><span class="built_in">CFArrayAppendArray</span>(_disposables, (__bridge <span class="built_in">CFArrayRef</span>)otherDisposables, range);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当数量少于等于 RACCompoundDisposableInlineCount(默认为2) 的时候会保存在 _inlineDisposables 数组里面，超过这个临界值后，后面的 RACDisposable 保存在 _disposables 中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDisposable:(RACDisposable *)disposable &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(disposable != <span class="keyword">self</span>);</span><br><span class="line"><span class="keyword">if</span> (disposable == <span class="literal">nil</span> || disposable.disposed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> shouldDispose = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_disposed) &#123;</span><br><span class="line">shouldDispose = <span class="literal">YES</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; RACCompoundDisposableInlineCount; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (_inlineDisposables[i] == <span class="literal">nil</span>) &#123;</span><br><span class="line">_inlineDisposables[i] = disposable;</span><br><span class="line"><span class="keyword">goto</span> foundSlot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_disposables == <span class="literal">NULL</span>) _disposables = RACCreateDisposablesArray();</span><br><span class="line"><span class="built_in">CFArrayAppendValue</span>(_disposables, (__bridge <span class="keyword">void</span> *)disposable);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RACCOMPOUNDDISPOSABLE_ADDED_ENABLED()) &#123;</span><br><span class="line">RACCOMPOUNDDISPOSABLE_ADDED(<span class="keyword">self</span>.description.UTF8String, disposable.description.UTF8String, <span class="built_in">CFArrayGetCount</span>(_disposables) + RACCompoundDisposableInlineCount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line">foundSlot:;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Performed outside of the lock in case the compound disposable is used</span></span><br><span class="line"><span class="comment">// recursively.</span></span><br><span class="line"><span class="keyword">if</span> (shouldDispose) [disposable dispose];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加 RACDisposable 的时候同样先判断当前是否已经被 dispose，若是则直接执行参数 RACDisposable 对象的 dispose；反之则先判断 _inlineDisposables 是否有剩余空间，如果没有就加入到 _disposables </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)dispose &#123;</span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line">RACDisposable *inlineCopy[RACCompoundDisposableInlineCount];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CFArrayRef</span> remainingDisposables = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">&#123;</span><br><span class="line">_disposed = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; RACCompoundDisposableInlineCount; i++) &#123;</span><br><span class="line">inlineCopy[i] = _inlineDisposables[i];</span><br><span class="line">_inlineDisposables[i] = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">remainingDisposables = _disposables;</span><br><span class="line">_disposables = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line"><span class="comment">// Dispose outside of the lock in case the compound disposable is used</span></span><br><span class="line"><span class="comment">// recursively.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; RACCompoundDisposableInlineCount; i++) &#123;</span><br><span class="line">[inlineCopy[i] dispose];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (remainingDisposables == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CFIndex</span> count = <span class="built_in">CFArrayGetCount</span>(remainingDisposables);</span><br><span class="line"><span class="built_in">CFArrayApplyFunction</span>(remainingDisposables, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, count), &amp;disposeEach, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CFRelease</span>(remainingDisposables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>-dispose</code> 中，_inlineDisposables 和 _disposables 遍历，然后逐一进行 dispose</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactiveCocoa </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RACSignal-Bind操作过程解析</title>
      <link href="/2019/01/12/RACSignal-Bind/"/>
      <url>/2019/01/12/RACSignal-Bind/</url>
      
        <content type="html"><![CDATA[<p>在 RACSignals.h 头文件中定义 RACSignal 几个基本操作方法:</p><ul><li>bind</li><li>concat</li><li>zipWith</li></ul><a id="more"></a><p>在分析一下 bind 操作流程，首先看一下 bind 函数的效果</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 1 */</span></span><br><span class="line"></span><br><span class="line">    RACSignal *sourceSignal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// BLOCK 1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 1.保存这个block，signal1.didSubscribe = block</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 5.sendNext，把value传给第3步的nextBlock，并执行nextBlock(value)</span></span><br><span class="line">        [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">        [subscriber sendNext:@(<span class="number">2</span>)];</span><br><span class="line">        [subscriber sendNext:@(<span class="number">3</span>)];</span><br><span class="line">        </span><br><span class="line">        [subscriber sendCompleted];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    RACSignal *bindSignal = [sourceSignal bind:^RACSignalBindBlock _Nonnull&#123;</span><br><span class="line">        <span class="comment">// BLOCK 2</span></span><br><span class="line">        <span class="keyword">return</span> ^RACSignal *(<span class="keyword">id</span> value,  <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line">            <span class="comment">// BLOCK 3</span></span><br><span class="line">            value = @([value integerValue] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> [RACSignal <span class="keyword">return</span>:value];</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [bindSignal subscribeNext:^(<span class="keyword">id</span>  _Nullable x) &#123;</span><br><span class="line">        <span class="comment">// BLOCK 4</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/// 2.内部调用RACDynamicSignal subscribe</span></span><br><span class="line">        <span class="comment">/// 3.创建subscriber, 保存subscriber-&gt;nextBlock</span></span><br><span class="line">        <span class="comment">/// 4.执行didSubscribe, subscriber执行sendNext</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, x);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码，在控制台会依次输出 <code>1</code>, <code>2</code>, <code>3</code></p><p>从输出结果可以猜测 bind 方法作用大概是将原信号 <code>sourceSignal</code>  发送的信号事件经过 bind 方法的参数 block 的加工之后，给 bind 函数返回的 <code>bindSignal</code> 的订阅者发送新的信号事件。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 2 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * -bind: should:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1. Subscribe to the original signal of values.</span></span><br><span class="line"><span class="comment"> * 2. Any time the original signal sends a value, transform it using the binding block.</span></span><br><span class="line"><span class="comment"> * 3. If the binding block returns a signal, subscribe to it, and pass all of its values through to the subscriber as they're received.</span></span><br><span class="line"><span class="comment"> * 4. If the binding block asks the bind to terminate, complete the _original_ signal.</span></span><br><span class="line"><span class="comment"> * 5. When _all_ signals complete, send completed to the subscriber.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * If any signal sends an error at any point, send that to the subscriber.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>从函数内部的注释中，可以初步地看到 bind 函数的作用:</p><ol><li>订阅原始信号</li><li>当原信号发送任何值的时候，都会通过 bind 方法参数 block 来进行转换</li><li>如果 block 返回一个 signal，则马上对其进行订阅，然后把值发送给订阅者 subscriber</li><li>如果 block 终止绑定，结束原始信号</li><li>所有信号都结束后，给订阅者 subscriber 发送 completed 信号</li><li>在以上过程中，其中一个 signal 发送 error，则会马上将 error 转发给订阅者 subscriber</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 3 */</span></span><br><span class="line"></span><br><span class="line">- (RACSignal *)bind:(RACSignalBindBlock (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    <span class="comment">// BLOCK 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> [[RACSignal createSignal:^(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber) &#123;</span><br><span class="line">        <span class="comment">// BLOCK 6</span></span><br><span class="line">        </span><br><span class="line">RACSignalBindBlock bindingBlock = block();</span><br><span class="line"></span><br><span class="line">__block <span class="keyword">volatile</span> int32_t signalCount = <span class="number">1</span>;   <span class="comment">// indicates self</span></span><br><span class="line"></span><br><span class="line">RACCompoundDisposable *compoundDisposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^completeSignal)(RACDisposable *) = ^(RACDisposable *finishedDisposable) &#123;</span><br><span class="line">            <span class="comment">// BLOCK 7</span></span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span> (OSAtomicDecrement32Barrier(&amp;signalCount) == <span class="number">0</span>) &#123;</span><br><span class="line">[subscriber sendCompleted];</span><br><span class="line">[compoundDisposable dispose];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">[compoundDisposable removeDisposable:finishedDisposable];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> (^addSignal)(RACSignal *) = ^(RACSignal *signal) &#123;</span><br><span class="line">            <span class="comment">// BLOCK 8</span></span><br><span class="line">            </span><br><span class="line">OSAtomicIncrement32Barrier(&amp;signalCount);</span><br><span class="line"></span><br><span class="line">RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">[compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">RACDisposable *disposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">                <span class="comment">// BLOCK 9</span></span><br><span class="line">                </span><br><span class="line">[subscriber sendNext:x];</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[compoundDisposable dispose];</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">completeSignal(selfDisposable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">selfDisposable.disposable = disposable;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">RACSerialDisposable *selfDisposable = [[RACSerialDisposable alloc] init];</span><br><span class="line">[compoundDisposable addDisposable:selfDisposable];</span><br><span class="line"></span><br><span class="line">RACDisposable *bindingDisposable = [<span class="keyword">self</span> subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">                <span class="comment">// BLOCK 10</span></span><br><span class="line">                     </span><br><span class="line"><span class="comment">// Manually check disposal to handle synchronous errors.</span></span><br><span class="line"><span class="keyword">if</span> (compoundDisposable.disposed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> stop = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">id</span> signal = bindingBlock(x, &amp;stop);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (signal != <span class="literal">nil</span>) addSignal(signal);</span><br><span class="line"><span class="keyword">if</span> (signal == <span class="literal">nil</span> || stop) &#123;</span><br><span class="line">[selfDisposable dispose];</span><br><span class="line">completeSignal(selfDisposable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">[compoundDisposable dispose];</span><br><span class="line">[subscriber sendError:error];</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">completeSignal(selfDisposable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">selfDisposable.disposable = bindingDisposable;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> compoundDisposable;</span><br><span class="line">&#125;] setNameWithFormat:<span class="string">@"[%@] -bind:"</span>, <span class="keyword">self</span>.name];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码 1开始看，主要流程可以分为以下几步:</p><ol><li>先创建原始信号 sourceSignal，执行 <code>createSignal:</code> 方法的时候 ,  会将 <code>BLOCK 1</code> 保存起来</li><li>执行 <code>bind:</code> 方法，进入 <code>BLOCK 5</code> 先判断参数是否为空</li><li>创建并返回新的信号，也就是 <code>代码 1</code> 中的 bindSignal，bindSignal 被订阅时，会触发 <code>BLOCK 6</code></li><li>执行 <code>bind:</code>方法的入参 block，返回 RACSignalBindBlock 类型对象 bindBlock，也就是执行 <code>BLOCK 2</code></li><li>定义好 <code>completeSignal</code>、 <code>addSignal</code> 后，开始订阅自己，也就是 sourceSignal 本身，这时候会触发步骤1保存的  <code>BLOCK 1</code>  ，sourceSignal  保存的 didSubscribe 会被执行，执行 <code>sendNext:</code> 方法，触发 subscriber 的 <code>nextBlock</code> ，也就是执行 <code>BLOCK 10</code></li><li>先判断绑定是否被 dispose，然后执行步骤4中的 bindBlock，入参是 <code>BLOCK 1</code> 发送的值 value ，分别是 <code>@(1)</code> 、 <code>@(2)</code> 、 <code>@(3)</code>，然后按照 <code>BLOCK 3</code> 逻辑进行转换，也就是 <code>代码 1</code> 中将 value 值加1之后，调用 <code>retrun:</code> 返回将 value 包装成 RACReturnSignal 对象返回，这里暂且将其称为 signal_t</li><li>调用 <code>addSignal</code> 闭包，将步骤6返回的 signal_t 作为闭包参数，通过 <code>OSAtomicDecrement32Barrier</code> 方法，将 signalCount + 1，然后对 signal_t 进行订阅，因为 signal_t 是 RACReturnSignal 类型，被订阅之后马上会执行 <code>BLOCK 9</code>，这里会执行 subscriber <code>sendNext</code> 方法，subscriber是 <code>BLOCK 6</code> 入参，最终会执行 <code>BLOCK 4</code></li><li>如果绑定被终止或者 signal_t 为空，则执行 completeSignal 闭包，也就是执行 <code>BLOCK 7</code>，给订阅者 subscriber 发送 completed 信号</li><li>执行完 <code>BLOCK 7</code> 或 源信号发送 complete/error 之后，就完成一次 bind 的基本流程</li></ol><p>bind 操作的基本流程大概可以用下图来表示:</p><p><img src="/2019/01/12/RACSignal-Bind/image-20190112202901811.png" alt="image-20190112202901811"></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactiveCocoa </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RACSignal源码解析</title>
      <link href="/2018/12/28/RACSignal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-RACSignal%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/12/28/RACSignal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-RACSignal%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%E8%BF%87%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>RACStream 是 ReactiveCocoa 中的核心概念：信号；RACStream 中有2个子类：</p><ol><li>RACSignal</li><li>RACSequence</li></ol><a id="more"></a><h2 id="RACSignal"><a href="#RACSignal" class="headerlink" title="RACSignal"></a>RACSignal</h2><p>实际项目中，对 RACSignal 的使用中，经常会看到这样的代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 1 */</span></span><br><span class="line"></span><br><span class="line">RACSignal *signal = [RACSignal createSignal:^RACDisposable *(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber)&#123;</span><br><span class="line">    <span class="comment">/// STEP 1</span></span><br><span class="line">    [subscriber sendNext:@(<span class="number">1</span>)];</span><br><span class="line">    [subscriber sendNext:@(<span class="number">2</span>)];</span><br><span class="line">    [subscriber sendNext:@(<span class="number">3</span>)];</span><br><span class="line">    [subscriber sendCompleted];</span><br><span class="line">    <span class="keyword">return</span> [RACDisposable disposableWithBlock:^&#123;</span><br><span class="line">        <span class="comment">/// STEP 5</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"signal dispose"</span>);</span><br><span class="line">    &#125;];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">RACDisposable *disposable = [signal subscribeNext:^(<span class="keyword">id</span> x) &#123;</span><br><span class="line">    <span class="comment">/// STEP 2</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"received value = %@"</span>, x);</span><br><span class="line">&#125; error:^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="comment">/// STEP 3</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"received error: %@"</span>, error);</span><br><span class="line">&#125; completed:^&#123;</span><br><span class="line">    <span class="comment">/// STEP 4</span></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"received completed"</span>);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable dispose];</span><br></pre></td></tr></table></figure><p>基于以上的代码，我们可以看看 RACSigal从 被订阅到订阅者受到数据的整个过程，具体经历过那些流程</p><p>初始化：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 2 */</span></span><br><span class="line"></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line"><span class="keyword">return</span> [RACDynamicSignal createSignal:didSubscribe]; <span class="comment">// 返回 RACDynamicSignal 类型的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面初始化返回 <code>RACDynamicSignal</code> 对象，这是一个私有类，继承RACSignal，实现 RACSignal 的订阅行为</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 3 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// A private `RACSignal` subclasses that implements its subscription behavior</span></span><br><span class="line"><span class="comment">// using a block.</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACDynamicSignal</span> : <span class="title">RACSignal</span></span></span><br><span class="line"></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>在调用 RACDynamicSignal 的 <code>createSignal</code> 方法中，会传入一个名为 <code>didSubscribe</code> ，返回类型为 <code>RACDisposable</code> 的block，在内部会将 didSubscribe 进行一次copy，然后保存在 RACDynamicSignal 对象中。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 4 */</span></span><br><span class="line"></span><br><span class="line">+ (RACSignal *)createSignal:(RACDisposable * (^)(<span class="keyword">id</span>&lt;RACSubscriber&gt; subscriber))didSubscribe &#123;</span><br><span class="line">RACDynamicSignal *signal = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">signal-&gt;_didSubscribe = [didSubscribe <span class="keyword">copy</span>]; <span class="comment">// 这里先进行一次copy</span></span><br><span class="line"><span class="keyword">return</span> [signal setNameWithFormat:<span class="string">@"+createSignal:"</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码初始化返回 signal 调用方法 <code>setNameWithFormat</code>，会执行基类 RACStream 的方法，给 name 属性赋值</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 5 */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)setNameWithFormat:(<span class="built_in">NSString</span> *)format, ... &#123;</span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">"RAC_DEBUG_SIGNAL_NAMES"</span>) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(format != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">va_list args;</span><br><span class="line">va_start(args, format);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSString</span> *str = [[<span class="built_in">NSString</span> alloc] initWithFormat:format arguments:args];</span><br><span class="line">va_end(args);</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.name = str;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 didSubscribe 中还可以看到 RACSubscriber 协议:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 6 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">RACSubscriber</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 给所有订阅者发送 next value</span></span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">nullable</span> <span class="keyword">id</span>)value;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 给所有订阅者发送 error</span></span><br><span class="line"><span class="comment">/// 这将终止订阅，并使所有订阅者无法收到后续数据</span></span><br><span class="line">- (<span class="keyword">void</span>)sendError:(<span class="keyword">nullable</span> <span class="built_in">NSError</span> *)error;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 给所有订阅者发送 complete</span></span><br><span class="line"><span class="comment">/// 这将终止订阅，并使所有订阅者无法收到后续数据</span></span><br><span class="line">- (<span class="keyword">void</span>)sendCompleted;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 用来接收代表某次订阅的 disposable 对象, 用来处理是否释放取消订阅的事件</span></span><br><span class="line">- (<span class="keyword">void</span>)didSubscribeWithDisposable:(RACCompoundDisposable *)disposable;</span><br></pre></td></tr></table></figure><p>代码4中可以看到，创建 RACSignal 的时候，signal 会持有保存传入的 didSubscribe 闭包。这个闭包会在 signal 被订阅的时候触发</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 7 */</span></span><br><span class="line"></span><br><span class="line">- (RACDisposable *)subscribeNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))nextBlock error:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *error))errorBlock completed:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completedBlock &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(nextBlock != <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(errorBlock != <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(completedBlock != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">RACSubscriber *o = [RACSubscriber subscriberWithNext:nextBlock error:errorBlock completed:completedBlock];</span><br><span class="line"><span class="keyword">return</span> [<span class="keyword">self</span> subscribe:o];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们平时对 RACSignal 实例对象调用 <code>- (RACDisposable *)subscribeNext:(void (^)(id x))nextBlock</code> 或者 <code>- (RACDisposable *)subscribeError:(void (^)(NSError *error))errorBlock</code> 方法会返回 RACDisposable  对象，内部会创建一个实现了 RACSubscriber 协议的对象 o， 把 next、error、completed 三种block进行 copy 保存</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 8 */</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)subscriberWithNext:(<span class="keyword">void</span> (^)(<span class="keyword">id</span> x))next error:(<span class="keyword">void</span> (^)(<span class="built_in">NSError</span> *error))error completed:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))completed &#123;</span><br><span class="line">RACSubscriber *subscriber = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line"></span><br><span class="line">subscriber-&gt;_next = [next <span class="keyword">copy</span>];</span><br><span class="line">subscriber-&gt;_error = [error <span class="keyword">copy</span>];</span><br><span class="line">subscriber-&gt;_completed = [completed <span class="keyword">copy</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> subscriber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后调用 <code>- (RACDisposable *)subscribe:(id&lt;RACSubscriber&gt;)subscriber</code> 方法并把刚刚 RACSubscriber 对象传入，如代码2所示，这里实际上是调用了 RACDynamicSignal 的 subscriber 方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 9 */</span></span><br><span class="line"></span><br><span class="line">- (RACDisposable *)subscribe:(<span class="keyword">id</span>&lt;RACSubscriber&gt;)subscriber &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(subscriber != <span class="literal">nil</span>);</span><br><span class="line"></span><br><span class="line">RACCompoundDisposable *disposable = [RACCompoundDisposable compoundDisposable];</span><br><span class="line">subscriber = [[RACPassthroughSubscriber alloc] initWithSubscriber:subscriber signal:<span class="keyword">self</span> disposable:disposable];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.didSubscribe != <span class="literal">NULL</span>) &#123;</span><br><span class="line">RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">RACDisposable *innerDisposable = <span class="keyword">self</span>.didSubscribe(subscriber);</span><br><span class="line">[disposable addDisposable:innerDisposable];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:schedulingDisposable];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> disposable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码9中我们可以看到 2 个 类：RACCompoundDisposable、 RACPassthroughSubscriber</p><p>RACCompoundDisposable 继承 RACDisposable，可以理解为是一个保存 RACDisposable 类型的容器，当 RACCompoundDisposable 执行 <code>- (void)dispose</code> 方法会将 disposables 数组中的元素一一进行 dispose</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 10 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> disposeEach(<span class="keyword">const</span> <span class="keyword">void</span> *value, <span class="keyword">void</span> *context) &#123;</span><br><span class="line">RACDisposable *disposable = (__bridge <span class="keyword">id</span>)value;</span><br><span class="line">[disposable dispose];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dispose &#123;</span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line">RACDisposable *inlineCopy[RACCompoundDisposableInlineCount];</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">CFArrayRef</span> remainingDisposables = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">&#123;</span><br><span class="line">_disposed = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; RACCompoundDisposableInlineCount; i++) &#123;</span><br><span class="line">inlineCopy[i] = _inlineDisposables[i];</span><br><span class="line">_inlineDisposables[i] = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">remainingDisposables = _disposables;</span><br><span class="line">_disposables = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line"></span><br><span class="line"><span class="meta">#if RACCompoundDisposableInlineCount</span></span><br><span class="line"><span class="comment">// Dispose outside of the lock in case the compound disposable is used</span></span><br><span class="line"><span class="comment">// recursively.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; RACCompoundDisposableInlineCount; i++) &#123;</span><br><span class="line">[inlineCopy[i] dispose];</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (remainingDisposables == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 遍历 RACDisposable 数组</span></span><br><span class="line">    <span class="comment">/// 通过函数 disposeEach 来 dispose 每一个数组元素</span></span><br><span class="line"><span class="built_in">CFIndex</span> count = <span class="built_in">CFArrayGetCount</span>(remainingDisposables);</span><br><span class="line"><span class="built_in">CFArrayApplyFunction</span>(remainingDisposables, <span class="built_in">CFRangeMake</span>(<span class="number">0</span>, count), &amp;disposeEach, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">CFRelease</span>(remainingDisposables);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACPassthroughSubscriber 是一个私有类，主要的作用是把一个订阅者 subscriber A 的信号事件传递给另一个没有被 dispose 的订阅者 subscriber B。由以下几个步骤实现：</p><ol><li>包装真正的订阅者，使自己成为订阅者的替代者</li><li>将真正的订阅者与一个订阅时产生的 Disposable 关联起来</li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 11 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RACPassthroughSubscriber</span> ()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受转发信号事件的订阅者，也就是上面提到的 subscriber B</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;RACSubscriber&gt; innerSubscriber;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给 RACPassthroughSubscriber 发送事件的 RACSignal 信号</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 该属性使用 unsafe_unretained 修饰主要是因为 RACSignal 仅是一个 DTrace probes </span></span><br><span class="line"><span class="comment">// 动态跟踪技术的探针, 如果改用 weak 会造成不必要的性能损耗</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">unsafe_unretained</span>, <span class="keyword">readonly</span>) RACSignal *signal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// disposable 若disposed，信号事件则不再转发给 innerSubscriber</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>) RACCompoundDisposable *disposable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>回到代码<strong>9</strong>中，之前已经创建刚刚提到的 RACCompoundDisposable 和 RACPassthroughSubscriber，</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 12 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.didSubscribe != <span class="literal">NULL</span>) &#123;</span><br><span class="line">RACDisposable *schedulingDisposable = [RACScheduler.subscriptionScheduler schedule:^&#123;</span><br><span class="line">RACDisposable *innerDisposable = <span class="keyword">self</span>.didSubscribe(subscriber);</span><br><span class="line">[disposable addDisposable:innerDisposable];</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[disposable addDisposable:schedulingDisposable];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>subscriptionScheduler</code> 是一个单例方法，返回 RACSubscriptionScheduler 对象</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 13 */</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)subscriptionScheduler &#123;</span><br><span class="line">   <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">   <span class="keyword">static</span> RACScheduler *subscriptionScheduler;</span><br><span class="line">   <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    subscriptionScheduler = [[RACSubscriptionScheduler alloc] init];</span><br><span class="line">   &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> subscriptionScheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继而调用 RACSubscriptionScheduler 的 <code>schedule</code> 方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 14 */</span></span><br><span class="line"></span><br><span class="line">- (RACDisposable *)schedule:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line"><span class="built_in">NSCParameterAssert</span>(block != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RACScheduler.currentScheduler == <span class="literal">nil</span>) <span class="keyword">return</span> [<span class="keyword">self</span>.backgroundScheduler schedule:block];</span><br><span class="line"></span><br><span class="line">block();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)isOnMainThread &#123;</span><br><span class="line"><span class="keyword">return</span> [<span class="built_in">NSOperationQueue</span>.currentQueue isEqual:<span class="built_in">NSOperationQueue</span>.mainQueue] || [<span class="built_in">NSThread</span> isMainThread];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (RACScheduler *)currentScheduler &#123;</span><br><span class="line">RACScheduler *scheduler = <span class="built_in">NSThread</span>.currentThread.threadDictionary[RACSchedulerCurrentSchedulerKey];</span><br><span class="line"><span class="keyword">if</span> (scheduler != <span class="literal">nil</span>) <span class="keyword">return</span> scheduler;</span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.class isOnMainThread]) <span class="keyword">return</span> RACScheduler.mainThreadScheduler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <code>schedule</code> 方法中主要先去找当前线程对应的 RACScheduler 对象，如果找不到，则去找主线程对应的 RACScheduler 对象，如果还是找不到，则返回 backgroundScheduler 对象。</p><p> <code>schedule</code>  方法目的是主要释放参数 block，也就是执行代码12中</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 15 */</span></span><br><span class="line"></span><br><span class="line">RACDisposable *innerDisposable = <span class="keyword">self</span>.didSubscribe(subscriber);</span><br><span class="line">[disposable addDisposable:innerDisposable];</span><br></pre></td></tr></table></figure><p>代码 4 中保存的闭包 <code>didSubscribe</code> 会在这里执行，进而可能调用闭包入参 subscriber（也就是之前创建的RACPassthroughSubscriber对象） 的 sendNext，sendError，sendCompleted 方法</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 16 */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.disposable.disposed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RACSIGNAL_NEXT_ENABLED()) &#123;</span><br><span class="line">RACSIGNAL_NEXT(cleanedSignalDescription(<span class="keyword">self</span>.signal), cleanedDTraceString(<span class="keyword">self</span>.innerSubscriber.description), cleanedDTraceString([value description]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.innerSubscriber sendNext:value];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.disposable.disposed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RACSIGNAL_ERROR_ENABLED()) &#123;</span><br><span class="line">RACSIGNAL_ERROR(cleanedSignalDescription(<span class="keyword">self</span>.signal), cleanedDTraceString(<span class="keyword">self</span>.innerSubscriber.description), cleanedDTraceString(error.description));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.innerSubscriber sendError:error];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendCompleted &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">self</span>.disposable.disposed) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (RACSIGNAL_COMPLETED_ENABLED()) &#123;</span><br><span class="line">RACSIGNAL_COMPLETED(cleanedSignalDescription(<span class="keyword">self</span>.signal), cleanedDTraceString(<span class="keyword">self</span>.innerSubscriber.description));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.innerSubscriber sendCompleted];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RACPassthroughSubscriber 在以上的方法会将信号事件转发给 innerSubscriber，因为 innerSubscriber 是 RACSubscriber 对象，进而会执行私有类 RACSubscriber 中的方法 sendNext/sendError/sendCompleted</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码 17 */</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendNext:(<span class="keyword">id</span>)value &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">void</span> (^nextBlock)(<span class="keyword">id</span>) = [<span class="keyword">self</span>.next <span class="keyword">copy</span>];</span><br><span class="line"><span class="keyword">if</span> (nextBlock == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">nextBlock(value);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendError:(<span class="built_in">NSError</span> *)e &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">void</span> (^errorBlock)(<span class="built_in">NSError</span> *) = [<span class="keyword">self</span>.error <span class="keyword">copy</span>];</span><br><span class="line">[<span class="keyword">self</span>.disposable dispose];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (errorBlock == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line">errorBlock(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)sendCompleted &#123;</span><br><span class="line"><span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="keyword">void</span> (^completedBlock)(<span class="keyword">void</span>) = [<span class="keyword">self</span>.completed <span class="keyword">copy</span>];</span><br><span class="line">[<span class="keyword">self</span>.disposable dispose];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (completedBlock == <span class="literal">nil</span>) <span class="keyword">return</span>;</span><br><span class="line">completedBlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上面方法前，都会先加锁保证线程安全，然后将对应的block（<strong>代码 8</strong> 创建 RACSubscriber 保存的 <code>_next</code>/<code>_error</code>/<code>_completed</code>）进行一次 copy，最后执行 block，最终的结果就是执行 <strong>代码 1</strong> 中的 <code>STEP 2</code> 、<code>STEP 3</code>、<code>STEP 4</code>。</p><p>基于以上的分析，RACSignal 从创建到给订阅发送事件可以归纳为以下几个步骤：</p><ol><li>调用RACSignal  <code>createSignal</code> 的方法，返回子类 RACDynamicSignal 对象并保存闭包 didSubscribe – <strong>代码 1</strong></li><li>订阅信号，调用RACSignal <code>subscribeNext</code>  方法，在该方法中会创建 RACSubscriber 订阅者对象</li><li>创建的 RACSubscriber 订阅者对象会copy nextBlock，errorBlock，completedBlock，保存到相关属性中 – <strong>代码 7</strong></li><li>调用步骤1创建的 RACDynamicSignal <code>subscribe</code> 方法</li><li>创建 RACCompoundDisposable 和 RACPassthroughSubscriber 对象，RACPassthroughSubscriber 会保存 步骤1返回的 RACDynamicSignal（signal属性），步骤2中的 RACSubscriber（innerSubscriber属性）– <strong>代码 11</strong></li><li>执行 RACDynamicSignal 保存的 didSubscribe 闭包，闭包内调用 RACPassthroughSubscriber <code>sendNext</code>，<code>sendError</code>，<code>sendCompleted</code> 方法</li><li>RACPassthroughSubscriber 执行保存的 innerSubscriber 对应的 <code>sendNext</code>，<code>sendError</code>，<code>sendCompleted</code> 方法 — <strong>代码 17</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ReactiveCocoa </tag>
            
            <tag> iOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSURLConnetion与NSURLSession的区别</title>
      <link href="/2018/12/26/NSURLConnetion%E4%B8%8ENSURLSession%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2018/12/26/NSURLConnetion%E4%B8%8ENSURLSession%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点:"></a>相同点:</h2><p>一、当服务器返回的数据较小时，NSURLSession与NSURLConnection执行普通任务的操作步骤没有区别；<br>二、 执行上传任务时，NSURLSession与NSURLConnection一样同样需要设置POST请求的请求体进行上传；</p><a id="more"></a><ul><li>1、比如进行普通的Get/Post请求<br><code>说明：任何NSURLRequest默认都是get请求。</code><ul><li>（1）创建一个NSURL对象，设置请求路径（设置请求路径）</li><li>（2）传入NSURL创建一个NSURLRequest对象，设置请求头和请求体（创建请求对象</li><li>（3）使用NSURLConnection发送NSURLRequest（发送请求）</li></ul></li></ul><h3 id="NSURLConnetion"><a href="#NSURLConnetion" class="headerlink" title="NSURLConnetion:"></a>NSURLConnetion:</h3><ol><li><p>方法1：NSURLConnetion通过类方法直接发送request，通过闭包处理异步操作</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)connetionPost &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *username = <span class="keyword">self</span>.usernameText.text;</span><br><span class="line">    <span class="built_in">NSString</span> *pwd = [<span class="keyword">self</span> base64Encode:<span class="keyword">self</span>.pwdText.text];</span><br><span class="line">    <span class="built_in">NSString</span> *urlString = <span class="string">@"http://10.0.1.7/login.php"</span>;</span><br><span class="line">    urlString = [urlString stringByAddingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:urlString];</span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">    request.HTTPMethod = <span class="string">@"POST"</span>;</span><br><span class="line">    <span class="built_in">NSString</span> *bodyString = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"username=%@&amp;password=%@"</span>, username, pwd];</span><br><span class="line">request.HTTPBody = [bodyString dataUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步请求，代码会阻塞在这里一直等待服务器返回，如果data为nil则请求失败，当获取少量数据时可以使用此方法。</span></span><br><span class="line">    <span class="comment">// sendSynchronousRequest:(NSURLRequest *)request returningResponse:(NSURLResponse * _Nullable * _Nullable)response error:(NSError **)error</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意，block的执行线程为queue，如果block涉及到UI操作，则必须回到主线程：[NSOperationQueue mainQueue]</span></span><br><span class="line">    [<span class="built_in">NSURLConnection</span> sendAsynchronousRequest:request queue:[<span class="built_in">NSOperationQueue</span> mainQueue] completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *connectionError) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSDictionary</span> *result = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="number">0</span> error:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据处理代码...</span></span><br><span class="line">    &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><ol start="2"><li><p>方法2：获取NSURLConnetion对立对象，将对象加入到runloop，通过delegate回调获取数据</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建连接有三个方法需要了解一下</span></span><br><span class="line"><span class="comment">// 该方法是NSURLConnection的默认构造函数，startImmediately参数，如果为YES，代表会将当前的connection实例加入到当前的runloop中，该connection的delegate的回调方法都会在当前线程执行，自动实现调度，所以这种情况下甚至是不需要调用 -start方法来开始请求；</span></span><br><span class="line"><span class="comment">//如果为NO，则需要手动调度，将当前的connection加入到一个线程的runloop中（如果不添加，默认会添加到当前线程的runloop中）。</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)request delegate:(<span class="keyword">nullable</span> <span class="keyword">id</span>)delegate startImmediately:(<span class="built_in">BOOL</span>)startImmediately  startImmediately;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实质为调用用的 [self initWithRequest:request delegate:delegate startImmediately:YES];</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)request delegate:(<span class="keyword">nullable</span> <span class="keyword">id</span>)delegate ;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类方法，不需要手动调用[connection start]，加入到当前的Runloop</span></span><br><span class="line">+ (<span class="built_in">NSURLConnection</span>*)connectionWithRequest:(<span class="built_in">NSURLRequest</span> *)request delegate:(<span class="keyword">id</span>)delegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">self</span>.connection = [<span class="built_in">NSURLConnection</span> connectionWithRequest:<span class="keyword">self</span>.request delegate:<span class="keyword">self</span>];</span><br><span class="line"><span class="comment">// 设置运行循环</span></span><br><span class="line">[<span class="keyword">self</span>.connection scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line"><span class="comment">// 设置代理工作队列</span></span><br><span class="line">[<span class="keyword">self</span>.connection setDelegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br></pre></td></tr></table></figure><p>使用代理模式需要实现NSURLConnectionDataDelegate协议，此协议提供了几个代理方法，涵盖了请求交互的几个步骤</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当接收到服务器响应时调用，response为响应头部</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收到服务返回的数据时调用，多次调用，直至接受到全部数据，每次接受一部分数据，放入到data中</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据接收完成是调用</span></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> *)connection;</span><br><span class="line"></span><br><span class="line"><span class="comment">//监控上传数据的进度，再上传数据时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection   didSendBodyData:(<span class="built_in">NSInteger</span>)bytesWritten</span><br><span class="line">                                                 totalBytesWritten:(<span class="built_in">NSInteger</span>)totalBytesWritten</span><br><span class="line">                                         totalBytesExpectedToWrite:(<span class="built_in">NSInteger</span>)totalBytesExpectedToWrite;</span><br><span class="line"></span><br><span class="line"><span class="comment">//请求错误（失败）的时候调用</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didFailWithError:(<span class="built_in">NSError</span> *)error;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="NSURLSession"><a href="#NSURLSession" class="headerlink" title="NSURLSession:"></a>NSURLSession:</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)SessionPost &#123;</span><br><span class="line">    <span class="comment">// 苹果直接提供了一个全局的session</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *task = [[<span class="built_in">NSURLSession</span> sharedSession] dataTaskWithRequest:[<span class="keyword">self</span> request] completionHandler:^(<span class="built_in">NSData</span> * _Nullable data, <span class="built_in">NSURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">        <span class="comment">// 处理数据</span></span><br><span class="line">    &#125;];</span><br><span class="line">    <span class="comment">// 需要把任务开始。 默认都是挂起</span></span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点:"></a>不同点:</h2><h3 id="一、-普通任务和上传"><a href="#一、-普通任务和上传" class="headerlink" title="一、 普通任务和上传"></a>一、 普通任务和上传</h3><p>NSURLSession针对下载/上传等复杂的网络操作提供了专门的解决方案，针对普通、上传和下载分别对应三种不同的网络请求任务：<code>NSURLSessionDataTask</code>,  <code>NSURLSessionUploadTask</code> 和 <code>NSURLSessionDownloadTask</code>。创建的task都是<code>挂起</code>状态，需要resume才能执行。</p><h3 id="二、-下载任务方式"><a href="#二、-下载任务方式" class="headerlink" title="二、 下载任务方式"></a>二、 下载任务方式</h3><p>NSURLConnection下载文件时，先将<code>整个文件下载到内存</code>，然后再写入沙盒，如果文件比较大，就会出现内存暴涨的情况。而使用NSURLSessionUploadTask下载文件，会默认下载到沙盒中的tem文件夹中，不会出现内存暴涨的情况，但在<code>下载完成后会将tem中的临时文件删除</code>，需要在初始化任务方法时，在completionHandler回调中增加保存文件的代码。</p><p>具体差别还可以分为以下几个部分：</p><ol><li><p>NSURLConnettion下载主要问题：</p><ul><li><p>没有办法直接跟踪到下载的进度</p></li><li><p>会出现内存峰值</p></li></ul><p>首先建立下载的请求：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *urlString = <span class="string">@"http://dldir1.qq.com/invc/tt/QQBrowser_for_Mac.dmg"</span>;</span><br><span class="line">    urlString = [urlString stringByAddingPercentEscapesUsingEncoding:<span class="built_in">NSUTF8StringEncoding</span>];</span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:urlString];</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:url cachePolicy:<span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span> timeoutInterval:<span class="number">10.0</span>];</span><br><span class="line">    <span class="comment">// NSURLRequestReloadIgnoringLocalCacheData  忽略本地的缓存数据</span></span><br><span class="line">    <span class="keyword">self</span>.conn = [<span class="built_in">NSURLConnection</span> connectionWithRequest:request delegate:<span class="keyword">self</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置运行循环</span></span><br><span class="line">    [<span class="keyword">self</span>.conn scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">    <span class="comment">// 设置代理工作队列，也就是代理回调会在子线程上进行</span></span><br><span class="line">    [<span class="keyword">self</span>.conn setDelegateQueue:[[<span class="built_in">NSOperationQueue</span> alloc] init]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)writeToSandbox:(<span class="built_in">NSData</span> *)data &#123;</span><br><span class="line">    <span class="built_in">NSFileHandle</span> *fp = [<span class="built_in">NSFileHandle</span> fileHandleForWritingAtPath:<span class="keyword">self</span>.targetPath];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">nil</span>) &#123;</span><br><span class="line">        [data writeToFile:<span class="keyword">self</span>.targetPath atomically:<span class="literal">YES</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [fp seekToEndOfFile];</span><br><span class="line">        [fp writeData:data];</span><br><span class="line">        [fp closeFile];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>delegate回调处理数据:</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 接收到服务器响应</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response &#123; </span><br><span class="line">    <span class="comment">// 保存要下载的文件的二进制数据长度，一边做进度观察</span></span><br><span class="line">    <span class="keyword">self</span>.expectedContentLength = response.expectedContentLength;</span><br><span class="line">    <span class="comment">//  清空当前下载的长度</span></span><br><span class="line">    <span class="keyword">self</span>.currentLength = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">self</span>.targetPath = [<span class="string">@"/Users/mac/Desktop"</span> stringByAppendingPathComponent:response.suggestedFilename];</span><br><span class="line">    [[<span class="built_in">NSFileManager</span> defaultManager] removeItemAtPath:<span class="keyword">self</span>.targetPath error:<span class="literal">NULL</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 接收到服务器数据</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> *)connection didReceiveData:(<span class="built_in">NSData</span> *)data &#123;    </span><br><span class="line">    <span class="comment">// 1&gt; 计算下载进度</span></span><br><span class="line">    <span class="keyword">self</span>.currentLength += data.length;</span><br><span class="line">    <span class="keyword">float</span> progress = (<span class="keyword">float</span>) <span class="keyword">self</span>.currentLength / <span class="keyword">self</span>.expectedContentLength;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%f %@"</span>, progress, [<span class="built_in">NSThread</span> currentThread]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSRunLoop</span> currentRunLoop] runMode:<span class="built_in">NSDefaultRunLoopMode</span> beforeDate:[<span class="built_in">NSDate</span> date]];</span><br><span class="line">        <span class="keyword">self</span>.progressView.progress = progress;</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2&gt; 拼接文件数据</span></span><br><span class="line">    [<span class="keyword">self</span> writeToSandbox:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决办法:</p><ul><li>在<code>- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response;</code>方法里面根据响应头返回缓存下来，然后在<code>- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data;</code>每次接受的数据的时候用属性<code>currentLength</code>保存已经下载的数据大小和<code>currentLength</code>比较进行进度跟踪</li><li>如果采用<code>sendAsynchronousRequest:queue:completionHandler:</code>方法进行下载，只有下载完了completionHandler返回整个文件的NSData大小，会导致内存峰值飙升；解决此问题可以采用delegate的回调方法<code>- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data;</code>每次接收到数据就写在硬盘上来避免</li></ul></li></ol><h3 id="三、断点续传的方式"><a href="#三、断点续传的方式" class="headerlink" title="三、断点续传的方式"></a>三、断点续传的方式</h3><ol><li><p><code>NSURLConnection</code>进行断点下载，通过设置访问请求的 <code>HTTPHeaderField</code> 的 <code>Range</code> 属性，开启运行循环，<code>NSURLConnection</code> 的代理方法作为运行循环的事件源，接收到下载数据时代理方法就会持续调用，并使 用 <code>NSOutputStream</code> 管道流进行数据保存。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置请求头信息，说明只需要请求该资源嗯一部分数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> bytes=0-1000   表示下载0-1000的数据</span></span><br><span class="line"><span class="comment"> bytes=0-       表示从0开始下载到下载完毕</span></span><br><span class="line"><span class="comment"> bytes=100-     表示从100开始下载到下载完毕</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line"><span class="built_in">NSString</span> *range = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"bytes=%zd-"</span>, <span class="keyword">self</span>.currentSize];</span><br><span class="line">[request setValue:range forHTTPHeaderField:<span class="string">@"Range"</span>];</span><br></pre></td></tr></table></figure></li><li><p><code>NSURLSession</code>进行断点下载，当暂停下载任务后，如果<code>downloadTask</code> （下载任务）为非空，调用 <code>- (void)cancelByProducingResumeData:(void (^)(NSData * _Nullable resumeData))completionHandler;</code>这个方法，这个方法接收一个参数，完成处理代码块，这个代码块有一个 NSData 参数 <code>resumeData</code>，如果 <code>resumeData</code> 非空，我们就保存这个对象到视图控制器的<code>resumeData</code> 属性中。在点击再次下载时，通过调用 <code>[ [self.session downloadTaskWithResumeData:self.resumeData]resume]</code> 方法进行继续下载操作。<br>经过以上比较可以发现，使用 <code>NSURLSession</code> 进行断点下载更加便捷。</p></li></ol><h3 id="四、请求方法的控制"><a href="#四、请求方法的控制" class="headerlink" title="四、请求方法的控制"></a>四、请求方法的控制</h3><ol><li><code>NSURLConnection</code> 实例化对象，实例化开始，默认请求就发送（同步发送），不需要调用 <code>start</code> 方法。而 <code>cancel</code>  可以停止请求的发送，停止后不能继续访问，需要创建新的请求。</li><li><code>NSURLSession</code> 有三个控制方法，取消（cancel），暂停（suspend），继续（resume），暂停后可以通过继续恢复当前的请求任务</li></ol><h3 id="五、-配置信息"><a href="#五、-配置信息" class="headerlink" title="五、 配置信息"></a>五、 配置信息</h3><p><code>NSURLSession</code> 的构造方法 <code>sessionWithConfiguration:delegate:delegateQueue</code>  中有一个  <code>NSURLSessionConfiguration</code> 类的参数可以设置配置信息，其决定了<code>cookie</code>，安全和高速缓存策略，最大主机连接数，资源管理，网络超时等配置。<code>NSURLConnection</code> 不能进行这个配置，相比于 <code>NSURLConnection</code> 依赖于一个全局的配置对象，缺乏灵活性而言，<code>NSURLSession</code> 有很大的改进了。</p><p>NSURLSession可以设置三种配置信息，分别通过调用三个累方法返回配置对象：</p><pre><code>1. `(NSURLSessionConfiguration *)defaultSessionConfiguration`，配置信息使用基于硬盘的持久话Cache，保存用户的证书到钥匙串,使用共享cookie存储；2. `+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration` ，配置信息和default大致相同。除了，不会把cache，证书，或者任何和Session相关的数据存储到硬盘，而是存储在内存中，生命周期和Session一致。比如浏览器无痕浏览等功能就可以基于这个来做；3. `+ (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier`，配置信息可以创建一个可以在后台甚至APP已经关闭的时候仍然在传输数据的session。注意，后台Session一定要在创建的时候赋予一个唯一的identifier，这样在APP下次运行的时候，能够根据identifier来进行相关的区分。如果用户关闭了APP,IOS 系统会关闭所有的background Session。而且，被用户强制关闭了以后，IOS系统不会主动唤醒APP，只有用户下次启动了APP，数据传输才会继续</code></pre><h3 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h3><p>其中几点和NSURLConnetion相似：</p><h4 id="Cookie-策略"><a href="#Cookie-策略" class="headerlink" title="Cookie 策略"></a>Cookie 策略</h4><blockquote><p>HTTPCookieStorage存储了 session 所使用的 cookie。默认情况下会使用 NSHTTPCookieShorage的 +sharedHTTPCookieStorage这个单例对象，这与 NSURLConnection是相同的。<br>HTTPCookieAcceptPolicy决定了什么情况下 session 应该接受从服务器发出的 cookie。<br>HTTPShouldSetCookies指定了请求是否应该使用 session 存储的 cookie，即 HTTPCookieSorage属性的值。</p></blockquote><h4 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h4><blockquote><p>URLCredentialStorage存储了 session 所使用的证书。默认情况下会使用 NSURLCredentialStorage的 +sharedCredentialStorage这个单例对象，这与 NSURLConnection是相同的。TLSMaximumSupportedProtocol<br>和 TLSMinimumSupportedProtocol<br>确定 session 是否支持 <a href="http://zh.wikipedia.org/wiki/%E5%AE%89%E5%85%A8%E5%A5%97%E6%8E%A5%E5%B1%82" target="_blank" rel="noopener">SSL 协议</a>。</p></blockquote><h4 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h4><blockquote><p>URLCache是 session 使用的缓存。默认情况下会使用 NSURLCache的 +sharedURLCache这个单例对象，这与 NSURLConnection是相同的。requestCachePolicy指定了一个请求的缓存响应应该在什么时候返回。这相当于 NSURLRequest的 -cachePolicy方法。</p></blockquote><p>具体可以参考<a href="https://objccn.io/issue-5-4/" target="_blank" rel="noopener">从 NSURLConnection 到 NSURLSession</a>。<br>​    </p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iOS内存管理机制详解</title>
      <link href="/2018/12/26/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/12/26/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="iOS内存管理机制详解"><a href="#iOS内存管理机制详解" class="headerlink" title="iOS内存管理机制详解"></a>iOS内存管理机制详解</h1><h4 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h4><p>OC采用引用计数器对内存进行管理，当一个对象的引用计数（retainCount）为0，则被释放。<br><img src="http://upload-images.jianshu.io/upload_images/1433064-f1f79a1a47faea8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><a id="more"></a><p>引用计数分为两种：</p><ul><li>手动引用计数（MRC）</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MRC代码</span></span><br><span class="line"><span class="built_in">NSObject</span> * obj = [[<span class="built_in">NSObject</span> alloc] init]; <span class="comment">//引用计数为1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//不需要的时候</span></span><br><span class="line">[obj release] <span class="comment">//引用计数减1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//持有这个对象</span></span><br><span class="line">[obj <span class="keyword">retain</span>] <span class="comment">//引用计数加1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//放到AutoReleasePool</span></span><br><span class="line">[obj autorelease]<span class="comment">//在auto release pool释放的时候，引用计数减1</span></span><br></pre></td></tr></table></figure><ul><li>自动引用计数（ARC）</li></ul><p>比如如下ARC代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NSObject * obj;</span><br><span class="line">&#123;</span><br><span class="line">    obj = [[NSObject alloc] init]; //引用计数为1</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;%@&quot;,obj);</span><br></pre></td></tr></table></figure><p>OC的内存机制可以简单概括为：谁持有(retain)谁释放(release)。<code>retain</code>引用计数+1，<code>release</code>反之。</p><p>我们先看看那ratain和release内部是如何实现的。</p><p><strong>retain</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (id)retain &#123;</span><br><span class="line">    return ((id)self)-&gt;rootRetain();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline id objc_object::rootRetain()</span><br><span class="line">&#123;</span><br><span class="line">    if (isTaggedPointer()) return (id)this;</span><br><span class="line">    return sidetable_retain();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出retain底层是调用了<code>sidetable_retain()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">id objc_object::sidetable_retain()</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    assert(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];<span class="comment">//获取引用计数表</span></span><br><span class="line">    </span><br><span class="line">    table.lock(); <span class="comment">// 加锁</span></span><br><span class="line">    <span class="keyword">size_t</span>&amp; refcntStorage = table.refcnts[<span class="keyword">this</span>]; <span class="comment">// 根据对象的引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (! (refcntStorage &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        refcntStorage += SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock(); <span class="comment">// 解锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (id)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SideTable数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SideTable</span> &#123;</span></span><br><span class="line">    <span class="keyword">spinlock_t</span> slock;</span><br><span class="line">    RefcountMap refcnts;</span><br><span class="line">    <span class="keyword">weak_table_t</span> weak_table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过代码可以出，SideTable拥有一个<code>自旋锁</code>，一个引用计数map。这个引用计数的map以<code>对象的地址</code>作为key，引用计数作为value</p><p><strong>release</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">oneway</span> <span class="keyword">void</span>)release &#123;</span><br><span class="line">    ((<span class="keyword">id</span>)<span class="keyword">self</span>)-&gt;rootRelease();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> objc_object::rootRelease()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTaggedPointer()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> sidetable_release(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uintptr_t</span> objc_object::sidetable_release(<span class="keyword">bool</span> performDealloc)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></span><br><span class="line">    assert(!isa.nonpointer);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> do_dealloc = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    table.lock(); <span class="comment">// 加锁</span></span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>); <span class="comment">// 先找到对象的地址</span></span><br><span class="line">    <span class="keyword">if</span> (it == table.refcnts.end()) &#123;</span><br><span class="line">        do_dealloc = <span class="literal">true</span>; <span class="comment">//引用计数小于阈值，最后执行dealloc</span></span><br><span class="line">        table.refcnts[<span class="keyword">this</span>] = SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">        <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.</span></span><br><span class="line">        do_dealloc = <span class="literal">true</span>;</span><br><span class="line">        it-&gt;second |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        it-&gt;second -= SIDE_TABLE_RC_ONE; <span class="comment">//引用计数减去1</span></span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock(); <span class="comment">// 解锁</span></span><br><span class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>release过程：查找map，对引用计数减1，如果引用计数小于阈值，则调用SEL_dealloc</p><hr><blockquote><p>自己生成的对象，自己持有</p></blockquote><p>使用以下名称开头的方法意味着生成的对象会被自己持有，也就是内部会对象进行一次retain:</p><ul><li>alloc</li><li>new</li><li>copy</li><li>mutableCopy</li></ul><p>比如NSObject的alloc方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">id</span>)alloc &#123;</span><br><span class="line">    <span class="keyword">return</span> _objc_rootAlloc(<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Base class implementation of +alloc. cls is not nil.</span></span><br><span class="line"><span class="comment">// Calls [cls allocWithZone:nil].</span></span><br><span class="line"><span class="keyword">id</span></span><br><span class="line">_objc_rootAlloc(Class cls)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> callAlloc(cls, <span class="literal">false</span><span class="comment">/*checkNil*/</span>, <span class="literal">true</span><span class="comment">/*allocWithZone*/</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Call [cls alloc] or [cls allocWithZone:nil], with appropriate </span></span><br><span class="line"><span class="comment">// shortcutting optimizations.</span></span><br><span class="line"><span class="keyword">static</span> ALWAYS_INLINE <span class="keyword">id</span></span><br><span class="line">callAlloc(Class cls, <span class="keyword">bool</span> checkNil, <span class="keyword">bool</span> allocWithZone=<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(checkNil &amp;&amp; !cls)) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#if __OBJC2__</span></span><br><span class="line">    <span class="keyword">if</span> (fastpath(!cls-&gt;ISA()-&gt;hasCustomAWZ())) &#123;</span><br><span class="line">        <span class="comment">// No alloc/allocWithZone implementation. Go straight to the allocator.</span></span><br><span class="line">        <span class="comment">// fixme store hasCustomAWZ in the non-meta class and </span></span><br><span class="line">        <span class="comment">// add it to canAllocFast's summary</span></span><br><span class="line">        <span class="keyword">if</span> (fastpath(cls-&gt;canAllocFast())) &#123;</span><br><span class="line">            <span class="comment">// No ctors, raw isa, etc. Go straight to the metal.</span></span><br><span class="line">            <span class="keyword">bool</span> dtor = cls-&gt;hasCxxDtor();</span><br><span class="line">            <span class="keyword">id</span> obj = (<span class="keyword">id</span>)calloc(<span class="number">1</span>, cls-&gt;bits.fastInstanceSize()); <span class="comment">// 在这里，obj创建的时候，obj的retainCount = 1</span></span><br><span class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</span><br><span class="line">            obj-&gt;initInstanceIsa(cls, dtor);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Has ctor or raw isa or something. Use the slower path.</span></span><br><span class="line">            <span class="keyword">id</span> obj = class_createInstance(cls, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (slowpath(!obj)) <span class="keyword">return</span> callBadAllocHandler(cls);</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No shortcuts available.</span></span><br><span class="line">    <span class="keyword">if</span> (allocWithZone) <span class="keyword">return</span> [cls allocWithZone:<span class="literal">nil</span>];</span><br><span class="line">    <span class="keyword">return</span> [cls alloc];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于OC提供的方法，除了上面几种，比如说[NSMutableArray array]，通过这些方法获取到的对象并不对其进行持有，内部会将生成的对象放入到自动释放池上</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取得非自己生成而且不持有的对象</span></span><br><span class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行retain之后，obj持有了对象</span></span><br><span class="line">[obj <span class="keyword">retain</span>];</span><br></pre></td></tr></table></figure><p>再比如如果我们定义一个方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)object &#123;</span><br><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加入自动释放池，pool销毁的池销毁的同事对obj进行release一次</span></span><br><span class="line">[obj autorelease]; </span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1433064-009725fec2b88f71.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><hr><blockquote><p>无法释放非自己持有的对象</p></blockquote><p>就像上面的 <code>id obj1 = [obj1 object]</code>，obj并没有持有对象，如果这时候我们主动调用<code>[obj1 release]</code>就会发生崩溃。</p><p>还有一种情况就是已经被释放的对象再对其进行release操作的时候也会发生崩溃</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">[obj release];</span><br><span class="line"></span><br><span class="line">[obj release]; <span class="comment">// crash</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>ARC中常见的所有权关键字</p></blockquote><ul><li>assign对应关键字__unsafe_unretained, 顾名思义，就是指向的对象被释放的时候，仍然指向之前的地址，容易引起野指针。</li><li>copy对应关键字__strong,只不过在赋值的时候，调用copy方法。</li><li>retain对应__strong</li><li><p>strong对应__strong</p><p>__strong修饰符是id类型和对象类型默认的所有权修饰符。也就是说，以下源代码中的id变量，实际上被附加了所有权修饰词：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure></li><li><p>weak 对应 __weak</p><p>weak是用来替代unsafe_unretained，weak修饰符的变量(即弱引用)不持有对象，所以在超出其作用域时，对象就会释放，所以因为强引用而造成的循环引用，将其中的成员变量改为弱引用，就不会发生相同情况。</p><p>在持有某若引用时，若该对象被废弃，则此弱引用将自动失效且处于nil被赋值状态(空弱引用)。</p></li><li><p>unsafe_unretained 对应 __unsafe_unretained</p></li></ul><p>unsafe unretained与weak修饰符一样不会增加引用计数，自己生成的对象不能继续为自己所有，所以会立即释放。</p><blockquote><p>iOS4以及OS X Snow Leopard的应用程序中，必须使用unsafe unretained修饰符来替代weak修饰符。赋值给附有__unsafe unretained修饰符变量的对象在通过该变量使用时，如果没有确保其存在，那么应用就会崩溃。</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">unsafe_unretained</span> obj1 = <span class="literal">nil</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj0 = [<span class="built_in">NSObject</span> new];</span><br><span class="line">obj1 = obj0;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"A: %@"</span>, obj1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">"%@"</span>, [obj1 description];);</span><br></pre></td></tr></table></figure><p>如果像上面那样，程序就会崩溃，因为obj0被销毁之后，obj1并不会自动置为nil。</p><hr><blockquote><p>__bridge</p></blockquote><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">void</span> *p = (__bridge <span class="keyword">void</span> *)obj;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">id</span> o = (__bridge <span class="keyword">id</span>)p;</span><br></pre></td></tr></table></figure><p>将Objective-C的对象类型用 <code>__bridge</code> 转换为 void* 类型和使用 <code>__unsafe_unretained</code> 关键字修饰的变量是一样的</p><p><code>__bridge</code>转换中还有另外两种转换，分别是” <code>__bridge_retained</code>转换”和” <code>__bridge_transfer</code>转换”</p><ul><li><code>__bridge_retained</code>转换可使要转换赋值的变量也持有所赋值的对象。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MRC</span></span><br><span class="line"><span class="keyword">void</span> *p = <span class="number">0</span>;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> new]; <span class="comment">// retainCount = 1</span></span><br><span class="line">p = (__bridge_retained <span class="keyword">void</span> *)obj; <span class="comment">// retainCount = 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class=%@"</span>, [(__bridge <span class="keyword">id</span>)p <span class="keyword">class</span>]);</span><br><span class="line"><span class="comment">// log:class=NSObject</span></span><br></pre></td></tr></table></figure><ul><li><code>__bridge_transfer</code>转换提供与次相反的动作，被转换的变量所持有的对象在该变量被赋值给转换目标变量后随之释放。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id p = (__bridge_transfer id)p;</span><br></pre></td></tr></table></figure><p>等效于：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MRC</span></span><br><span class="line"><span class="keyword">id</span> obj = (<span class="keyword">id</span>)p;</span><br><span class="line">[obj <span class="keyword">retain</span>];</span><br><span class="line">[(<span class="keyword">id</span>)p release];</span><br></pre></td></tr></table></figure><p>同<code>__bridge_retained</code>和<code>retain</code>类似，<code>__bridge_transfer</code>与<code>release</code>相似。    在给id obj赋值时retain即相当于__strong修饰符的变量。</p><p>如果使用以上两种转换，那么不是用id类型或者对象型变量也可以生成、持有以及释放对象。虽然可以这样做，但是ARC中并不推荐。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = (__bridge_retained <span class="keyword">void</span> *)[<span class="built_in">NSObject</span> new];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class = %@"</span>, [(__bridge <span class="keyword">id</span>)p <span class="keyword">class</span>]);</span><br><span class="line">(<span class="keyword">void</span>)(__bridge_transfer <span class="keyword">id</span>)p;</span><br></pre></td></tr></table></figure><p>和下面代码等效</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MRC</span></span><br><span class="line"><span class="keyword">id</span> p = <span class="built_in">NSObject</span> new];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"class = %@"</span>, [p <span class="keyword">class</span>]);</span><br><span class="line">[p release];</span><br></pre></td></tr></table></figure><hr><blockquote><p>Objective-C对象与Core Foundation对象</p></blockquote><p>Core Foundation对象主要使用在C语言编写的Core Foundation框架中，并是用引用计数的对象。在ARC无效时，Core Foundation框架中的retain/release分别是CFRetain/CFRelease。</p><p>因为Core Foundation对象与OC对象没有区别，所以在MRC时，只用简单的C语言的转换也能实现互换。另外这种转换不需要使用额外的CPU资源，因此也被称为”Toll-Free Bridge”</p><p>以下函数可用于OC对象和Core Foundation对象之间的相互变换，即Toll-Free Bridge转换：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CFTypeRef <span class="title">CFBridgingRetain</span><span class="params">(id x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (__bridge_retained CFTypeRef) x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">id <span class="title">CFBridgingRelease</span><span class="params">(CFTypeRef x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (__bridge_transfer id)x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFMutableArrayRef</span> cfObj = <span class="literal">NULL</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">NSMutableArray</span> *obj = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">            cfObj = <span class="built_in">CFBridgingRetain</span>(obj);</span><br><span class="line">            <span class="built_in">CFShow</span>(cfObj);</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"retainCount = %ld"</span>, <span class="built_in">CFGetRetainCount</span>(cfObj));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"after retainCount = %ld"</span>, <span class="built_in">CFGetRetainCount</span>(cfObj));</span><br><span class="line">        <span class="built_in">CFRelease</span>(cfObj);</span><br></pre></td></tr></table></figure><p>效果如下</p><p><img src="http://upload-images.jianshu.io/upload_images/1433064-42edad862f029a28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>还可以通过__bridge_retained来替代CFBridgingRetain</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFMutableArrayRef cfObject = (__bridge_retained CFMutableArrayRef)obj;</span><br></pre></td></tr></table></figure><p>反过来</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFMutableArrayRef</span> cfObj = <span class="built_in">CFArrayCreateMutable</span>(kCFAllocatorDefault, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retainCount = %ld"</span>, <span class="built_in">CFGetRetainCount</span>(cfObj));</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> obj = <span class="built_in">CFBridgingRelease</span>(cfObj);</span><br><span class="line"><span class="comment">// CFRelease(cfObj);</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"after retainCount = %ld"</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(obj)));</span><br></pre></td></tr></table></figure><p>打印出来：<br><img src="http://upload-images.jianshu.io/upload_images/1433064-9b3726b501667271.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>和书上的结果好像不一样，如果加上CFRelsease就正常了，这个点没有搞清楚:</p><p><img src="http://upload-images.jianshu.io/upload_images/1433064-4c427aa2bcad9558.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果我们直接用__bridge_transfer进行转换，结果几就过就正常了：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CFMutableArrayRef</span> cfObj = <span class="built_in">CFArrayCreateMutable</span>(kCFAllocatorDefault, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"retainCount = %ld"</span>, <span class="built_in">CFGetRetainCount</span>(cfObj));</span><br><span class="line"></span><br><span class="line"><span class="comment">//NSMutableArray *obj = CFBridgingRelease(cfObj);</span></span><br><span class="line">            </span><br><span class="line"><span class="built_in">NSMutableArray</span> *obj = (__bridge_transfer <span class="built_in">NSMutableArray</span> *)(cfObj);</span><br><span class="line"><span class="comment">//CFRelease(cfObj);</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"after retainCount = %ld"</span>, <span class="built_in">CFGetRetainCount</span>((__bridge <span class="built_in">CFTypeRef</span>)(obj)));</span><br></pre></td></tr></table></figure><p><img src="http://upload-images.jianshu.io/upload_images/1433064-3e11eb018b7a0dd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><hr><h4 id="ARC运行时的优化"><a href="#ARC运行时的优化" class="headerlink" title="ARC运行时的优化"></a>ARC运行时的优化</h4><p>ARC不只是在编译时由编译器进行内存管理，实际上在此基础还借助了OC运行时库。也就是说，ARC由以下工具、库实现：</p><ul><li>clang(LLVM编译器)3.0以上</li><li>objc4 Objective-C运行时库493.9以上</li></ul><p><strong>__strong修饰符</strong></p><p>赋值给__strong修饰的变量：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看作成：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</span><br><span class="line">objc_msgSend(obj, <span class="keyword">@selector</span>(init));</span><br><span class="line">objc_release(obj);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用2次objc_msgSend方法，变量作用域结束时，objc_release释放对象。</span></span><br><span class="line"><span class="comment">// 由此看出编译器会自动插入release操作。</span></span><br></pre></td></tr></table></figure><hr><p><strong>使用alloc/new/copy/mutableCopy以外的方法：</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看作：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = objc_msgSend(<span class="built_in">NSMutableArray</span>, <span class="keyword">@selector</span>(array));</span><br><span class="line">objc_retainAutoreleaseReturnValue(obj);</span><br><span class="line">objc_release(obj);</span><br></pre></td></tr></table></figure><p>这里和上面区别主要是<code>objc_retainAutoreleaseReturnValue</code>，该函数主要用于优化程序运行，<code>objc_retainAutoreleaseReturnValue</code>的入参是返回<code>注册在autoreleasepool</code>中的对象的方法/函数的<code>返回值</code>。编译器会在alloc/new/copy/mutableCopy<code>以外</code>的方法调用外部插入。</p><p>上面所说的功能实现的时候是需要<code>objc_retainAutoreleaseReturnValue</code>和<code>objc_autoreleaseReturnValue</code>配合完成，任何不在alloc/new/copy/mutableCopy组中的方法必须调<code>objc_autoreleaseReturnValue</code>。 例如，NSMutableArray类方法“array”调用此函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (id)array &#123;</span><br><span class="line">return [[NSMutableArray alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* pseudo code by the compiler */ </span><br><span class="line">+ (id) array &#123;</span><br><span class="line">id obj = objc_msgSend(NSMutableArray, @selector(alloc)); objc_msgSend(obj, @selector(init));</span><br><span class="line">return objc_autoreleaseReturnValue(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任何返回添加到自动释放池的对象的方法都将调用<code>objc_autoreleaseReturnValue</code>函数，如上例所示。 它将一个对象添加到自动释放池并返回。 但是实际上<code>objc_autoreleaseReturnValue</code>不会一直注册到自动释放池。</p><p><code>objc_autoreleaseReturnValue</code>检查调用者的可执行代码，如果代码在调用此方法后调用<code>objc_retainAutoreleasedReturnValue</code>函数，它将跳过注册到自动释放池，并将对象返回给调用者。 即使<code>objc_autoreleaseReturnValue</code>没有将对象注册到自动释放池，<code>objc_retainAutoreleasedReturnValue</code>函数也可以正确地获得这样的对象。 通过<code>objc_autoreleaseReturnValue</code>和<code>objc_retainAutoreleasedReturnValue</code>的合作，对象绕过被添加到自动释放池。</p><p>一般来说：检验了主调方在返回值之后是否紧接着调用了<code>objc_retainAutoreleasedReturnValue</code>，如果是，就知道了外部是ARC环境，反之就走没被优化的老逻辑。</p><p><img src="http://upload-images.jianshu.io/upload_images/1433064-cc6339039b4c2204.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><hr><p><strong>__weak修饰符</strong></p><ul><li>当引用对象被丢弃时，__weak修饰的变量会赋值为nil。</li><li>通过__weak限定变量访问对象时，该对象将添加到自动释放池。</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj; <span class="comment">// 假色obj诶__strong修饰且对象被赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pseudo code by the compiler */</span> </span><br><span class="line">id obj1;</span><br><span class="line">objc_initWeak(&amp;obj1, obj); </span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></table></figure><p>通过<code>objc_initWeak</code>初始化__weak修饰的变量，在变量作用域结束时通过<code>objc_destroyWeak</code>释放该变量。</p><p>objc4源码中<code>objc_initWeak</code>和<code>objc_destroyWeak</code>的具体实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">objc_initWeak</span><span class="params">(id *location, id newObj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!newObj) &#123;</span><br><span class="line">        *location = nil;</span><br><span class="line">        <span class="keyword">return</span> nil;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> storeWeak&lt;<span class="literal">false</span><span class="comment">/*old*/</span>, <span class="literal">true</span><span class="comment">/*new*/</span>, <span class="literal">true</span><span class="comment">/*crash*/</span>&gt;</span><br><span class="line">        (location, (objc_object*)newObj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_destroyWeak</span><span class="params">(id *location)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    (<span class="keyword">void</span>)storeWeak&lt;<span class="literal">true</span><span class="comment">/*old*/</span>, <span class="literal">false</span><span class="comment">/*new*/</span>, <span class="literal">false</span><span class="comment">/*crash*/</span>&gt;</span><br><span class="line">        (location, nil);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，本质上都是调用了<code>storeWeak</code>函数，<code>storeWeak</code>函数把第二参数的赋值对象的地址作为<code>键值</code>，将第一个参数的附有__weak修饰符的变量的地址注册到weak表中。如果第二个参数为0/nil，则把变量的地址从weak表中删。</p><p>这个函数总结起来主要做了以下事情:</p><ul><li>获取存储weak对象的map，这个map的key是对象的地址，value是weak引用的地址</li><li>当对象被释放的时候，根据对象的地址可以找到对应的weak引用的地址，将其置为nil即可</li></ul><p>weak表与引用计数表都是采用<code>散列表</code>实现。另外，由于一哥对象可以同时赋值给多个__waek对象修饰符的变量中，对于一个键值，可以注册多个变量的地址。</p><p>释放对象的时候，一般经历下面几个操作：</p><ol><li>objc_release</li><li>因为引用计数为0所以执行dealloc</li><li>_objc_rootDealloc</li><li>object_dispose</li><li>objc_destructInstance</li><li>objc_clear_deallocating</li></ol><p>对象被废弃时最后调用的objc_ckear_deallocating函数动作如下:</p><ol><li>从weak表中获取废弃对象的地址为键值的记录</li><li>将包含在记录中的所有附有__weak修饰符变量的地址，赋值为nil</li><li>从weak表伤处该记录</li><li>从应用计数表中删除废弃对象的地址为键值的记录</li></ol><p>通过上面的步骤可以看出，如果大量的是用<strong>weak修饰符的变量，会对cpu资源造成相应的消耗，一般只有在需要避免循环引用的时候是用</strong>weak修饰符。</p><p><img src="http://upload-images.jianshu.io/upload_images/1433064-6154df6246a24dae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>如果我们像上图那样，自己生成对象并复制给__weak变量，自己不能持有该对象，对象会马上被回收，引起编译器警告</p><p>编译器处理后代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pseudo code by the compiler </span></span><br><span class="line"><span class="comment">虽然自己生成并持有对象，但是编译器判断其没有持有责，因此被释放</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">id</span> obj;</span><br><span class="line"><span class="keyword">id</span> tmp = objc_msgSend(<span class="built_in">NSObject</span>, <span class="keyword">@selector</span>(alloc));</span><br><span class="line">objc_msgSend(tmp, <span class="keyword">@selector</span>(init)); </span><br><span class="line">objc_initWeak(&amp;obj, tmp);</span><br><span class="line">objc_release(tmp);</span><br><span class="line">objc_destroyWeak(&amp;obj);</span><br></pre></td></tr></table></figure><p>然后再来测试一下：使用__weak修饰符的变量是否会将对象注册到autoreleasepool。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="keyword">id</span> __<span class="keyword">weak</span> obj1 = obj;</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">"%@"</span>, obj1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 编译器的模拟代码 */</span></span><br><span class="line"><span class="keyword">id</span> obj1;</span><br><span class="line">objc_initWeak(&amp;obj1, obj);</span><br><span class="line"><span class="keyword">id</span> tmp = objc_loadWeakRetained(&amp;obj1);</span><br><span class="line">objc_autorelease(tmp);</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, tmp);</span><br><span class="line">objc_destroyWeak(&amp;obj1);</span><br></pre></td></tr></table></figure><p>与被赋值相比，在使用附有__weak修饰变量的情况下，增加了对<code>objc_loadWeakRetained</code>函数和<code>objc_autorelease</code>函数的调用。</p><ul><li><code>objc_loadWeakRetained</code>函数取出附有__weak修饰符变量所引用的对象并<strong>ratain</strong></li><li><code>objc_autorelease</code>函数将对象注册到autoreleasepool中</li></ul><p>由于附有<strong>weak修饰符变量所引用的对象能被注册到autoreleasepool中，所以在@autoreleasepool块结束前都能保证对象不被释放。但是，如果大流量地是用</strong>weak变量会导致autoreleasepool的对象也会大量地添加，因此在使用<strong>weak变量最好先暂时赋值给</strong>strong变量再是用后者。</p><p>这样就能解释我们平时用到的weak-strong-dance的原理了。以AFN的源码为例子：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">    strongSelf.networkReachabilityStatus = status;</span><br><span class="line">    <span class="keyword">if</span> (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">        strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面在闭包中利用把weakSelf赋值给strongSelf，保证在callback闭包执行的过程中，self不会被释放。</p><hr><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><ul><li>1、内敛函数</li></ul><blockquote><p>内联函数是指用inline关键字修饰的函数。内联函数不是在调用时发生控制转移，而是在编译时将函数体嵌入在每一个调用处。编译时，类似宏替换，使用函数体替换调用处的函数名。<a href="http://www.cnblogs.com/iosshare/archive/2016/05/11/5483330.html" target="_blank" rel="noopener">参考资料</a></p></blockquote><p>参考文章：<br><a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="noopener">黑幕背后的Autorelease</a><br><a href="http://www.jianshu.com/p/32265cbb2a26" target="_blank" rel="noopener">自动释放池的前世今生 —- 深入解析 Autoreleasepool</a><br><a href="http://blog.csdn.net/hello_hwc/article/details/70045334" target="_blank" rel="noopener">深入理解Objective C的ARC机制</a></p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> iOS </tag>
            
            <tag> 内存 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
